import*as r from"three";import{GUI as e}from"three/addons/libs/lil-gui.module.min.js";var n={accumulateFrag:"  vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + emissive;",ambientFrag:"  reflectedLight.indirectDiffuse += ambientColor * material.diffuseColor;",ambientFragPars:"uniform vec3 ambientColor;\r\n\r\nvec3 getAmbientLightIrradiance(const in vec3 ambient) {\r\n  return ambient;\r\n}",ambientHemisphereFrag:"  reflectedLight.indirectDiffuse += mix(groundColor, ambientColor, (dot(geometry.normal, normalize(skyDirection)) + 1.0) * 0.5) * material.diffuseColor;",ambientHemisphereFragPars:"uniform vec3 groundColor;\r\nuniform vec3 skyDirection;",ambientHemisphereUniforms:{groundColor:{value:new r.Color(4210752)},skyDirection:{value:new r.Vector3(0,1,0)}},ambientUniforms:{ambientColor:{value:new r.Color(0)}},anisotropyFrag:"// vec3 H = normalize(directLight.direction + geometry.viewDir);\r\n\r\n// reflectedLight.directDiffuse += material.diffuseColor * AnisotropyDiffuseTerm(material.diffuseColor, anisotropyColor, geometry.normal, directLight.direction, geometry.viewDir) * NoL * anisotropyStrength;\r\n  reflectedLight.directSpecular += AnisotropySpecularTerm(anisotropyExponent, geometry.normal, H, directLight.direction, geometry.viewDir, vTangent, vBinormal, anisotropyFresnel) * anisotropyColor * NoL * anisotropyStrength;\r\n\r\n// vec3 vObjPosition = normalize(geometry.position);\r\n// vec3 asHL = normalize(directLight.direction + vObjPosition);\r\n// vec3 asHH = normalize(asHL + geometry.viewDir);\r\n// float asHHU = dot(asHH, vTangent);\r\n// float asHHV = dot(asHH, vBinormal);\r\n// float asHHN = dot(asHH, vNormal);\r\n// float asHHK = dot(asHH, asHL);\r\n// float asHNU = 1.0;\r\n// float asHNV = anisotropyExponent;\r\n// float asHTerm1 = sqrt((asHNU + 1.0) * (asHNV + 1.0)) / (8.0 * PI);\r\n// float asHexponent = ((asHNU * asHHU * asHHU) + (asHNV * asHHV * asHHV)) / (1.0 - asHHN * asHHN);\r\n// float asHTerm2 = pow(asHHN, asHexponent);\r\n// float asHFresnelTerm = (anisotropyFresnel + (1.0 - anisotropyFresnel) * (1.0 - (pow2(asHHK) * pow3(asHHK))));\r\n// float asHSpecTerm = min(1.0, asHTerm1 * asHTerm2 * asHFresnelTerm * anisotropyStrength);\r\n// reflectedLight.directSpecular += asHSpecTerm * NoL * anisotropyColor;",anisotropyFragPars:"// http://asura.iaigiri.com/XNA_GS/xna19.html\r\nuniform float anisotropyExponent;\r\nuniform float anisotropyStrength;\r\nuniform float anisotropyFresnel;\r\nuniform vec3 anisotropyColor;\r\n// varying vec3 vObjPosition;\r\n// vec3 AnisotropyDiffuseTerm(vec3 Rd, vec3 Rs, vec3 N, vec3 k1, vec3 k2) {\r\n//   vec3 term1 = ((28.0 * Rd) / (23.0 * PI)) * (1.0 - Rs);\r\n//   float term2 = (1.0 - pow5(1.0 - dot(N, k1) * 0.5));\r\n//   float term3 = (1.0 - pow5(1.0 - dot(N, k2) * 0.5));\r\n//   return term1 * term2 * term3;\r\n// }\r\n// float nu = 1.0\r\nfloat AnisotropySpecularTerm(float nv, vec3 N, vec3 H, vec3 L, vec3 V, vec3 T, vec3 B, float F) {\r\n  float HU = dot(H, T);\r\n  float HV = dot(H, B);\r\n  float HN = dot(H, N);\r\n  float HK = dot(H, L);\r\n  float NL = dot(N, L);\r\n  float NV = dot(N, V);\r\n//   float exponent = ((nu * HU * HU) + (nv * HV * HV)) / (1.0 - HN * HN);\r\n//   float term1 = sqrt((nu + 1.0) * (nv + 1.0)) / (8.0 * PI);\r\n  float exponent = ((HU * HU) + (nv * HV * HV)) / (1.0 - HN * HN);\r\n  float term1 = sqrt(2.0 * (nv + 1.0)) / (8.0 * PI);\r\n  float term2 = pow(HN, exponent) / (HK * max(NL, NV));\r\n  float fresnel = F + (1.0 - F) * (1.0 - pow5(HK));\r\n  return term1 * term2 * fresnel;\r\n}",anisotropyUniforms:{anisotropyExponent:{value:100},anisotropyStrength:{value:1},anisotropyFresnel:{value:.5},anisotropyColor:{value:new r.Color}},antiAliasFrag:"uniform sampler2D tDiffuse;\r\nuniform vec2 resolution;\r\n\r\n#define FXAA_REDUCE_MIN (1.0/128.0)\r\n#define FXAA_REDUCE_MUL (1.0/8.0)\r\n#define FXAA_SPAN_MAX 8.0\r\n\r\nvoid main() {\r\n  vec3 rgbNW = texture2D(tDiffuse, (gl_FragCoord.xy + vec2(-1.0, -1.0)) * resolution).xyz;\r\n  vec3 rgbNE = texture2D(tDiffuse, (gl_FragCoord.xy + vec2( 1.0, -1.0)) * resolution).xyz;\r\n  vec3 rgbSW = texture2D(tDiffuse, (gl_FragCoord.xy + vec2(-1.0,  1.0)) * resolution).xyz;\r\n  vec3 rgbSE = texture2D(tDiffuse, (gl_FragCoord.xy + vec2( 1.0,  1.0)) * resolution).xyz;\r\n  vec4 rgbaM = texture2D(tDiffuse, gl_FragCoord.xy * resolution);\r\n  vec3 rgbM = rgbaM.xyz;\r\n  vec3 luma = vec3(0.299, 0.587, 0.114);\r\n\r\n  float lumaNW = dot(rgbNW, luma);\r\n  float lumaNE = dot(rgbNE, luma);\r\n  float lumaSW = dot(rgbSW, luma);\r\n  float lumaSE = dot(rgbSE, luma);\r\n  float lumaM  = dot(rgbM,  luma);\r\n  float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\r\n  float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\r\n\r\n  vec2 dir;\r\n  dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\r\n  dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\r\n\r\n  float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\r\n  float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\r\n  dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\r\n            max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), dir * rcpDirMin)) * resolution;\r\n  vec4 rgbA = (1.0/2.0) * (\r\n    texture2D(tDiffuse, gl_FragCoord.xy * resolution + dir * (1.0/3.0 - 0.5)) +\r\n    texture2D(tDiffuse, gl_FragCoord.xy * resolution + dir * (2.0/3.0 - 0.5)));\r\n  vec4 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\r\n    texture2D(tDiffuse, gl_FragCoord.xy * resolution + dir * (0.0/3.0 - 0.5)) +\r\n    texture2D(tDiffuse, gl_FragCoord.xy * resolution + dir * (3.0/3.0 - 0.5)));\r\n\r\n  float lumaB = dot(rgbB, vec4(luma, 0.0));\r\n\r\n  if ((lumaB < lumaMin) || (lumaB > lumaMax)) {\r\n    gl_FragColor = rgbA;\r\n  } else {\r\n    gl_FragColor = rgbB;\r\n  }\r\n}",antiAliasUniforms:{tDiffuse:{value:null},resolution:{value:new r.Vector2(1/1024,1/512)}},antiAliasVert:"void main() {\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}",aoMapFrag:"  float obscure = texture2D(tAO, vUv).r * aoStrength;\r\n  reflectedLight.directDiffuse *= obscure;\r\n  reflectedLight.directDiffuse += reflectedLight.directSpecular * obscure;\r\n  reflectedLight.directSpecular = vec3(0.0);",aoMapFragPars:"uniform sampler2D tAO;\r\nuniform float aoStrength;",aoMapUniforms:{tAO:{value:null},aoStrength:{value:1}},beginFrag:"  GeometricContext geometry;\r\n  geometry.position = -vViewPosition;\r\n  geometry.normal = normalize(vNormal);\r\n  geometry.viewDir = normalize(vViewPosition);\r\n\r\n  Material material;\r\n  material.diffuseColor = diffuseColor;\r\n  material.opacity = opacity;\r\n\r\n  ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\r\n  vec3 emissive = vec3(0.0);",beginFragDebug:"vec3 debugColor = vec3(1.0, 0.0, 0.0);",billboardDefaultVert:"  mat3 invMatrix = mat3(ViewInverse[0].xyz, ViewInverse[1].xyz, ViewInverse[2].xyz);",billboardRotZVertEnd:"  vec3 rotX = vec3(0.0);\r\n  vec3 rotY = vec3(0.0);\r\n  vec3 rotZ = vec3(0.0);\r\n  if (wscale.x > 0.0) rotX = row0 / wscale.x;\r\n  if (wscale.y > 0.0) rotY = row1 / wscale.y;\r\n  if (wscale.z > 0.0) rotZ = row2 / wscale.z;\r\n  vec3 pos = invMatrix * mat3(rotX, rotY, rotZ) * position;\r\n  vec3 wpos = pos * wscale + wtrans;\r\n  vec4 hpos = projectionMatrix * viewMatrix * vec4(wpos, 1.0);",billboardUniforms:{ViewInverse:{value:new r.Matrix4}},billboardVert:"void main() {\r\n  vec3 row0 = vec3(modelMatrix[0].x, modelMatrix[1].x, modelMatrix[2].x);\r\n  vec3 row1 = vec3(modelMatrix[0].y, modelMatrix[1].y, modelMatrix[2].y);\r\n  vec3 row2 = vec3(modelMatrix[0].z, modelMatrix[1].z, modelMatrix[2].z);\r\n  vec3 wscale = vec3(length(row0), length(row1), length(row2));\r\n  vec3 wtrans = modelMatrix[3].xyz;",billboardVertEnd:"  vec3 pos = invMatrix * position;\r\n  vec3 wpos = pos * wscale + wtrans;\r\n  vec4 hpos = projectionMatrix * viewMatrix * vec4(wpos, 1.0);\r\n//   mat4 matrix = projectionMatrix * modelViewMatrix;\r\n//   vec4 hpos;\r\n//   hpos.x = dot(position, vec3(matrix[0].x, matrix[1].x, matrix[2].x)) + matrix[3].x;\r\n//   hpos.y = dot(position, vec3(matrix[0].y, matrix[1].y, matrix[2].y)) + matrix[3].y;\r\n//   hpos.z = dot(position, vec3(matrix[0].z, matrix[1].z, matrix[2].z)) + matrix[3].z;\r\n//   hpos.w = dot(position, vec3(matrix[0].w, matrix[1].w, matrix[2].w)) + matrix[3].w;\r\n//   hpos = matrix * vec4(position, 1.0);",billboardVertPars:"uniform mat4 ViewInverse;",billboardYVert:"  mat3 invMatrix;\r\n  invMatrix[2] = normalize(vec3(ViewInverse[2].x, 0.0, ViewInverse[2].z));\r\n  invMatrix[0] = normalize(cross(vec3(0.0, 1.0, 0.0), invMatrix[2]));\r\n  invMatrix[1] = cross(invMatrix[2], invMatrix[0]);",bokehFrag:"#include <common>\r\n\r\nvarying vec2 vUv;\r\n\r\nuniform sampler2D tColor;\r\nuniform sampler2D tDepth;\r\nuniform float textureWidth;\r\nuniform float textureHeight;\r\n\r\nuniform float focalDepth;\r\nuniform float focalLength;\r\nuniform float fstop;\r\nuniform bool showFocus;\r\n\r\n// make sure that these two values are the same for your camera, otherwise distances will be wrong\r\nuniform float znear;\r\nuniform float zfar;\r\n\r\n// user variables\r\nconst int samples = SAMPLES;\r\nconst int rings = RINGS;\r\n\r\nconst int maxringsamples = rings * samples;\r\n\r\nuniform bool manualdof;\r\nfloat ndofstart = 1.0;\r\nfloat ndofdist = 2.0;\r\nfloat fdofstart = 1.0;\r\nfloat fdofdist = 3.0;\r\n\r\nfloat CoC = 0.03;\r\n\r\nuniform bool vignetting;\r\nfloat vignout = 1.3;\r\nfloat vignin = 0.0;\r\nfloat vignfade = 22.0;\r\n\r\nuniform bool shaderFocus;\r\n// disable if you use external focalDepth value\r\n\r\nuniform vec2 focusCoords;\r\n// autofocus point on screen (0.0, 0.0 - left lower corner, 1.0, 1.0 - upper right)\r\n// if center of screen use vec2(0.5, 0.5)\r\n\r\nuniform float maxblur;\r\n// clamp value o fmax blur (0.0 = no blur, 1.0 default)\r\n\r\nuniform float threshold;\r\nuniform float gain;\r\n\r\nuniform float bias;\r\nuniform float fringe;\r\n\r\nuniform bool noise;\r\n\r\nuniform float dithering;\r\n\r\nuniform bool depthblur;\r\nfloat dbsize = 1.25;\r\n\r\n// next part is experimental\r\n// not looking good with small sample and ring count\r\n// looks okay starting from samples = 4, rings = 4\r\n\r\nuniform bool pentagon;\r\nfloat feather = 0.4;\r\n\r\nfloat penta(vec2 coords) {\r\n// pentagonal shape\r\n  float scale = float(rings) - 1.3;\r\n  vec4 HS0 = vec4( 1.0,         0.0,         0.0, 1.0);\r\n  vec4 HS1 = vec4( 0.309016994, 0.951056516, 0.0, 1.0);\r\n  vec4 HS2 = vec4(-0.809016994, 0.587785252, 0.0, 1.0);\r\n  vec4 HS3 = vec4(-0.809016994,-0.587785252, 0.0, 1.0);\r\n  vec4 HS4 = vec4( 0.309016994,-0.951056516, 0.0, 1.0);\r\n  vec4 HS5 = vec4( 0.0,         0.0,         1.0, 1.0);\r\n  vec4 one = vec4(1.0);\r\n  vec4 P = vec4((coords), vec2(scale, scale));\r\n  vec4 dist = vec4(0.0);\r\n  float inorout = -4.0;\r\n\r\n  dist.x = dot(P, HS0);\r\n  dist.y = dot(P, HS1);\r\n  dist.z = dot(P, HS2);\r\n  dist.w = dot(P, HS3);\r\n\r\n  dist = smoothstep(-feather, feather, dist);\r\n\r\n  inorout += dot(dit, one);\r\n\r\n  dist.x = dot(P, HS4);\r\n  dist.y = HS5.w - abs(P.z);\r\n  dist = smoothstep(-feather, feather, dist);\r\n  inorout += dist.x;\r\n  return clamp(inorout, 0.0, 1.0);\r\n}\r\n\r\nfloat bdepth(vec2 coords) {\r\n// Depth buffer blur\r\n  float d = 0.0;\r\n  float kernel[9];\r\n  vec2 offset[9];\r\n  vec2 wh = vec2(1.0 / textureWidth, 1.0 / textureHeight) * dbsize;\r\n\r\n  offset[0] = vec2(-wh.x, -wh.y);\r\n  offset[1] = vec2(0.0,   -wh.y);\r\n  offset[2] = vec2(wh.x,  -wh.y);\r\n\r\n  offset[3] = vec2(-wh.x, 0.0);\r\n  offset[4] = vec2(0.0,   0.0);\r\n  offset[5] = vec2(wh.x,  0.0);\r\n\r\n  offset[6] = vec2(-wh.x, wh.y);\r\n  offset[7] = vec2(0.0,   wh.y);\r\n  offset[8] = vec2(wh.x,  wh.y);\r\n\r\n  kernel[0] = 1.0 / 16.0; kernel[1] = 2.0 / 16.0; kernel[2] = 1.0 / 16.0;\r\n  kernel[3] = 2.0 / 16.0; kernel[4] = 4.0 / 16.0; kernel[5] = 2.0 / 16.0;\r\n  kernel[6] = 1.0 / 16.0; kernel[7] = 2.0 / 16.0; kernel[8] = 1.0 / 16.0;\r\n\r\n  for (int i=0; i<9; i++) {\r\n    float tmp = texture2D(tDepth, coords + offset[i]).r;\r\n    d += tmp * kernel[i];\r\n  }\r\n\r\n  return d;\r\n}\r\n\r\nvec3 color(vec2 coords, float blur) {\r\n// processing the sample\r\n  vec3 col = vec3(0.0);\r\n  vec2 texel = vec2(1.0 / textureWidth, 1.0 / textureHeight);\r\n\r\n  col.r = texture2D(tColor, coords + vec2(0.0, 1.0) * texel * fringe * blur).r;\r\n  col.g = texture2D(tColor, coords + vec2(-0.866, -0.5) * texel * fringe * blur).g;\r\n  col.b = texture2D(tColor, coords + vec2(0.866, -0.5) * texel * fringe * blur).b;\r\n\r\n  vec3 lumcoeff = vec3(0.299, 0.587, 0.114);\r\n  float lum = dot(col.rgb, lumcoeff);\r\n  float thresh = max((lum - threshold) * gain, 0.0);\r\n  return col + mix(vec3(0.0), col, thresh * blur);\r\n}\r\n\r\nvec3 debugFocus(vec3 col, float blur, float depth) {\r\n  float edge = 0.002 * depth;\r\n  float m = clamp(smoothstep(0.0, edge, blur), 0.0, 1.0);\r\n  float e = clamp(smoothstep(1.0 - edge, 1.0, blur), 0.0, 1.0);\r\n\r\n  col = mix(col, vec3(1.0, 0.5, 0.0), (1.0 - m) * 0.6);\r\n  col = mix(col, vec3(0.0, 0.5, 1.0), ((1.0 - e) - (1.0 - m)) * 0.2);\r\n\r\n  return col;\r\n}\r\n\r\nfloat linearize(float depth) {\r\n  return -zfar * znear / (depth * (zfar - znear) - zfar);\r\n}\r\n\r\nfloat vignette() {\r\n  float dist = distance(vUv.xy, vec2(0.5, 0.5));\r\n  dist = smoothstep(vignout + (fstop / vignfade), vignin + (fstop / vignfade), dist);\r\n  return clamp(dist, 0.0, 1.0);\r\n}\r\n\r\nfloat gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {\r\n  float rings2 = float(rings);\r\n  step = PI * 2.0 / float(ringsamples);\r\n  float pw = cos(j * step) * i;\r\n  float ph = sin(j * step) * i;\r\n  float p = 1.0;\r\n  if (pentagon) {\r\n    p = penta(vec2(pw, ph));\r\n  }\r\n  col += color(vUv.xy + vec2(pw*w, ph*h), blur) * mix(1.0, i/rings2, bias) * p;\r\n  return 1.0 * mix(1.0, i/rings2, bias) * p;\r\n}\r\n\r\nvoid main() {\r\n// scene depth calculation\r\n  float depth = linearize(texture2D(tDepth, vUv.xy).x);\r\n\r\n// Blur depth?\r\n  if (depthblur) {\r\n    depth = linearize(bdepth(vUv.xy));\r\n  }\r\n\r\n// focal plane calculation\r\n  float fDepth = focalDepth;\r\n\r\n  if (shaderFocus) {\r\n    fDpeth = linearize(texture2D(tDepth, focusCoords).x);\r\n  }\r\n\r\n// dof blur factor calculation\r\n\r\n  float blur = 0.0;\r\n\r\n  if (manualdof) {\r\n    float a = depth - fDepth;\r\n    float b = (a - fdofstart) / fdofdist;\r\n    float c = (-a - ndofstart) / ndofdist;\r\n    blur = (a > 0.0) ? b : c;\r\n  } else {\r\n    float f = focalLength;\r\n    float d = fDepth * 1000.0;\r\n    float o = depth * 1000.0;\r\n\r\n    float a = (o*f) / (o-f);\r\n    float b = (d*f) / (d-f);\r\n    float c = (d-f) / (d * fstop * CoC);\r\n\r\n    blur = abs(a-b) * c;\r\n  }\r\n\r\n  blur = clamp(blur, 0.0, 1.0);\r\n\r\n// calculation of pattern for dithering\r\n\r\n  vec2 noise = vec2(rand(vUv.xy), rand(vUv.xy + vec2(0.4, 0.6))) * dithering * blur;\r\n\r\n// getting blur x and y step factor\r\n\r\n  float w = (1.0 / textureWidth) * blur * maxblur + noise.x;\r\n  float h = (1.0 / textureHeight) * blur * maxblur + noise.y;\r\n\r\n// calculation of final color\r\n\r\n  vec3 col = vec3(0.0);\r\n\r\n  if (blur < 0.05) {\r\n// some optimization thingy\r\n    col = texture2D(tColor, vUv.xy).rgb;\r\n  } else {\r\n    col = texture2D(tColor, vuv.xy).rgb;\r\n    float s = 1.0;\r\n    int ringsamples;\r\n\r\n    for (int i=1; i<=rings; i++) {\r\n// unboxstart\r\n      ringsamples = i * samples;\r\n      for (int j=0; j<maxringsamples; j++) {\r\n        if (j >= ringsamples) break;\r\n        s += gather(float(i), float(j), ringsamples, col, w, h, blur);\r\n      }\r\n// unboxend\r\n    }\r\n\r\n    col /= s;\r\n  }\r\n\r\n  if (showFocus) {\r\n    col = debugFocus(col, blur, depth);\r\n  }\r\n\r\n  if (vignetting) {\r\n    col *= vignette();\r\n  }\r\n\r\n  gl_FragColor.rgb = col;\r\n  gl_FragColor.a = 1.0;\r\n}",bokehUniforms:{textureWidth:{value:1},textureHeight:{value:1},focalDepth:{value:1},focalLength:{value:24},fstop:{value:.9},tColor:{value:null},tDepth:{value:null},maxblur:{value:1},showFocus:{value:0},manualdof:{value:0},vignetting:{value:0},depthblur:{value:0},threshold:{value:.5},gain:{value:2},bias:{value:.5},fringe:{value:.7},znear:{value:.1},zfar:{value:100},noise:{value:1},dithering:{value:1e-4},pentagon:{value:0},shaderFocus:{value:1},focusCoords:{value:new r.Vector2}},bokehVert:"varying vec2 vUv;\r\nvoid main() {\r\n  vUv = uv;\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}",bsdfs:'vec3 DiffuseLambert(vec3 diffuseColor) {\r\n  return RECIPROCAL_PI * diffuseColor;\r\n}\r\n\r\n// KANSAI CEDEC2015: Final Fantasy 零式HD リマスター\r\nvec3 DiffuseOrenNayar(vec3 diffuseColor, float NoV, float NoL, float LoV, float roughness) {\r\n  float s = LoV - NoL * NoV;\r\n  float t = rcp(max(NoL, NoV) + 1e-5);\r\n  t = (s < 0.0) ? 1.0 : t;\r\n  float st = s*t;\r\n  \r\n  // ラフネスが 0.0 ～ 1.0 になるように限定すると高速近似可能\r\n  // 参照：A tiny improvement of Oren-Nayar reflectance model\r\n  // http://mimosa-pudica.net/improved-oren-nayar.html\r\n  float a = rcp((PI * 0.5 - 2.0/3.0) * roughness + PI);\r\n  float b = roughness * a;\r\n  return diffuseColor * NoL * (a + b*st);\r\n}\r\n\r\n// compute fresnel specular factor for given base specular and product\r\n// product could be NoV or VoH depending on used technique\r\n// vec3 F_Schlick(vec3 f0, float product) {\r\n//   return mix(f0, vec3(1.0), pow(1.0 - product, 5.0));\r\n// }\r\n\r\nvec3 F_Schlick(vec3 specularColor, vec3 H, vec3 V) {\r\n  return (specularColor + (1.0 - specularColor) * pow(1.0 - saturate(dot(V, H)), 5.0));\r\n}\r\n\r\nvec3 F_SchlickApprox(vec3 specularColor, float VoH) {\r\n\r\n  // Original approximation by Christophe Schlick \'94\r\n  // float fresnel = pow(1.0 - product, 5.0);\r\n  \r\n  // Optimized variant (presented by Epic at SIGGRAPH \'13)\r\n  float fresnel = exp2((-5.55473 * VoH - 6.98316) * VoH);\r\n  \r\n  // Anything less than 2% is physically impossible and is instead considered to be shadowing\r\n  // return specularColor + (saturate(50.0 * specularColor.g) - specularColor) * fresnel;\r\n  return specularColor + (vec3(1.0) - specularColor) * fresnel;\r\n}\r\n\r\nvec3 F_CookTorrance(vec3 specularColor, vec3 H, vec3 V) {\r\n  vec3 n = (1.0 + sqrt(specularColor)) / (1.0 - sqrt(specularColor));\r\n  float c = saturate(dot(V, H));\r\n  vec3 g = sqrt(n * n + c * c - 1.0);\r\n  \r\n  vec3 part1 = (g - c) / (g + c);\r\n  vec3 part2 = ((g + c) * c - 1.0) / ((g - c) * c + 1.0);\r\n  \r\n  return max(vec3(0.0), 0.5 * part1 * part1 * (1.0 + part2 + part2));\r\n}\r\n\r\n\r\n/// SPECULAR D: MICROFACET DISTRIBUTION FUNCTION\r\n\r\n// Microfacet Models for Refraction through Rough Surface - equation (33)\r\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\r\n// "a" is "roughness squared" in Disney \'s reparameterization\r\nfloat D_GGX(float a, float NoH) {\r\n  // Isotropic ggx\r\n  float a2 = a*a;\r\n  float NoH2 = NoH*NoH;\r\n  float d = NoH2 * (a2 - 1.0) + 1.0;\r\n  return a2 / (PI * d * d);\r\n}\r\n\r\nfloat D_GGX_AreaLight(float a, float aP, float NoH) {\r\n  float a2 = a*a;\r\n  float aP2 = aP*aP;\r\n  float NoH2 = NoH*NoH;\r\n  float d = NoH2 * (a2 - 1.0) + 1.0;\r\n  return (a2*aP2) / (pow(NoH2 * (a2-1.0) + 1.0, 2.0) * PI);\r\n}\r\n\r\n// following functions are copies fo UE4\r\n// for computing cook-torrance specular lighitng terms\r\n// https://gist.github.com/galek/53557375251e1a942dfa\r\nfloat D_Blinn(in float a, in float NoH) {\r\n  float a2 = a * a;\r\n  float n = 2.0 / (a2*a2) - 2.0;\r\n  return (n + 2.0) / (2.0 * PI) * pow(NoH, n);\r\n}\r\n\r\nfloat D_BlinnPhong(float a, float NoH) {\r\n  float a2 = a * a;\r\n  return (1.0 / (PI * a2)) * pow(NoH, 2.0 / a2 - 2.0);\r\n}\r\n\r\n// https://gist.github.com/galek/53557375251e1a942dfa\r\nfloat D_Beckmann(float a, float NoH) {\r\n  float a2 = a * a;\r\n  float NoH2 = NoH * NoH;\r\n  \r\n  return (1.0 / (PI * a2 * NoH2 * NoH2 + 1e-5)) * exp((NoH2 - 1.0) / (a2 * NoH2));\r\n}\r\n\r\n\r\n/// SPECULAR G: GEOMETRIC ATTENUATION\r\n\r\n\r\nfloat G_Implicit(float a, float NoV, float NoL) {\r\n  return NoL * NoL;\r\n}\r\n\r\nfloat G_BlinngPhong_Implicit(float a, float NoV, float NoL) {\r\n  // geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\r\n  return 0.25;\r\n}\r\n\r\nfloat G_Newmann(float a, float NoV, float NoL) {\r\n  return (NoL * NoV) / max(NoL, NoV);\r\n}\r\n\r\nfloat G_CookTorrance(float a, float NoV, float NoL, float NoH, float VoH) {\r\n  return min(1.0, min((2.0 * NoH * NoV) / VoH, (2.0 * NoH * NoL) / VoH));\r\n}\r\n\r\nfloat G_Kelemen(float a, float NoV, float NoL, float LoV) {\r\n  return (2.0 * NoL * NoV) / (1.0 + LoV);\r\n}\r\n\r\nfloat G_Beckmann(float a, float product) {\r\n  float c = product / (a * sqrt(1.0 - product * product));\r\n  if (c >= 1.6) {\r\n    return 1.0;\r\n  }\r\n  else {\r\n    float c2 = c * c;\r\n    return (3.535 * c + 2.181 * c2) / (1.0 + 2.276 * c + 2.577 * c2);\r\n  }\r\n}\r\n\r\nfloat G_Smith_Beckmann(float a, float NoV, float NoL) {\r\n  return G_Beckmann(a, NoV) * G_Beckmann(a, NoL);\r\n}\r\n\r\n// Smith approx\r\n// Microfacet Models for Refraction through Rough Surface - equation (34)\r\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\r\n// "a" is "roughness squared" in Disney \'s reparameterization\r\nfloat G_Smith_GGX(float a, float NoV, float NoL) {\r\n  // geometry term = dot(G(l), G(v)) / 4 * dot(n,l) * dot(n,v)\r\n  float a2 = a * a;\r\n  float gl = NoL + sqrt(a2 + (1.0 - a2) * pow2(NoL));\r\n  float gv = NoV + sqrt(a2 + (1.0 - a2) * pow2(NoV));\r\n  return 1.0 / (gl*gv);\r\n}\r\n\r\n// from page 12, listing 2 of http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr_v2.pdf\r\nfloat G_SmithCorrelated_GGX(float a, float NoV, float NoL) {\r\n  float a2 = a * a;\r\n  \r\n  // NoL and NoV are explicitly swapped. This is not a mistake\r\n  float gv = NoL * sqrt(a2 + (1.0 - a2) * pow2(NoV));\r\n  float gl = NoV * sqrt(a2 + (1.0 - a2) * pow2(NoL));\r\n  \r\n  return 0.5 / max(gv+gl, EPSILON);\r\n}\r\n\r\n// Schlick\'s Geometric approximation. Note this is edited by Epic to match\r\n// a modification disney made (And ignoring there modifications,\r\n// if you want to do your own research you need to know up front the Schlick originally\r\n// approximated the wrong fomula, so be careful to make sure you choose the corrected\r\n// Schlick if you find it online)\r\nfloat G_Smith_Schlick_GGX(float a, float NoV, float NoL) {\r\n  float k = a * a * 0.5;\r\n  float gl = NoL / (NoL * (1.0 - k) + k);\r\n  float gv = NoV / (NoV * (1.0 - k) + k);\r\n  return gl*gv;\r\n}\r\n\r\n// Tuned to match behavior of Vis_Smith\r\n// [Schlick 1994, "An Inexpensive BRDF Model for Physically-Based Rendering"]\r\nfloat G_Schlick(in float a, in float NoV, in float NoL) {\r\n  float k = a * 0.5;\r\n  float V = NoV * (1.0 - k) + k;\r\n  float L = NoL * (1.0 - k) + k;\r\n  return 0.25 / (V * L);\r\n}\r\n\r\nfloat G_SchlickApprox(in float a, in float NdotV, in float NdotL) {\r\n  float V = NdotL * (NdotV * (1.0 - a) + a);\r\n  float L = NdotV * (NdotL * (1.0 - a) + a);\r\n  return 0.5 / (V + L + 1e-5);\r\n}\r\n\r\n// [ Lazarov 2013 "Getting More Physical in Call of Duty: Black Ops II" ]\r\n// Adaptation to fit our G term\r\n// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\r\n// BRDF_Specular_GGX_Environment\r\nvec3 EnvBRDFApprox(vec3 specularColor, float roughness, float NoV) {\r\n  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\r\n  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04 );\r\n  vec4 r = roughness * c0 + c1;\r\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\r\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\r\n  return specularColor * AB.x + AB.y;\r\n}\r\n\r\n// three.js (bsdfs.glsl)\r\n// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html\r\nfloat GGXRoughnessToBlinnExponent(const in float ggxRoughness) {\r\n  return 2.0 / pow2(ggxRoughness + 0.0001) - 2.0;\r\n}\r\n\r\nfloat BlinnExponentToGGXRoughness(const in float blinnExponent) {\r\n  return sqrt(2.0 / (blinnExponent + 2.0));\r\n}\r\n\r\n/// DISNEY\r\n\r\nfloat F_Schlick_Disney(float u) {\r\n  float m = saturate(1.0 - u);\r\n  float m2 = m * m;\r\n  return m2 * m2 * m;\r\n}\r\n\r\nfloat GTR2_aniso(float NoH, float HoX, float HoY, float ax, float ay) {\r\n  return 1.0 / (PI * ax*ay * pow2(pow2(HoX/ax) + pow2(HoY/ay) + NoH*NoH));\r\n}\r\n    \r\nfloat smithG_GGX(float NoV, float alphaG) {\r\n  float a = alphaG * alphaG;\r\n  float b = NoV * NoV;\r\n  return 1.0 / (NoV + sqrt(a + b - a*b));\r\n}\r\n    \r\nfloat GTR1(float NoH, float a) {\r\n  if (a >= 1.0) {\r\n    return 1.0 / PI;\r\n  }\r\n      \r\n  float a2 = a*a;\r\n  float t = 1.0 + (a2 - 1.0) * NoH * NoH;\r\n  return (a2 - 1.0) / (PI * log(a2) * t);\r\n}',bumpMapFrag:"  geometry.normal = perturbNormalArb(-vViewPosition, normalize(vNormal), dHdxy_fwd());",bumpMapFragPars:"uniform sampler2D tNormal;\r\nuniform float bumpiness;\r\n\r\nvec2 dHdxy_fwd() {\r\n  vec2 dSTdx = dFdx(vUv);\r\n  vec2 dSTdy = dFdy(vUv);\r\n  float Hll = bumpiness * texture2D(tNormal, vUv).x;\r\n  float dBx = bumpiness * texture2D(tNormal, vUv + dSTdx).x - Hll;\r\n  float dBy = bumpiness * texture2D(tNormal, vUv + dSTdy).x - Hll;\r\n  return vec2(dBx, dBy);\r\n}\r\n\r\nvec3 perturbNormalArb(vec3 surf_pos, vec3 surf_norm, vec2 dHdxy) {\r\n  vec3 vSigmaX = dFdx(surf_pos);\r\n  vec3 vSigmaY = dFdy(surf_pos);\r\n  vec3 vN = surf_norm; // normalized\r\n  vec3 R1 = cross(vSigmaY, vN);\r\n  vec3 R2 = cross(vN, vSigmaX);\r\n  float fDet = dot(vSigmaX, R1);\r\n  vec3 vGrad = sign(fDet) * (dHdxy.x * R1 + dHdxy.y * R2);\r\n  return normalize(abs(fDet) * surf_norm - vGrad);\r\n}",bumpMapUniforms:{tNormal:{value:null},bumpiness:{value:1}},castShadowFrag:"  float d = vShadowMapUV.z / vShadowMapUV.w;\r\n  gl_FragColor = packDepthToRGBA(d);",castShadowFragPars:"varying vec4 vShadowMapUV;",castShadowUniforms:{lightViewProjectionMatrix:{value:new r.Matrix4}},castShadowVert:"  vec4 hpos = lightViewProjectionMatrix * modelMatrix * vec4(position, 1.0);\r\n  vShadowMapUV = hpos;",castShadowVertPars:"uniform mat4 lightViewProjectionMatrix;\r\nvarying vec4 vShadowMapUV;",clippingPlaneFrag:"  if (dot(vViewPosition, clippingPlane.xyz) > clippingPlane.w) discard;",clippingPlaneFragPars:"uniform vec4 clippingPlane;",clippingPlaneUniforms:{clippingPlane:{value:new r.Vector4}},cloudsFrag:"  vec2 cloudsUV = vec2(vUv.x + cloudsTranslation, vUv.y);\r\n  vec2 cloudsPerturb = texture2D(tCloudsPerturb, cloudsUV).xy * cloudsScale;\r\n  cloudsPerturb.xy += cloudsUV + vec2(cloudsTranslation);\r\n  vec3 sunLight = max(reflectedLight.indirectDiffuse, vec3(0.2));\r\n  reflectedLight.indirectDiffuse += texture2D(tClouds, cloudsPerturb).rgb * cloudsBrightness * sunLight;\r\n// reflectedLight.indirectDiffuse += texture2D(tClouds, vUv).rgb * cloudsBrightness;",cloudsFragPars:"uniform sampler2D tClouds;\r\nuniform sampler2D tCloudsPerturb;\r\nuniform float cloudsTranslation;\r\nuniform float cloudsScale;\r\nuniform float cloudsBrightness;",cloudsUniforms:{tClouds:{value:null},tCloudsPerturb:{value:null},cloudsTranslation:{value:0},cloudsScale:{value:.3},cloudsBrightness:{value:.5}},colorBalanceFrag:"uniform vec3 cColorBalanceColor;\r\nuniform sampler2D tDiffuse;\r\nvarying vec2 vUv;\r\n// http://stackoverflow.com/questions/23213925/interpreting-color-function-and-adjusting-pixels-values\r\n// https://gist.github.com/liovch/3168961\r\n// https://github.com/liovch/GPUImage/blob/master/framework/Source/GPUImageColorBalanceFilter.m\r\n\r\nfloat rgb2l(vec3 c) {\r\n  float fmin = min(min(c.r, c.g), c.b);\r\n  float fmax = max(max(c.r, c.g), c.b);\r\n  return (fmax + fmin) * 0.5; // Luminance\r\n}\r\n\r\nvoid main() {\r\n  vec4 texel = texture2D(tDiffuse, vUv);\r\n\r\n  float lightness = rgb2l(texel.rgb);\r\n\r\n  const float a = 0.25;\r\n  const float b = 0.333;\r\n  const float scale = 0.7;\r\n\r\n  float c2 = clamp((lightness - b) / a + 0.5, 0.0, 1.0);\r\n  float c3 = clamp((lightness + b - 1.0) / -a + 0.5, 0.0, 1.0);\r\n  vec3 midtones = cColorBalanceColor * (c2 * c3 * scale);\r\n\r\n  vec3 newColor = texel.rgb + midtones;\r\n  newColor = clamp(newColor, 0.0, 1.0);\r\n  gl_FragColor = vec4(newColor, 1.0);\r\n}",colorBalanceUniforms:{cColorBalanceColor:{value:new r.Vector3(0,0,0)}},colorMap2Frag:"  vec4 color2RGBA = texture2D(tDiffuse2, uv);\r\n  material.diffuseColor.rgb = (1.0 - color2RGBA.a) * material.diffuseColor.rgb + color2RGBA.rgb * color2RGBA.a;",colorMap2FragPars:"uniform sampler2D tDiffuse2;",colorMap2Uniforms:{tDiffuse2:{value:null}},colorMapAlphaFrag:"  material.opacity *= colorRGBA.a;",colorMapFrag:"  vec4 colorRGBA = texture2D(tDiffuse, uv);\r\n  material.diffuseColor.rgb *= colorRGBA.rgb;",colorMapFragPars:"uniform sampler2D tDiffuse;",colorMapUniforms:{tDiffuse:{value:null}},common:"#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n// handy value clamping to 0 - 1 range\r\n#ifndef saturate\r\n#define saturate( a ) clamp( a, 0.0, 1.0 )\r\n#endif\r\n#define whiteCompliment(a) (1.0 - saturate(a))\r\n\r\nfloat pow2(const in float x) { return x*x; }\r\nfloat pow3(const in float x) { return x*x*x; }\r\nfloat pow4(const in float x) { float x2 = x*x; return x2*x2; }\r\nfloat pow5(const in float x) { float x2 = x*x; return x2*x2*x; }\r\nfloat average(const in vec3 color) { return dot(color, vec3(0.3333)); }\r\nfloat rcp(const in float x) { return 1.0/x; }\r\n\r\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\r\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\r\nhighp float rand(const in vec2 uv) {\r\n  const highp float a = 12.9898, b = 78.233, c = 43758.5453;\r\n  highp float dt = dot(uv.xy, vec2(a,b)), sn = mod(dt, PI);\r\n  return fract(sin(sn) * c);\r\n}\r\n\r\nstruct IncidentLight {\r\n  vec3 color;\r\n  vec3 direction;\r\n  bool visible;\r\n};\r\n\r\nstruct ReflectedLight {\r\n  vec3 directDiffuse;\r\n  vec3 directSpecular;\r\n  vec3 indirectDiffuse;\r\n  vec3 indirectSpecular;\r\n};\r\n\r\nstruct GeometricContext {\r\n  vec3 position;\r\n  vec3 normal;\r\n  vec3 viewDir;\r\n};\r\n\r\nstruct Material {\r\n  vec3 diffuseColor;\r\n  float opacity;\r\n  float specularRoughness;\r\n  vec3 specularColor;\r\n};\r\n\r\nvec3 transformDirection(in vec3 dir, in mat4 matrix) {\r\n  return normalize((matrix * vec4(dir, 0.0)).xyz);\r\n}\r\n\r\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\r\nvec3 inverseTransformDirection(in vec3 dir, in mat4 matrix) {\r\n  return normalize((vec4(dir, 0.0) * matrix).xyz);\r\n}\r\n\r\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {\r\n  float distance = dot(planeNormal, point - pointOnPlane);\r\n  return -distance * planeNormal + point;\r\n}\r\n\r\nfloat sideOfPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {\r\n  return sign(dot(point - pointOnPlane, planeNormal));\r\n}\r\n\r\nvec3 linePlaneIntersect(in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal) {\r\n  return lineDirection * (dot(planeNormal, pointOnPlane - pointOnLine) / dot(planeNormal, lineDirection)) + pointOnLine;\r\n}\r\n\r\nvec4 GammaToLinear(in vec4 value, in float gammaFactor) {\r\n  return vec4(pow(value.xyz, vec3(gammaFactor)), value.w);\r\n}\r\nvec4 LinearToGamma(in vec4 value, in float gammaFactor) {\r\n  return vec4(pow(value.xyz, vec3(1.0/gammaFactor)), value.w);\r\n}\r\n",copyFrag:"uniform sampler2D tDiffuse;\r\nuniform float opacity;\r\nvarying vec2 vUv;\r\nvoid main() {\r\n  gl_FragColor = texture2D(tDiffuse, vUv) * opacity;\r\n}",copyUniforms:{tDiffuse:{value:null},opacity:{value:1}},copyVert:"varying vec2 vUv;\r\nvoid main() {\r\n  vUv = uv;\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}",deferredGeometryFrag:"#include <packing>\r\nuniform sampler2D tDiffuse;\r\nuniform sampler2D tRoughness;\r\nuniform sampler2D tNormal;\r\nuniform float bumpiness;\r\nvarying vec3 vViewPosition;\r\nvarying vec3 vNormal;\r\nvarying vec2 vUv;\r\nlayout(location = 0) out vec4 gNormal;\r\nlayout(location = 1) out vec4 gDiffuseRoughness;\r\n\r\nvec2 dHdxy_fwd() {\r\n  vec2 dSTdx = dFdx(vUv);\r\n  vec2 dSTdy = dFdy(vUv);\r\n  float Hll = bumpiness * texture2D(tNormal, vUv).x;\r\n  float dBx = bumpiness * texture2D(tNormal, vUv + dSTdx).x - Hll;\r\n  float dBy = bumpiness * texture2D(tNormal, vUv + dSTdy).x - Hll;\r\n  return vec2(dBx, dBy);\r\n}\r\n\r\nvec3 perturbNormalArb(vec3 surf_pos, vec3 surf_norm, vec2 dHdxy) {\r\n  vec3 vSigmaX = dFdx(surf_pos);\r\n  vec3 vSigmaY = dFdy(surf_pos);\r\n  vec3 vN = surf_norm; // normalized\r\n  vec3 R1 = cross(vSigmaY, vN);\r\n  vec3 R2 = cross(vN, vSigmaX);\r\n  float fDet = dot(vSigmaX, R1);\r\n  vec3 vGrad = sign(fDet) * (dHdxy.x * R1 + dHdxy.y * R2);\r\n  return normalize(abs(fDet) * surf_norm - vGrad);\r\n}\r\n\r\nvoid main() {\r\n  vec4 diffuseRGBA = texture2D(tDiffuse, vUv);\r\n  vec4 roughnessRGBA = texture2D(tRoughness, vUv);\r\n  vec3 Nn = perturbNormalArb(-vViewPosition, normalize(vNormal), dHdxy_fwd());\r\n  gNormal = vec4(Nn * 0.5 + 0.5, 0.0);\r\n  gDiffuseRoughness = vec4(diffuseRGBA.xyz, roughnessRGBA.r);\r\n}",deferredGeometryUniforms:{tDiffuse:{value:null},tRoughness:{value:null},tNormal:{value:null},bumpiness:{value:1}},deferredGeometryVert:"uniform mat4 projectionMatrix;\r\nuniform mat4 modelViewMatrix;\r\nuniform mat3 normalMatrix;\r\nattribute vec3 position;\r\nattribute vec3 normal;\r\nattribute vec2 uv;\r\nvarying vec3 vViewPosition;\r\nvarying vec3 vNormal;\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n  gl_Position = projectionMatrix * mvPosition;\r\n  vViewPosition = -mvPosition.xyz;\r\n  vNormal = normalize(normalMatrix * normal);\r\n  vUv = uv;\r\n}",deferredLightFrag:'#include <packing>\r\n#define PI 3.14159265359\r\n#define RECIPROCAL_PI 0.31830988618\r\n#ifndef saturate\r\n#define saturate(x) clamp(x, 0.0, 1.0)\r\n#endif\r\nfloat pow2(const in float x) { return x*x; }\r\nvec3 transformDirection(in vec3 dir, in mat4 matrix) {\r\n  return normalize((matrix * vec4(dir, 0.0)).xyz);\r\n}\r\nvec3 inverseTransformDirection(in vec3 dir, in mat4 matrix) {\r\n  return normalize((vec4(dir, 0.0) * matrix).xyz);\r\n}\r\nvec4 GammaToLinear(in vec4 value, in float gammaFactor) {\r\n  return vec4(pow(value.xyz, vec3(gammaFactor)), value.w);\r\n}\r\nvec4 LinearToGamma(in vec4 value, in float gammaFactor) {\r\n  return vec4(pow(value.xyz, vec3(1.0/gammaFactor)), value.w);\r\n}\r\n// #define NUM_POINT_LIGHT 300\r\nstruct PointLight {\r\n  vec3 position;\r\n  vec3 color;\r\n};\r\n\r\nuniform PointLight pointLights[NUM_POINT_LIGHT];\r\nuniform int numPointLights;\r\nuniform float cutoffDistance;\r\nuniform float decayExponent;\r\nuniform float metalness;\r\nuniform float reflectionStrength;\r\nuniform vec3 viewPosition;\r\nuniform mat4 viewInverse;\r\nuniform mat4 viewProjectionInverse;\r\nuniform sampler2D gbuf0; // [rgb-] normal\r\nuniform sampler2D gbuf1; // [rgb-] albedo [---w] roughness\r\nuniform sampler2D tDepth;\r\nuniform samplerCube tEnvMap;\r\nvarying vec2 vUv;\r\n\r\n\r\n// [ Lazarov 2013 "Getting More Physical in Call of Duty: Black Ops II" ]\r\n// Adaptation to fit our G term\r\n// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\r\n// BRDF_Specular_GGX_Environment\r\nvec3 EnvBRDFApprox(vec3 specularColor, float roughness, float NoV) {\r\n  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\r\n  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04 );\r\n  vec4 r = roughness * c0 + c1;\r\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\r\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\r\n  return specularColor * AB.x + AB.y;\r\n}\r\n\r\n// three.js (bsdfs.glsl)\r\n// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html\r\nfloat GGXRoughnessToBlinnExponent(const in float ggxRoughness) {\r\n  return 2.0 / pow2(ggxRoughness + 0.0001) - 2.0;\r\n}\r\n\r\nfloat BlinnExponentToGGXRoughness(const in float blinnExponent) {\r\n  return sqrt(2.0 / (blinnExponent + 2.0));\r\n}\r\n\r\n// taken from here: http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html\r\nfloat getSpecularMipLevel(const in float blinnShininessExponent, const in int maxMipLevel) {\r\n  float maxMipLevelScalar = float(maxMipLevel);\r\n  float desiredMipLevel = maxMipLevelScalar - 0.79248 - 0.5 * log2(pow2(blinnShininessExponent)+1.0);\r\n  \r\n  // clamp to allowable LOD ranges\r\n  return clamp(desiredMipLevel, 0.0, maxMipLevelScalar);\r\n}\r\n\r\nvec3 getLightProbeIndirectIrradiance(const in vec3 N, const in float blinnShininessExponent, const in int maxMipLevel) {\r\n  return GammaToLinear(textureCubeLodEXT(tEnvMap, N, float(maxMipLevel)), 2.2).rgb * reflectionStrength;\r\n}\r\n\r\nvec3 getLightProbeIndirectRadiance(const in vec3 V, const in vec3 N, const in float blinnShininessExponent, const in int maxMipLevel) {\r\n  vec3 reflectVec = reflect(-V, N);\r\n  float specMipLevel = getSpecularMipLevel(blinnShininessExponent, maxMipLevel);\r\n  return GammaToLinear(textureCubeLodEXT(tEnvMap, reflectVec, specMipLevel), 2.2).rgb * reflectionStrength;\r\n}\r\n\r\n\r\nvec3 DiffuseLambert(vec3 diffuseColor) {\r\n  return RECIPROCAL_PI * diffuseColor;\r\n}\r\n\r\nfloat D_GGX(float a, float NoH) {\r\n  // Isotropic ggx\r\n  float a2 = a*a;\r\n  float NoH2 = NoH*NoH;\r\n  float d = NoH2 * (a2 - 1.0) + 1.0;\r\n  return a2 / (PI * d * d);\r\n}\r\n\r\nfloat G_Smith_Schlick_GGX(float a, float NoV, float NoL) {\r\n  float k = a * a * 0.5;\r\n  float gl = NoL / (NoL * (1.0 - k) + k);\r\n  float gv = NoV / (NoV * (1.0 - k) + k);\r\n  return gl*gv;\r\n}\r\n\r\nvec3 F_Schlick(vec3 specularColor, float VoH) {\r\n\r\n  // Original approximation by Christophe Schlick \'94\r\n  // "float fresnel = pow(1.0 - product, 5.0);",\r\n  \r\n  // Optimized variant (presented by Epic at SIGGRAPH \'13)\r\n  float fresnel = exp2((-5.55473 * VoH - 6.98316) * VoH);\r\n  \r\n  return specularColor + (vec3(1.0) - specularColor) * fresnel;\r\n}\r\n\r\nfloat Specular_D(float a, float NoH) {\r\n  return D_GGX(a, NoH);\r\n}\r\n\r\nfloat Specular_G(float a, float NoV, float NoL, float NoH, float VoH, float LoV) {\r\n  return G_Smith_Schlick_GGX(a, NoV, NoL);\r\n}\r\n\r\nvec3 Specular_F(vec3 specularColor, vec3 H, vec3 V) {\r\n  return F_Schlick(specularColor, saturate(dot(H,V)));\r\n}\r\n\r\nvec3 Specular(vec3 specularColor, vec3 H, vec3 V, vec3 L, float a, float NoL, float NoV, float NoH, float VoH, float LoV) {\r\n  float D = Specular_D(a, NoH);\r\n  float G = Specular_G(a, NoV, NoL, NoH, VoH, LoV);\r\n  vec3 F = Specular_F(specularColor, V, H) / (4.0 * NoL * NoV + 1e-5);\r\n  return F * (G * D);\r\n}\r\n\r\nvec3 ComputeLight(vec3 albedoColor, vec3 specularColor, vec3 N, float roughness, vec3 L, vec3 Lc, vec3 V) {\r\n  // Compute some useful values\r\n  float NoL = saturate(dot(N, L));\r\n  float NoV = saturate(dot(N, V));\r\n  vec3 H = normalize(L+V);\r\n  float NoH = saturate(dot(N, H));\r\n  float VoH = saturate(dot(V, H));\r\n  float LoV = saturate(dot(L, V));\r\n  \r\n  float a = pow2(roughness);\r\n  \r\n  vec3 cdiff = DiffuseLambert(albedoColor);\r\n  vec3 cspec = Specular(specularColor, H, V, L, a, NoL, NoV, NoH, VoH, LoV);\r\n  \r\n  return Lc * NoL * (cdiff + cspec);\r\n}\r\n\r\nvoid main() {\r\n  vec4 normalDepth = texture2D(gbuf0, vUv);\r\n  if (normalDepth.x + normalDepth.y + normalDepth.z == 0.0) discard;\r\n  \r\n  vec4 diffuseRoughness = texture2D(gbuf1, vUv);\r\n  vec4 diffuse = GammaToLinear(diffuseRoughness, 2.2);\r\n  vec4 depthRGBA = texture2D(tDepth, vUv);\r\n  float depth = depthRGBA.x * 2.0 - 1.0;\r\n  vec4 HPos = viewProjectionInverse * vec4(vUv*2.0-1.0, depth, 1.0);\r\n  vec3 worldPosition = HPos.xyz / HPos.w;\r\n  vec3 Nn = normalDepth.xyz * 2.0 - 1.0;\r\n  Nn = transformDirection(Nn, viewInverse);\r\n  vec3 viewDir = normalize(viewPosition - worldPosition);\r\n  \r\n  float roughnessFactor = max(0.04, diffuseRoughness.w);\r\n  vec3 cdiff = mix(diffuse.xyz, vec3(0.0), metalness);\r\n  vec3 cspec = mix(vec3(0.04), diffuse.xyz, metalness);\r\n\r\n  vec3 finalColor = vec3(0.0);\r\n  for (int i=0; i<NUM_POINT_LIGHT; ++i) {\r\n    if (i >= numPointLights) break;\r\n    \r\n    vec3 L = pointLights[i].position - worldPosition;\r\n    float Ld = length(L);\r\n    if (cutoffDistance == 0.0 || Ld < cutoffDistance) {\r\n      \r\n      float Lc = pow(saturate(-Ld / cutoffDistance + 1.0), decayExponent);\r\n      vec3 irradiance = pointLights[i].color * Lc;\r\n      irradiance *= PI; // punctual light\r\n      \r\n      vec3 Ln = normalize(L);\r\n      finalColor += ComputeLight(cdiff, cspec, Nn, roughnessFactor, Ln, irradiance, viewDir);\r\n    }\r\n  }\r\n  \r\n  vec3 indirect_irradiance = getLightProbeIndirectIrradiance(Nn, GGXRoughnessToBlinnExponent(roughnessFactor), 10) * PI;\r\n  vec3 diffIBL = indirect_irradiance * DiffuseLambert(cdiff);\r\n  finalColor += diffIBL;\r\n  \r\n  float NoV = saturate(dot(Nn, viewDir));\r\n  vec3 radiance = getLightProbeIndirectRadiance(viewDir, Nn, GGXRoughnessToBlinnExponent(roughnessFactor), 10);\r\n  finalColor += radiance * EnvBRDFApprox(cspec, roughnessFactor, NoV);\r\n  \r\n  gl_FragColor = LinearToGamma(vec4(finalColor, 1.0), 2.2);\r\n}',deferredLightUniforms:{gbuf0:{value:null},gbuf1:{value:null},tDepth:{value:null},tEnvMap:{value:null},metalness:{value:1},reflectionStrength:{value:1},pointLights:{value:[]},numPointLights:{value:0},viewInverse:{value:new r.Matrix4},viewProjectionInverse:{value:new r.Matrix4},viewPosition:{value:new r.Vector3},cutoffDistance:{value:10},decayExponent:{value:3}},deferredLightVert:"uniform mat4 projectionMatrix;\r\nuniform mat4 modelViewMatrix;\r\nattribute vec3 position;\r\nattribute vec2 uv;\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n  vUv = uv;\r\n}",depthFrag:"  gl_FragData[0] = packDepthToRGBA(gl_FragCoord.z);",depthFragPars:"#include <packing>",depthShadowFrag:"  gl_FragColor.xyz = vec3(unpackRGBAToDepth(texture2D(tShadow, vUv)));\r\n// gl_FragColor.xyz = vec3(DecodeFloatRGBA(texture2D(tShadow, vUv)));\r\n// gl_FragColor.xyz = texture2D(tShadow, vUv).aaa;\r\n  gl_FragColor.a = 1.0;",depthShadowFragPars:"uniform sampler2D tShadow;",depthShadowReceiveFrag:"uniform sampler2D tDiffuse;\r\nuniform sampler2D tShadow;\r\nvarying vec4 depth;\r\nvarying vec4 shadowMapUV;\r\nvarying vec2 vUv;\r\n\r\n// http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\r\nfloat DecodeFloatRGBA(vec4 rgba) {\r\n  return dot(rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0));\r\n}\r\n\r\nvoid main() {\r\n  float d = DecodeFloatRGBA(texture2DProj(tShadow, shadowMapUV));\r\n  vec4 diffuse = texture2D(tDiffuse, vUv);\r\n  vec4 color = (d * depth.w < depth.z-0.03) ? vec4(0) : vec4(1);\r\n  gl_FragColor = diffuse * color;\r\n  // gl_FragColor.rgb = vec3(shadowMapUV.x, shadowMapUV.y, 1.0);\r\n  // gl_FragColor.rgb = shadow.xxx;\r\n  // gl_FragColor.rgb = texture2D(tShadow, vUv).xxx;\r\n}",depthShadowReceiveUniforms:{mLightViewProjection:{value:new r.Matrix4},mShadowMatrix:{value:new r.Matrix4},tDiffuse:{value:null},tShadow:{value:null}},depthShadowReceiveVert:"uniform mat4 mLightViewProjection;\r\nuniform mat4 mShadowMatrix;\r\nvarying vec4 depth;\r\nvarying vec4 shadowMapUV;\r\nvarying vec2 vUv;\r\nvoid main() {\r\n  vUv = uv;\r\n  depth = mLightViewProjection * modelMatrix * vec4(position, 1.0);\r\n  shadowMapUV = mShadowMatrix * modelMatrix * vec4(position, 1.0);\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}",depthShadowUniforms:{tShadow:{value:null}},depthShadowVert:"uniform mat4 mLightViewProjection;\r\nvarying vec4 vShadowMapUV;\r\nvoid main() {\r\n  vec4 pos = mLightViewProjection * modelMatrix * vec4(position, 1.0);\r\n  gl_Position = pos;\r\n  vShadowMapUV = pos;\r\n}",discardFrag:"  if (material.opacity <= 0.5) discard;",displacementMapUniforms:{tDisplacement:{value:null},displacementScale:{value:1},displacementBias:{value:0}},displacementMapVert:"  transformed += normal * (texture2D(tDisplacement, uv).x * displacementScale + displacementBias);",displacementMapVertPars:"uniform sampler2D tDisplacement;\r\nuniform float displacementScale;\r\nuniform float displacementBias;",distortionFrag:"  vec4 distortionNormal = texture2D(tDistortion, vUv2);\r\n  vec3 distortion = (distortionNormal.rgb - vec3(0.5)) * distortionStrength;\r\n  uv += distortion.xy;\r\n// float distortionInfluence = 1.0;\r\n// material.diffuseColor.rgb *= texture2D(tDiffuse, vUv + distortion.xy * distortionInfluence).rgb;\r\n// material.diffuseColor.rgb *= texture2D(tDiffuse, vUv2 + distortion.xy).rgb;\r\n// material.diffuseColor.rgb *= texture2D(tDiffuse, uv + distortion.xy).rgb;",distortionFragPars:"varying vec2 vUv2;\r\nuniform sampler2D tDistortion;\r\nuniform float distortionStrength;",distortionUniforms:{tDistortion:{value:null},distortionStrength:{value:1}},distortionVert:"  vUv2 = uv;",distortionVertPars:"varying vec2 vUv2;",ditherFrag:"  // float threshold = bayer(1, vScreenPos.xy * 10.0);\r\n  // material.opacity = step(threshold, material.opacity);\r\n  mat4 StippleThresholdMatrix = mat4(\r\n    1.0 / 17.0, 9.0 / 17.0, 3.0 / 17.0, 11.0 / 17.0,\r\n    13.0 / 17.0, 5.0 / 17.0, 15.0 / 17.0, 7.0 / 17.0,\r\n    4.0 / 17.0, 12.0 / 17.0, 2.0 / 17.0, 10.0 / 17.0,\r\n    16.0 / 17.0, 8.0 / 17.0, 14.0 / 17.0, 6.0 / 17.0);\r\n  \r\n  vec4 thresholdVec = StippleThresholdMatrix[3];\r\n  float scrX = abs(mod(gl_FragCoord.x, 4.0));\r\n  if (scrX <= 1.0) {\r\n    thresholdVec = StippleThresholdMatrix[0];\r\n  }\r\n  else if (scrX <= 2.0) {\r\n    thresholdVec = StippleThresholdMatrix[1];\r\n  }\r\n  else if (scrX <= 3.0) {\r\n    thresholdVec = StippleThresholdMatrix[2];\r\n  }\r\n  \r\n  float threshold = thresholdVec.w;\r\n  float scrY = abs(mod(gl_FragCoord.y, 4.0));\r\n  if (scrY <= 1.0) {\r\n    threshold = thresholdVec.x;\r\n  }\r\n  else if (scrY <= 2.0) {\r\n    threshold = thresholdVec.y;\r\n  }\r\n  else if (scrX <= 3.0) {\r\n    threshold = thresholdVec.z;\r\n  }\r\n  if (material.opacity < threshold) {\r\n    discard;\r\n  }",ditherFragPars:"varying vec4 vScreenPos;\r\n// http://fe0km.blog.fc2.com/blog-entry-122.html?sp\r\n// http://glslsandbox.com/e#30514.1\r\nfloat bayer(int iter, vec2 rc) {\r\n  float sum = 0.0;\r\n  for (int i=0; i<4; ++i) {\r\n    if (i >= iter) break;\r\n    vec2 bsize = vec2(pow(2.0, float(i+1)));\r\n    vec2 t = mod(rc, bsize) / bsize;\r\n    int idx = int(dot(floor(t*2.0), vec2(2.0, 1.0)));\r\n    float b = 0.0;\r\n    if (idx == 0) { b = 0.0; } else if (idx == 1) { b = 2.0; } else if (idx == 2) { b = 3.0; } else { b = 1.0; }\r\n    sum += b * pow(4.0, float(iter-i-1));\r\n  }\r\n  float phi = pow(4.0, float(iter)) + 1.0;\r\n  return (sum + 1.0) / phi;\r\n}",edgeCompositeFrag:"uniform sampler2D tDiffuse;\r\nuniform sampler2D tEdge;\r\nuniform vec3 edgeColor;\r\nvarying vec2 vUv;\r\nvoid main() {\r\n  vec4 diffuse = texture2D(tDiffuse, vUv);\r\n  vec4 edge = texture2D(tEdge, vUv);\r\n  vec4 color = mix(diffuse, vec4(edgeColor, 1.0), edge.x);\r\n  gl_FragColor = vec4(color.xyz, 1.0);\r\n}",edgeCompositeUniforms:{tDiffuse:{value:null},tEdge:{value:null},edgeColor:{value:new r.Vector3}},edgeCompositeVert:"varying vec2 vUv;\r\nvoid main() {\r\n  vUv = uv;\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}",edgeExpandFrag:"uniform sampler2D tDiffuse;\r\nuniform vec2 aspect;\r\nuniform float strength;\r\nvarying vec2 vUv0;\r\nvarying vec2 vUv1;\r\nvarying vec2 vUv2;\r\nvarying vec2 vUv3;\r\nvarying vec2 vUv4;\r\nvarying vec2 vUv5;\r\nvarying vec2 vUv6;\r\nvarying vec2 vUv7;\r\nvoid main() {\r\n  vec2 dvu = vec2(4.0 / aspect.x, 0);\r\n  vec4 color = texture2D(tDiffuse, vUv0)\r\n             + texture2D(tDiffuse, vUv1)\r\n             + texture2D(tDiffuse, vUv2)\r\n             + texture2D(tDiffuse, vUv3)\r\n             + texture2D(tDiffuse, vUv4)\r\n             + texture2D(tDiffuse, vUv5)\r\n             + texture2D(tDiffuse, vUv6)\r\n             + texture2D(tDiffuse, vUv7)\r\n             + texture2D(tDiffuse, vUv0 + dvu)\r\n             + texture2D(tDiffuse, vUv1 + dvu)\r\n             + texture2D(tDiffuse, vUv2 + dvu)\r\n             + texture2D(tDiffuse, vUv3 + dvu)\r\n             + texture2D(tDiffuse, vUv4 + dvu)\r\n             + texture2D(tDiffuse, vUv5 + dvu)\r\n             + texture2D(tDiffuse, vUv6 + dvu)\r\n             + texture2D(tDiffuse, vUv7 + dvu);\r\n  gl_FragColor = vec4(color.xyz * strength, 1);\r\n}",edgeExpandUniforms:{tDiffuse:{value:null},aspect:{value:new r.Vector2},strength:{value:.7}},edgeExpandVert:"uniform vec2 aspect;\r\nvarying vec2 vUv0;\r\nvarying vec2 vUv1;\r\nvarying vec2 vUv2;\r\nvarying vec2 vUv3;\r\nvarying vec2 vUv4;\r\nvarying vec2 vUv5;\r\nvarying vec2 vUv6;\r\nvarying vec2 vUv7;\r\nvoid main() {\r\n  vec2 stepUV = vec2(1.0 / aspect.x, 1.0 / aspect.y);\r\n  vec2 stepUV3 = stepUV * 3.0;\r\n  vUv0 = uv + vec2(-stepUV3.x, -stepUV3.y);\r\n  vUv1 = uv + vec2(-stepUV3.x, -stepUV.y);\r\n  vUv2 = uv + vec2(-stepUV3.x, stepUV.y);\r\n  vUv3 = uv + vec2(-stepUV3.x, stepUV3.y);\r\n  vUv4 = uv + vec2(-stepUV.x, -stepUV3.y);\r\n  vUv5 = uv + vec2(-stepUV.x, -stepUV.y);\r\n  vUv6 = uv + vec2(-stepUV.x, stepUV.y);\r\n  vUv7 = uv + vec2(-stepUV.x, stepUV3.y);\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}",edgeFrag:"uniform sampler2D tDiffuse;\r\nvarying vec2 vUv0;\r\nvarying vec2 vUv1;\r\nvarying vec2 vUv2;\r\nvarying vec2 vUv3;\r\nvoid main() {\r\n  float d0 = texture2D(tDiffuse, vUv0).x - texture2D(tDiffuse, vUv1).x;\r\n  float d1 = texture2D(tDiffuse, vUv2).x - texture2D(tDiffuse, vUv3).x;\r\n  gl_FragColor = vec4(vec3(d0*d0 + d1*d1), 1);\r\n}",edgeIDFrag:"uniform sampler2D tDiffuse;\r\nvarying vec2 vUv0;\r\nvarying vec2 vUv1;\r\nvarying vec2 vUv2;\r\nvarying vec2 vUv3;\r\nvoid main() {\r\n  float t0 = texture2D(tDiffuse, vUv0).x;\r\n  float t1 = texture2D(tDiffuse, vUv1).x;\r\n  float t2 = texture2D(tDiffuse, vUv2).x;\r\n  float t3 = texture2D(tDiffuse, vUv3).x;\r\n  float t0t1 = t0 - t1;\r\n  float t2t3 = t2 - t3;\r\n  float id0 = t0t1 * t0t1;\r\n  float id1 = t2t3 * t2t3;\r\n  gl_FragColor = vec4(vec3((id0 + id1) * 64.0), 1.0);\r\n}",edgeIDUniforms:{tDiffuse:{value:null},step:{value:2},aspect:{value:new r.Vector2}},edgeIDVert:"uniform vec2 aspect;\r\nuniform float step;\r\nvarying vec2 vUv0;\r\nvarying vec2 vUv1;\r\nvarying vec2 vUv2;\r\nvarying vec2 vUv3;\r\nvoid main() {\r\n  vec2 stepUV = vec2(step / aspect.x, step / aspect.y);\r\n  vUv0 = uv + vec2(-stepUV.x, -stepUV.y);\r\n  vUv1 = uv + vec2( stepUV.x,  stepUV.y);\r\n  vUv2 = uv + vec2(-stepUV.x,  stepUV.y);\r\n  vUv3 = uv + vec2( stepUV.x, -stepUV.y);\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}",edgeUniforms:{tDiffuse:{value:null},aspect:{value:new r.Vector2}},edgeVert:"uniform vec2 aspect;\r\nvarying vec2 vUv0;\r\nvarying vec2 vUv1;\r\nvarying vec2 vUv2;\r\nvarying vec2 vUv3;\r\nvoid main() {\r\n  vec2 stepUV = vec2(0.5 / aspect.x, 0.5 / aspect.y);\r\n  vUv0 = uv + vec2(-stepUV.x, -stepUV.y);\r\n  vUv1 = uv + vec2( stepUV.x,  stepUV.y);\r\n  vUv2 = uv + vec2(-stepUV.x,  stepUV.y);\r\n  vUv3 = uv + vec2( stepUV.x, -stepUV.y);\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}",emissiveFrag:"emissive += emissiveColor;",emissiveFragPars:"uniform vec3 emissiveColor;",emissiveMapFrag:"emissive *= texture2D(tEmissive, uv).rgb;",emissiveMapFragPars:"uniform sampler2D tEmissive;",emissiveMapUniforms:{tEmissive:{value:null}},emissiveUniforms:{emissiveColor:{value:new r.Color(0)}},endFrag:"  gl_FragColor.xyz = outgoingLight;\r\n  gl_FragColor.a = material.opacity;",endFragDebug:"gl_FragColor.rgb = debugColor;",fakeSunFrag:"uniform vec2 sunPos; // screen space\r\nuniform float aspect;\r\nuniform vec3 sunColor;\r\nuniform vec3 bgColor;\r\nvarying vec2 vUv;\r\nvoid main() {\r\n  vec2 diff = vUv - sunPos;\r\n  \r\n  // Correct for aspect ratio\r\n  diff.x *= aspect;\r\n  \r\n  float prop = clamp(length(diff) / 0.5, 0.0, 1.0);\r\n  prop = 0.35 * pow(1.0 - prop, 3.0);\r\n  gl_FragColor.xyz = mix(sunColor, bgColor, 1.0 - prop);\r\n  gl_FragColor.a = 1.0;\r\n}",fakeSunUniforms:{sunPos:{value:new r.Vector2},aspect:{value:1},sunColor:{value:new r.Color},bgColor:{value:new r.Color}},fakeSunVert:"varying vec2 vUv;\r\nvoid main() {\r\n  vUv = uv;\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}",fogFrag:"  outgoingLight = fogColor * vFogFactor + outgoingLight * (1.0 - vFogFactor);",fogFragPars:"uniform vec3 fogColor;\r\nvarying float vFogFactor;",fogUniforms:{fogAlpha:{value:1},fogFar:{value:50},fogNear:{value:1},fogColor:{value:new r.Color}},fogVert:"  float fogParamA = fogFar / (fogFar - fogNear);\r\n  float fogParamB = -1.0 / (fogFar - fogNear);\r\n  float fogFactor = 1.0 - (fogParamA + hpos.w * fogParamB);\r\n  vFogFactor = clamp(fogFactor, 0.0, 1.0) * fogAlpha;",fogVertPars:"uniform float fogAlpha;\r\nuniform float fogFar;\r\nuniform float fogNear;\r\nvarying float vFogFactor;",fresnelFrag:"  vec3 cameraToVertex = normalize(vWorldPosition - cameraPosition);\r\n\r\n  // Transforming Normal Vectors with the Inverse Transformation\r\n  vec3 worldNormal = inverseTransformDirection(geometry.normal, viewMatrix);\r\n\r\n  float krmin = reflectionStrength * fresnelReflectionScale;\r\n  float invFresnelExponent = 1.0 / fresnelExponent;\r\n  float ft = pow(abs(dot(worldNormal, cameraToVertex)), invFresnelExponent);\r\n  float fresnel = mix(reflectionStrength, krmin, ft);\r\n  vec3 vReflect = reflect(cameraToVertex, worldNormal);\r\n  vReflect.x = -vReflect.x; // flip\r\n  reflectedLight.indirectSpecular += textureCube(tEnvMap, vReflect).rgb * fresnel;",fresnelFragPars:"uniform float fresnelExponent;\r\nuniform float fresnelReflectionScale;",fresnelUniforms:{fresnelExponent:{value:3.5},fresnelReflectionScale:{value:.5}},glassFrag:"  vec4 glassPos = vScreenPos;\r\n  glassPos.xy += (geometry.viewDir.xy - geometry.normal.xy) * (glassCurvature * vScreenPos.w);\r\n  glassPos.xy /= glassPos.w;\r\n// vec4 distortionNormal = texture2D(tDistortion, vUv);\r\n// vec3 distortion = (distortionNormal.rgb - vec3(0.5)) * distortionStrength;\r\n  distortionNormal = texture2D(tDistortion, vUv + distortion.xy);\r\n  distortion = distortionNormal.rgb - vec3(0.5);\r\n  glassPos.xy += distortion.xy;\r\n  reflectedLight.directDiffuse = mix(reflectedLight.directDiffuse, texture2D(tBackBuffer, glassPos.xy).rgb, glassStrength);",glassFragPars:"uniform sampler2D tBackBuffer;\r\nuniform float glassStrength;\r\nuniform float glassCurvature;\r\nvarying vec4 vScreenPos;",glassUniforms:{tBackBuffer:{value:null},glassStrength:{value:.7},glassCurvature:{value:.5}},glassVert:"  vScreenPos.xy = vScreenPos.xy * 0.5 + (0.5 * hpos.w);",glsl3Frag:"precision mediump sampler2DArray;\r\n#define varying in\r\n#ifndef MULTIRENDERCOLOR\r\nlayout(location = 0) out highp vec4 outFragColor;\r\n#endif\r\n#define gl_FragColor outFragColor\r\n#define gl_FragDepthEXT gl_FragDepth\r\n#define texture2D texture\r\n#define textureCube texture\r\n#define texture2DProj textureProj\r\n#define texture2DLodEXT textureLod\r\n#define texture2DProjLodEXT textureProjLod\r\n#define textureCubeLodEXT textureLod\r\n#define texture2DGradEXT textureGrad\r\n#define texture2DProjGradEXT textureProjGrad\r\n#define textureCubeGradEXT textureGrad\r\nprecision highp float;\r\nprecision highp int;\r\n#define HIGH_PRECISION",glsl3Vert:"precision mediump sampler2DArray;\r\n#define attribute in\r\n#define varying out\r\n#define texture2D texture\r\nprecision highp float;\r\nprecision highp int;\r\n#define HIGH_PRECISION",godRayCompositeFrag:"uniform sampler2D tColors;\r\nuniform sampler2D tGodRays;\r\nuniform float intensity;\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n  // Since THREE.MeshDepthMaterial renders foreground objects white and background\r\n  // objects black, the god-rays will be white streaks. \r\n  // Therefore value is inverted\r\n  // before being combined with tColors\r\n  gl_FragColor = texture2D(tColors, vUv) + intensity * vec4(1.0 - texture2D(tGodRays, vUv).r);\r\n  gl_FragColor.a = 1.0;\r\n}",godRayCompositeUniforms:{intensity:{value:1},tColors:{value:null},tGodRays:{value:null}},godRayCompositeVert:"varying vec2 vUv;\r\nvoid main() {\r\n  vUv = uv;\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}",godRayFrag:"#define TAPS_PER_PASS 6.0\r\nuniform sampler2D tDiffuse;\r\nuniform vec2 sunPos;\r\nuniform float stepSize;\r\nvarying vec2 vUv;\r\nvoid main() {\r\n\r\n  // delta from current pixel to sun position\r\n  vec2 delta = sunPos - vUv;\r\n  float dist = length(delta);\r\n  \r\n  // Step vector (uv space)\r\n  vec2 stepv = stepSize * delta / dist;\r\n  \r\n  // Number of iterations between pixel and sun\r\n  float iters = dist / stepSize;\r\n  vec2 uv = vUv.xy;\r\n  float col = 0.0;\r\n  \r\n  // Unrolling loop manuarry makes it work in ANGLE\r\n  if (0.0 <= iters && uv.y < 1.0) col += texture2D(tDiffuse, uv).r;\r\n  uv += stepv;\r\n  if (1.0 <= iters && uv.y < 1.0) col += texture2D(tDiffuse, uv).r;\r\n  uv += stepv;\r\n  if (2.0 <= iters && uv.y < 1.0) col += texture2D(tDiffuse, uv).r;\r\n  uv += stepv;\r\n  if (3.0 <= iters && uv.y < 1.0) col += texture2D(tDiffuse, uv).r;\r\n  uv += stepv;\r\n  if (4.0 <= iters && uv.y < 1.0) col += texture2D(tDiffuse, uv).r;\r\n  uv += stepv;\r\n  if (5.0 <= iters && uv.y < 1.0) col += texture2D(tDiffuse, uv).r;\r\n  uv += stepv;\r\n  \r\n  // Should technicallry be dividing by 'iters', but 'TAPS_PER_PASS' smooths out\r\n  // objectionable artifacts, in particular near the position.\r\n  // The side effect is that the result is darker than it should be around the sun, \r\n  // as TAPS_PER_PASS is greater than the number of sampler actually accumulated.\r\n  // When the result is inverted (in the shader 'GodLaysCombine', \r\n  // this produces a slight bright spot at the position of the sun,\r\n  // even when it is occluded.\r\n  gl_FragColor = vec4(col / TAPS_PER_PASS);\r\n  gl_FragColor.a = 1.0;\r\n}",godRayUniforms:{tDiffuse:{value:null},sunPos:{value:new r.Vector2},stepSize:{value:1}},godRayVert:"varying vec2 vUv;\r\nvoid main() {\r\n  vUv = uv;\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}",grassUniforms:{grassWindDirection:{value:new r.Vector3(1,0,0)},grassWindPower:{value:1},grassTime:{value:0}},grassVert:"// transformed += grassWindDirection * grassWindPower * max(transformed.y, 0.0) * sin(grassTime);\r\n// vWorldPosition += grassWindDirection * grassWindPower * max(vWorldPosition.y, 0.0) * sin(grassTime);\r\n  float windStrength = (uv.y * uv.y) * (sin(grassTime + color.y * PI) * 0.5 + 0.5) * color.x;\r\n  vWorldPosition += offsets;\r\n  vWorldPosition += grassWindDirection * grassWindPower * windStrength;",grassVertPars:"attribute vec3 offsets;\r\nattribute vec4 color;\r\nuniform vec3 grassWindDirection;\r\nuniform float grassWindPower;\r\nuniform float grassTime;",heightFogFrag:"  outgoingLight = heightFogColor * vHeightFogFactor + outgoingLight * (1.0 - vHeightFogFactor);",heightFogFragPars:"uniform vec3 heightFogColor;\r\nvarying float vHeightFogFactor;",heightFogMapFrag:"  float heightFogFactor = vHeightFogFactor;\r\n  heightFogFactor *= texture2D(tHeightFog, vUv).r;\r\n  outgoingLight = heightFogColor * heightFogFactor + outgoingLight * (1.0 - vHeightFogFactor);",heightFogMapFragPars:"uniform sampler2D tHeightFog;",heightFogMapUniforms:{tHeightFog:{value:null}},heightFogUniforms:{heightFogAlpha:{value:1},heightFogFar:{value:50},heightFogNear:{value:1},heightFogColor:{value:new r.Color}},heightFogVert:"  float heightFogParamA = heightFogFar / (heightFogFar - heightFogNear);\r\n  float heightFogParamB = -1.0 / (heightFogFar - heightFogNear);\r\n  float heightFogFactor = 1.0 - (heightFogParamA + vWorldPosition.y * heightFogParamB);\r\n  vHeightFogFactor = clamp(heightFogFactor, 0.0, 1.0) * heightFogAlpha;",heightFogVertPars:"uniform float heightFogAlpha;\r\nuniform float heightFogFar;\r\nuniform float heightFogNear;\r\nvarying float vHeightFogFactor;",idFrag:"uniform float id;\r\nvoid main() {\r\n  gl_FragColor = vec4(vec3(id), 1);\r\n}",idUniforms:{id:{value:1}},idVert:"void main() {\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}",innerGlowFrag:"  float glow = 1.0 - max(0.0, dot(geometry.normal, geometry.viewDir));\r\n  float glowPow = max(glow / (innerGlowBase * (1.0 - glow) + glow), 0.0) * innerGlowSub;\r\n  glowPow = max(0.0, glowPow - innerGlowRange) * (1.0 / max(1.0 - innerGlowRange, 0.00001));\r\n  glowPow = min(glowPow, 1.0);\r\n  // glowPow = min(1.0, glowPow*step(innerGlowRange, glowPow));\r\n  reflectedLight.indirectSpecular += innerGlowColor * glowPow;\r\n  // reflectedLight.indirectSpecular += vec3(glowPow);\r\n  // reflectedLight.indirectSpecular += vec3(glow);",innerGlowFragPars:"uniform vec3 innerGlowColor;\r\nuniform float innerGlowBase;\r\nuniform float innerGlowSub;\r\nuniform float innerGlowRange;",innerGlowSubtractFrag:"  float glow = 1.0 - max(0.0, dot(geometry.normal, geometry.viewDir));\r\n  float glowPow = max(glow / (innerGlowBase * (1.0 - glow) + glow), 0.0) * innerGlowSub;\r\n  glowPow = -max(0.0, glowPow - innerGlowRange) * (1.0 / (1.0 - innerGlowRange));\r\n  reflectedLight.indirectSpecular += innerGlowColor * glowPow;",innerGlowUniforms:{innerGlowColor:{value:new r.Color},innerGlowBase:{value:20},innerGlowSub:{value:10},innerGlowRange:{value:0}},instanceCastShadowVert:"  vec3 vPos = (modelMatrix * vec4(position, 1.0)).xyz;\r\n  float windStrength = (uv.y * uv.y) * (sin(grassTime + color.y * PI) * 0.5 + 0.5) * color.x;\r\n  vPos += offsets;\r\n  vPos += grassWindDirection * grassWindPower * windStrength;\r\n  vec4 hpos = lightViewProjectionMatrix * vec4(vPos, 1.0);\r\n  vShadowMapUV = hpos;",instanceCastShadowVertPars:"// attribute vec3 offsets;\r\n// attribute vec4 colors;\r\nuniform mat4 lightViewProjectionMatrix;\r\nvarying vec4 vShadowMapUV;",instanceColorMapDiscardFrag:"  if (texture2D(tDiffuse, vUv).a < 0.5) discard;",lambertFrag:"  float NoL = max(dot(directLight.direction, geometry.normal), 0.0);\r\n  reflectedLight.directDiffuse += material.diffuseColor * directLight.color * NoL;",lightMapFrag:"  reflectedLight.directDiffuse *= mix(vec3(1.0), texture2D(tLight, vUv).rgb * lightMapPower, lightMapStrength);;",lightMapFragPars:"uniform sampler2D tLight;\r\nuniform float lightMapPower;\r\nuniform float lightMapStrength;",lightMapUniforms:{tLight:{value:null},lightMapPower:{value:1},lightMapStrength:{value:1}},lightsAreaLightFrag:"  for (int i=0; i<PIXY_AREA_LIGHTS_NUM; ++i) {\r\n    computeAreaLight(areaLights[i], geometry, material, reflectedLight);\r\n  }",lightsAreaLightFragUnroll:"  computeAreaLight(areaLights[0], geometry, material, reflectedLight);",lightsAreaLightUniforms:{areaLights:{value:[]}},lightsDirectFrag:"  for (int i=0; i<PIXY_DIRECT_LIGHTS_NUM; ++i) {\r\n    getDirectLightIrradiance(directLights[i], geometry, directLight);\r\n    if (directLight.visible) {\r\n      updateLight(directLight);\r\n      computeLight(directLight, geometry, material, reflectedLight);\r\n    }\r\n  }",lightsDirectFragUnroll:"  getDirectLightIrradiance(directLights[0], geometry, directLight);\r\n  if (directLight.visible) {\r\n    updateLight(directLight);\r\n    computeLight(directLight, geometry, material, reflectedLight);\r\n  }",lightsDirectUniforms:{directLights:{value:[{direction:new r.Vector3(0,0,1),color:new r.Color(16777215)}]}},lightsFragPars:"bool testLightInRange(const in float lightDistance, const in float cutoffDistance) {\r\n  return any(bvec2(cutoffDistance == 0.0, lightDistance < cutoffDistance));\r\n}\r\n\r\nfloat punctualLightIntensityToIrradianceFactor(const in float lightDistance, const in float cutoffDistance, const in float decayExponent) {\r\n  \r\n  if (decayExponent > 0.0) {\r\n  \r\n// #if defined(PHYSICALLY_CORRECT_LIGHTS)\r\n  // based upon Frostbite 3 Moving to Physically-based Rendering\r\n  // page 32, equation 26: E[window1]\r\n  // http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr_v2.pdf\r\n  // this is intended to be used to spot and point lights who are represented as mulinouse intensity\r\n  // but who must be converted to luminous irradiance for surface lighting calculation\r\n  \r\n  // float distanceFalloff = 1.0 / max(pow(lightDistance, decayExponent), 0.01);\r\n  // float maxDistanceCutoffFactor = pow2(saturate(1.0 - pow4(lightDistance / cutoffDistance)));\r\n  // return distanceFalloff * maxDistanceCutoffFactor;\r\n// #else\r\n    return pow(saturate(-lightDistance / cutoffDistance + 1.0), decayExponent);\r\n// #endif\r\n  }\r\n\r\n  return 1.0;\r\n}\r\n\r\nstruct DirectLight {\r\n  vec3 direction;\r\n  vec3 color;\r\n};\r\n\r\nvoid getDirectLightIrradiance(const in DirectLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight) {\r\n  directLight.color = directionalLight.color;\r\n  directLight.direction = directionalLight.direction;\r\n  directLight.visible = true;\r\n}\r\n\r\nstruct PointLight {\r\n  vec3 position;\r\n  vec3 color;\r\n  float distance;\r\n  float decay;\r\n};\r\n\r\nvoid getPointDirectLightIrradiance(const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight) {\r\n  vec3 L = pointLight.position - geometry.position;\r\n  directLight.direction = normalize(L);\r\n\r\n  float lightDistance = length(L);\r\n\r\n  if (testLightInRange(lightDistance, pointLight.distance)) {\r\n    directLight.color = pointLight.color;\r\n    directLight.color *= punctualLightIntensityToIrradianceFactor(lightDistance, pointLight.distance, pointLight.decay);\r\n    directLight.visible = true;\r\n  } else {\r\n    directLight.color = vec3(0.0);\r\n    directLight.visible = false;\r\n  }\r\n}\r\n\r\nstruct SpotLight {\r\n  vec3 position;\r\n  vec3 direction;\r\n  vec3 color;\r\n  float distance;\r\n  float decay;\r\n  float coneCos;\r\n  float penumbraCos;\r\n};\r\n\r\nvoid getSpotDirectLightIrradiance(const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight) {\r\n  vec3 L = spotLight.position - geometry.position;\r\n  directLight.direction = normalize(L);\r\n\r\n  float lightDistance = length(L);\r\n  float angleCos = dot(directLight.direction, spotLight.direction);\r\n\r\n  if (all(bvec2(angleCos > spotLight.coneCos, testLightInRange(lightDistance, spotLight.distance)))) {\r\n    float spotEffect = smoothstep(spotLight.coneCos, spotLight.penumbraCos, angleCos);\r\n    directLight.color = spotLight.color;\r\n    directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor(lightDistance, spotLight.distance, spotLight.decay);\r\n    directLight.visible = true;\r\n  } else {\r\n    directLight.color = vec3(0.0);\r\n    directLight.visible = false;\r\n  }\r\n}\r\n\r\nstruct AreaLight {\r\n  vec3 position;\r\n  vec3 color;\r\n  float distance;\r\n  float decay;\r\n  float radius;\r\n};\r\n\r\nstruct TubeLight {\r\n  vec3 start;\r\n  vec3 end;\r\n  vec3 color;\r\n  float distance;\r\n  float decay;\r\n  float radius;\r\n};\r\n\r\nstruct RectLight {\r\n  vec3 positions[4];\r\n  vec3 normal;\r\n  vec3 tangent;\r\n  vec3 color;\r\n  float intensity;\r\n  float width;\r\n  float height;\r\n  float distance;\r\n  float decay;\r\n  int numPositions;\r\n};",lightsPars:"// taken from here: http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html\r\nfloat getSpecularMipLevel(const in float blinnShininessExponent, const in int maxMipLevel) {\r\n  float maxMipLevelScalar = float(maxMipLevel);\r\n  float desiredMipLevel = maxMipLevelScalar - 0.79248 - 0.5 * log2(pow2(blinnShininessExponent)+1.0);\r\n  \r\n  // clamp to allowable LOD ranges\r\n  return clamp(desiredMipLevel, 0.0, maxMipLevelScalar);\r\n}\r\n\r\nvec3 getLightProbeIndirectIrradiance(const in vec3 N, const in float blinnShininessExponent, const in int maxMipLevel) {\r\n  vec3 worldNormal = inverseTransformDirection(N, viewMatrix);\r\n  vec3 queryVec = vec3(-worldNormal.x, worldNormal.yz); // flip\r\n  return GammaToLinear(textureCubeLodEXT(tEnvMap, queryVec, float(maxMipLevel)), 2.2).rgb * reflectionStrength;\r\n}\r\n\r\nvec3 getLightProbeIndirectRadiance(const in vec3 V, const in vec3 N, const in float blinnShininessExponent, const in int maxMipLevel) {\r\n  vec3 reflectVec = reflect(-V, N);\r\n  reflectVec = inverseTransformDirection(reflectVec, viewMatrix);\r\n  vec3 queryVec = vec3(-reflectVec.x, reflectVec.yz); // flip\r\n  float specMipLevel = getSpecularMipLevel(blinnShininessExponent, maxMipLevel);\r\n  return GammaToLinear(textureCubeLodEXT(tEnvMap, queryVec, specMipLevel), 2.2).rgb * reflectionStrength;\r\n}",lightsPointFrag:"  for (int i=0; i<PIXY_POINT_LIGHTS_NUM; ++i) {\r\n    getPointDirectLightIrradiance(pointLights[i], geometry, directLight);\r\n    if (directLight.visible) {\r\n      updateLight(directLight);\r\n      computeLight(directLight, geometry, material, reflectedLight);\r\n    }\r\n  }",lightsPointFragUnroll:"  getPointDirectLightIrradiance(pointLights[0], geometry, directLight);\r\n  if (directLight.visible) {\r\n    updateLight(directLight);\r\n    computeLight(directLight, geometry, material, reflectedLight);\r\n  }",lightsPointUniforms:{pointLights:{value:[{position:new r.Vector3,color:new r.Color,distance:1,decay:0}]}},lightsRectLightFrag:"for (int i=0; i<PIXY_RECT_LIGHTS_NUM; ++i) {\r\n  computeRectLight(rectLights[i], geometry, material, reflectedLight);\r\n}",lightsRectLightFragUnroll:"  computeRectLight(rectLights[0], geometry, material, reflectedLight);",lightsRectLightUniforms:{rectLights:{value:[]}},lightsSpotFrag:"  for (int i=0; i<PIXY_SPOT_LIGHTS_NUM; ++i) {\r\n    getSpotDirectLightIrradiance(spotLights[i], geometry, directLight);\r\n    if (directLight.visible) {\r\n      updateLight(directLight);\r\n      computeLight(directLight, geometry, material, reflectedLight);\r\n    }\r\n  }",lightsSpotFragUnroll:"  getSpotDirectLightIrradiance(spotLights[0], geometry, directLight);\r\n  if (directLight.visible) {\r\n    updateLight(directLight);\r\n    computeLight(directLight, geometry, material, reflectedLight);\r\n  }",lightsSpotUniforms:{spotLights:{value:[{position:new r.Vector3(0,0,10),direction:new r.Vector3(0,0,-1),color:new r.Color,distance:10,decay:0,coneCos:Math.PI/4,penumbraCos:1}]}},lightsStandardDisneyFrag:"material.specularRoughness = roughnessFactor;\r\n\r\nfloat luminance = 0.3 * material.diffuseColor.x + 0.6 * material.diffuseColor.y + 0.1 * material.diffuseColor.z;\r\nvec3 tint = luminance > 0.0 ? material.diffuseColor / luminance : vec3(1.0);\r\nspecularColor = mix(0.5 * 0.08 * mix(vec3(1.0), tint, SpecularTint), material.diffuseColor, Metallic);\r\n\r\n//material.specularColor = mix(vec3(0.04), material.diffuseColor, metalnessFactor);\r\n//material.diffuseColor = material.diffuseColor * (1.0 - metalnessFactor);\r\nMetallic = metalnessFactor;",lightsStandardFrag:"material.specularRoughness = roughnessFactor;\r\nmaterial.specularColor = mix(vec3(0.04), material.diffuseColor, metalnessFactor);\r\nmaterial.diffuseColor = material.diffuseColor * (1.0 - metalnessFactor);",lightsTubeLightFrag:"for (int i=0; i<PIXY_TUBE_LIGHTS_NUM; ++i) {\r\n  computeTubeLight(tubeLights[i], geometry, material, reflectedLight);\r\n}",lightsTubeLightFragUnroll:"  computeTubeLight(tubeLights[0], geometry, material, reflectedLight);",lightsTubeLightUniforms:{tubeLights:{value:[]}},lineGlowFrag:"    float lineGlowDist = abs(dot(vWorldPosition, normalize(lineGlowPlane.xyz)) - lineGlowPlane.w);\r\n    reflectedLight.indirectSpecular += max(1.0 - lineGlowDist / lineGlowRange, 0.0) * lineGlowPower * lineGlowColor;",lineGlowFragPars:"uniform vec4 lineGlowPlane;\r\nuniform vec3 lineGlowColor;\r\nuniform float lineGlowRange;\r\nuniform float lineGlowPower;",lineGlowUniforms:{lineGlowPlane:{value:new r.Vector4(0,1,0,0)},lineGlowColor:{value:new r.Color(16777215)},lineGlowRange:{value:1},lineGlowPower:{value:1}},luminosityFrag:"uniform sampler2D tDiffuse;\r\n\r\nvarying vUv;\r\n\r\nvoid main() {\r\n  vec4 texel = texture2D(tDiffuse, vUv);\r\n  vec3 luma = vec3(0.299, 0.587, 0.114);\r\n  float v = dot(texel.xyz, luma);\r\n  gl_FragColor = vec4(v, v, v, texel.w);\r\n}",luminosityHighPassFrag:"uniform sampler2D tDiffuse;\r\nuniform vec3 defaultColor;\r\nuniform float defaultOpacity;\r\nuniform float luminosityThreshold;\r\nuniform float smoothWidth;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n  vec4 texel = texture2D(tDiffuse, vUv);\r\n  vec3 luma = vec3(0.299, 0.587, 0.114);\r\n  float v = dot(texel.xyz, luma);\r\n  vec4 outputColor = vec4(defaultColor.rgb, defaultOpacity);\r\n  float alpha = smoothstep(luminosityThreshold, luminosityThreshold + smoothWidth, v);\r\n  gl_FragColor = mix(outputColor, texel, alpha);\r\n}",luminosityHighPassUniforms:{tDiffuse:{value:null},luminosityThreshold:{value:1},smoothWidth:{value:1},defaultColor:{value:new r.Color(0)},defaultOpacity:{value:0}},luminosityHighPassVert:"varying vec2 vUv;\r\nvoid main() {\r\n  vUv = uv;\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}",luminosityUniforms:{tDiffuse:{value:null}},luminosityVert:"varying vec2 vUv;\r\nvoid main() {\r\n  vUv = uv;\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}",metalnessFrag:"  float metalnessFactor = metalness;",metalnessMapFrag:"  vec4 metalnessRGBA = texture2D(tMetalness, uv);\r\n  metalnessFactor *= metalnessRGBA.r;",metalnessMapFragPars:"uniform sampler2D tMetalness;",metalnessMapUniforms:{tMetalness:{value:null}},nolitFrag:"  reflectedLight.directDiffuse += material.diffuseColor;",normalMapFrag:"  vec4 normalRGBA = texture2D(tNormal, uv);\r\n  vec3 bump = (normalRGBA.rgb - vec3(0.5)) * bumpiness;\r\n  geometry.normal = normalize(vNormal + bump.x * vTangent + bump.y * vBinormal);\r\n// geometry.normal = perturbNormal2Arb(-vViewPosition, normalize(vNormal));",normalMapFragPars:"uniform sampler2D tNormal;\r\nuniform float bumpiness;\r\n\r\n// Per-Pixel Tangent Space Normal Mapping\r\n// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\r\n\r\n// vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\r\n// \r\n// \tvec3 q0 = dFdx( eye_pos.xyz );\r\n// \tvec3 q1 = dFdy( eye_pos.xyz );\r\n// \tvec2 st0 = dFdx( vUv.st );\r\n// \tvec2 st1 = dFdy( vUv.st );\r\n// \r\n// \tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\r\n// \tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\r\n// \tvec3 N = normalize( surf_norm );\r\n// \r\n// \tvec3 mapN = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;\r\n// \tmapN.xy = bumpiness * mapN.xy;\r\n// \tmat3 tsn = mat3( S, T, N );\r\n// \treturn normalize( tsn * mapN );\r\n// \r\n// }",normalMapUniforms:{tNormal:{value:null},bumpiness:{value:1}},opacityFrag:"uniform sampler2D tDiffuse;\r\nvarying vec2 vUv;\r\nvoid main() {\r\n  float a = texture2D(tDiffuse, vUv).a;\r\n  gl_FragColor = vec4(a, a, a, 1.0);\r\n}",opacityUniforms:{tDiffuse:{value:null}},opacityVert:"varying vec2 vUv;\r\nvoid main() {\r\n  vUv = uv;\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}",overlayFrag:"// https://github.com/GameTechDev/CloudsGPUPro6/blob/master/fx/Terrain.fx\r\n// https://github.com/GameTechDev/CloudySky/blob/master/fx/Terrain.fx\r\n\r\n  vec4 mtrlWeights = texture2D(tOverlayMask, uv);\r\n  mtrlWeights /= max(dot(mtrlWeights, vec4(1.0,1.0,1.0,1.0)), 1.0);\r\n  float baseMaterialWeight = clamp(1.0 - dot(mtrlWeights, vec4(1,1,1,1)), 0.0, 1.0);\r\n  vec4 baseMaterialDiffuse = texture2D(tOverlay1, uv * overlay1Scale);\r\n  mat4 materialColors;\r\n  materialColors[0] = texture2D(tOverlay2, uv * overlay2Scale) * mtrlWeights.x;\r\n  materialColors[1] = texture2D(tOverlay3, uv * overlay3Scale) * mtrlWeights.y;\r\n  materialColors[2] = texture2D(tOverlay4, uv * overlay4Scale) * mtrlWeights.z;\r\n  materialColors[3] = texture2D(tOverlay5, uv * overlay5Scale) * mtrlWeights.w;\r\n  material.diffuseColor.rgb *= (baseMaterialDiffuse * baseMaterialWeight + materialColors * mtrlWeights).rgb;",overlayFragPars:"// https://github.com/GameTechDev/CloudsGPUPro6/blob/master/fx/Terrain.fx\r\n// https://github.com/GameTechDev/CloudySky/blob/master/fx/Terrain.fx\r\n\r\nuniform sampler2D tOverlay1;\r\nuniform sampler2D tOverlay2;\r\nuniform sampler2D tOverlay3;\r\nuniform sampler2D tOverlay4;\r\nuniform sampler2D tOverlay5;\r\nuniform sampler2D tOverlayMask;\r\nuniform float overlay1Scale;\r\nuniform float overlay2Scale;\r\nuniform float overlay3Scale;\r\nuniform float overlay4Scale;\r\nuniform float overlay5Scale;",overlayNormalFrag:"  vec4 baseNormal = texture2D(tOverlay1Normal, uv * overlay1Scale);\r\n  mat4 normals;\r\n  normals[0] = texture2D(tOverlay2Normal, uv * overlay2Scale) * mtrlWeights.x;\r\n  normals[1] = texture2D(tOverlay3Normal, uv * overlay3Scale) * mtrlWeights.y;\r\n  normals[2] = texture2D(tOverlay4Normal, uv * overlay4Scale) * mtrlWeights.z;\r\n  normals[3] = texture2D(tOverlay5Normal, uv * overlay5Scale) * mtrlWeights.w;\r\n  vec3 overlayNormal = (baseNormal * baseMaterialWeight + normals * mtrlWeights).xyz;\r\n  overlayNormal = overlayNormal - vec3(0.5);\r\n  geometry.normal = normalize(vNormal + overlayNormal.x * vTangent + overlayNormal.y * vBinormal);",overlayNormalFragPars:"uniform sampler2D tOverlay1Normal;\r\nuniform sampler2D tOverlay2Normal;\r\nuniform sampler2D tOverlay3Normal;\r\nuniform sampler2D tOverlay4Normal;\r\nuniform sampler2D tOverlay5Normal;",overlayNormalUniforms:{tOverlay1Normal:{value:null},tOverlay2Normal:{value:null},tOverlay3Normal:{value:null},tOverlay4Normal:{value:null},tOverlay5Normal:{value:null}},overlayUniforms:{tOverlay1:{value:null},tOverlay2:{value:null},tOverlay3:{value:null},tOverlay4:{value:null},tOverlay5:{value:null},tOverlayMask:{value:null},overlay1Scale:{value:1},overlay2Scale:{value:1},overlay3Scale:{value:1},overlay4Scale:{value:1},overlay5Scale:{value:1}},packing:"vec3 packNormalToRGB(const in vec3 normal) {\r\n  return normalize(normal) * 0.5 + 0.5;\r\n}\r\nvec3 unpackRGBToNormal(const in vec3 rgb) {\r\n  return 1.0 - 2.0 * rgb.xyz;\r\n}\r\n\r\nconst vec3 PackFactors = vec3(255.0, 65025.0, 16581375.0);\r\nconst vec4 UnpackFactors = vec4(1.0, 1.0 / PackFactors);\r\nconst float ShiftRight8 = 1.0 / 255.0;\r\n// const float PackUpscale = 256.0 / 255.0; // fraction -> 0..1 (including 1)\r\n// const float UnpackDownscale = 255.0 / 256.0; // 0..1 -> fraction (excluding 1)\r\n// const vec3 PackFactors = vec3(256.0, 65535.0, 16777216.0);\r\n// const vec4 UnpackFactors = UnpackDownscale / vec4(1.0, PackFactors);\r\n// const float ShiftRight8 = 1.0 / 256.0;\r\nvec4 packDepthToRGBA(float v) {\r\n  vec4 r = vec4(v, fract(PackFactors * v));\r\n  r.xyz -= r.yzw * ShiftRight8;\r\n//   return r * PackUpscale;\r\n  return r;\r\n}\r\n\r\nfloat unpackRGBAToDepth(vec4 rgba) {\r\n  return dot(rgba, UnpackFactors);\r\n}\r\n\r\n\r\n// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\nfloat viewZToOrthographicDepth(const in float viewZ, const in float near, const in float far) {\r\n  return (viewZ + near) / (near - far);\r\n}\r\n\r\nfloat orthographicDepthToViewZ(const in float linearClipZ, const in float near, const in float far) {\r\n  return linearClipZ * (near - far) - near;\r\n}\r\n\r\nfloat viewZToPerspectiveDepth(const in float viewZ, const in float near, const in float far) {\r\n  return ((near + viewZ) * far) / ((far - near) * viewZ);\r\n}\r\n\r\nfloat perspectiveDepthToViewZ(const in float invClipZ, const in float near, const in float far) {\r\n  return (near * far) / ((far - near) * invClipZ - far);\r\n}",parallaxFrag:"  vec3 T = normalize(vTangent);\r\n  vec3 B = normalize(vBinormal);\r\n  vec3 vv = -geometry.viewDir * mat3(T, B, -geometry.normal);\r\n  uv += parallaxHeight * vv.xy;",parallaxMapFrag:"  vec3 vv = -geometry.viewDir * mat3(vTangent, vBinormal, -vNormal);\r\n  uv += (texture2D(tNormal, vUv).a * parallaxHeight + parallaxScale) * vv.xy;",parallaxMapFragPars:"uniform float parallaxHeight;\r\nuniform float parallaxScale;",parallaxMapUniforms:{parallaxHeight:{value:.035},parallaxScale:{value:-.03}},parallaxOcclusionMapFrag:"  vec3 vv = -geometry.viewDir * mat3(vTangent, vBinormal, vNormal);\r\n  // vec3 vv = perturbUv(-vViewPosition, normalize(vNormal), normalize(vViewPosition));\r\n  float parallaxLimit = -length(vv.xy) / vv.z;\r\n  parallaxLimit *= parallaxScale;\r\n\r\n  vec2 vOffsetDir = normalize(vv.xy);\r\n  vec2 vMaxOffset = vOffsetDir * parallaxLimit;\r\n\r\n  float nNumSamples = mix(20.0, 10.0, dot(geometry.viewDir,vNormal));\r\n  float fStepSize = 1.0 / nNumSamples;\r\n\r\n  // debugColor = vec3(vv.xy * 0.5 + vec2(0.5), 0.0);\r\n\r\n  // vec2 dPdx = dFdx(uv);\r\n  // vec2 dPdy = dFdy(uv);\r\n\r\n  float fCurrRayHeight = 1.0;\r\n  vec2 vCurrOffset = vec2(0,0);\r\n  vec2 vLastOffset = vec2(0.0);\r\n  float fLastSampledHeight = 1.;\r\n  float fCurrSampledHeight = 1.;\r\n  for (int nCurrSample = 0; nCurrSample < 50; nCurrSample++) {\r\n    if (float(nCurrSample) > nNumSamples) break;\r\n    // fCurrSampledHeight = textureGrad(tDiffuse, uv + vCurrOffset, dPdx, dPdy).a;\r\n    // fCurrSampledHeight = texture2DGradEXT(tDiffuse, uv + vCurrOffset, dPdx, dPdy).a;\r\n    // fCurrSampledHeight = texture2D(tDiffuse, uv + vCurrOffset).a;\r\n    fCurrSampledHeight = texture2D(tHeightMap, uv + vCurrOffset).r;\r\n    if (fCurrSampledHeight > fCurrRayHeight) {\r\n      float delta1 = fCurrSampledHeight - fCurrRayHeight;\r\n      float delta2 = (fCurrRayHeight + fStepSize) - fLastSampledHeight;\r\n      float ratio = delta1 / (delta1 + delta2);\r\n      vCurrOffset = ratio * vLastOffset + (1.0-ratio) * vCurrOffset;\r\n      break;\r\n    } else {\r\n      fCurrRayHeight -= fStepSize;\r\n      vLastOffset = vCurrOffset;\r\n      vCurrOffset += fStepSize * vMaxOffset;\r\n      fLastSampledHeight = fCurrSampledHeight;\r\n    }\r\n  }\r\n\r\n  uv += vCurrOffset;",parallaxOcclusionMapFragPars:"uniform float parallaxScale;\r\nuniform sampler2D tHeightMap;\r\n\r\n// vec3 perturbUv( vec3 surfPosition, vec3 surfNormal, vec3 viewPosition ) {\r\n\r\n//     vec2 texDx = dFdx( vUv );\r\n//     vec2 texDy = dFdy( vUv );\r\n\r\n//     vec3 vSigmaX = dFdx( surfPosition );\r\n//     vec3 vSigmaY = dFdy( surfPosition );\r\n//     vec3 vR1 = cross( vSigmaY, surfNormal );\r\n//     vec3 vR2 = cross( surfNormal, vSigmaX );\r\n//     float fDet = dot( vSigmaX, vR1 );\r\n\r\n//     vec2 vProjVscr = ( 1.0 / fDet ) * vec2( dot( vR1, viewPosition ), dot( vR2, viewPosition ) );\r\n//     vec3 vProjVtex;\r\n//     vProjVtex.xy = texDx * vProjVscr.x + texDy * vProjVscr.y;\r\n//     vProjVtex.z = dot( surfNormal, viewPosition );\r\n//     return vProjVtex;\r\n// }",parallaxOcclusionMapUniforms:{parallaxScale:{value:.03},tHeightMap:{value:null}},phongFrag:"  float NoL = max(dot(directLight.direction, geometry.normal), 0.0);\r\n  reflectedLight.directDiffuse += material.diffuseColor * directLight.color * NoL;\r\n\r\n  vec3 H = normalize(geometry.viewDir + directLight.direction);\r\n  float HoN = dot(H, geometry.normal);\r\n  float pw = max(HoN / (shininess * (1.0 - HoN) + HoN), 0.0);\r\n  float specPow = step(0.0, NoL) * pw;\r\n  reflectedLight.directSpecular += specPow * material.specularRoughness * directLight.color * NoL;",phongFragPars:"uniform float shininess;",phongUniforms:{shininess:{value:50}},projectionMapFrag:"  {\r\n    vec4 Vp = viewMatrix * vec4(projectionMapPos, 1.0);\r\n    vec3 Ln = normalize(Vp.xyz - projectionPos);\r\n    vec4 lightContrib = texture2DProj(tProjectionMap, projectionUv);\r\n    reflectedLight.indirectSpecular += projectionColor * lightContrib.xyz * max(dot(Ln,geometry.normal),0.0);\r\n  }",projectionMapFragPars:"uniform sampler2D tProjectionMap;\r\nuniform vec3 projectionMapPos;\r\nuniform vec3 projectionColor;\r\nvarying vec3 projectionPos;\r\nvarying vec4 projectionUv;",projectionMapUniforms:{tProjectionMap:{value:null},projectionMapMatrix:{value:new r.Matrix4},projectionMapPos:{value:new r.Vector3},projectionColor:{value:new r.Color}},projectionMapVert:"  projectionPos = (modelViewMatrix * vec4(position, 1.0)).xyz;\r\n  projectionUv = projectionMapMatrix * modelMatrix * vec4(position, 1.0);",projectionMapVertPars:"uniform mat4 projectionMapMatrix;\r\nvarying vec3 projectionPos;\r\nvarying vec4 projectionUv;",receiveShadowFrag:"  float shadowDepth = unpackRGBAToDepth(texture2DProj(tShadow, vShadowMapUV));\r\n  float shadowColor = (shadowDepth * vDepth.w < vDepth.z-shadowBias) ? 1.0 - shadowDensity : 1.0;\r\n  directLight.color *= vec3(shadowColor);",receiveShadowFragPars:"uniform sampler2D tShadow;\r\nuniform float shadowBias;\r\nuniform float shadowDensity;\r\nvarying vec4 vDepth;\r\nvarying vec4 vShadowMapUV;",receiveShadowUniforms:{lightViewProjectionMatrix:{value:new r.Matrix4},shadowMatrix:{value:new r.Matrix4},shadowBias:{value:.03},shadowDensity:{value:1},tShadow:{value:null}},receiveShadowVert:"  vDepth = lightViewProjectionMatrix * vec4(vWorldPosition, 1.0);\r\n  vShadowMapUV = shadowMatrix * vec4(vWorldPosition, 1.0);",receiveShadowVertPars:"uniform mat4 lightViewProjectionMatrix;\r\nuniform mat4 shadowMatrix;\r\nvarying vec4 vDepth;\r\nvarying vec4 vShadowMapUV;",reflectionFrag:"  vec3 cameraToVertex = normalize(vWorldPosition - cameraPosition);\r\n\r\n  // Transforming Normal Vectors with the Inverse Transformation\r\n  vec3 worldNormal = inverseTransformDirection(geometry.normal, viewMatrix);\r\n\r\n  vec3 vReflect = reflect(cameraToVertex, worldNormal);\r\n  vReflect.x = -vReflect.x; // flip\r\n  reflectedLight.indirectSpecular += textureCube(tEnvMap, vReflect).rgb * reflectionStrength;",reflectionFragPars:"uniform samplerCube tEnvMap;\r\nuniform float reflectionStrength;",reflectionStandardFrag:"  {\r\n    float blinnExponent = GGXRoughnessToBlinnExponent(material.specularRoughness);\r\n    \r\n    vec3 irradiance = getLightProbeIndirectIrradiance(geometry.normal, blinnExponent, 10);\r\n    irradiance *= PI; // punctual light\r\n    vec3 diffuse = irradiance * DiffuseLambert(material.diffuseColor);\r\n    reflectedLight.indirectDiffuse += diffuse;\r\n    \r\n    float NoV = saturate(dot(geometry.normal, geometry.viewDir));\r\n    vec3 radiance = getLightProbeIndirectRadiance(geometry.viewDir, geometry.normal, blinnExponent, 10);\r\n    vec3 specular = radiance * EnvBRDFApprox(material.specularColor, material.specularRoughness, NoV);\r\n    reflectedLight.indirectSpecular += specular * reflectionStrength;\r\n  }",reflectionUniforms:{reflectionStrength:{value:1},tEnvMap:{value:null}},reliefMapFrag:"  vec3 vv = -geometry.viewDir * mat3(vTangent, vBinormal, vNormal);\r\n  float parallaxLimit = -length(vv.xy) / vv.z;\r\n  parallaxLimit *= parallaxScale;\r\n\r\n  vec2 vOffsetDir = normalize(vv.xy);\r\n  vec2 vMaxOffset = vOffsetDir * parallaxLimit;\r\n\r\n  float nNumSamples = mix(20.0, 10.0, dot(geometry.viewDir,vNormal));\r\n  float fStepSize = 1.0 / nNumSamples;\r\n\r\n  float fCurrRayHeight = 1.0;\r\n  vec2 vCurrOffset = vec2(0,0);\r\n  float fCurrSampledHeight = 1.;\r\n  for (int nCurrSample = 0; nCurrSample < 50; nCurrSample++) {\r\n    if (float(nCurrSample) > nNumSamples) break;\r\n    fCurrSampledHeight = texture2D(tHeightMap, uv + vCurrOffset).r;\r\n    if (fCurrSampledHeight > fCurrRayHeight) {\r\n\r\n      vec2 deltaOffset = vMaxOffset * fStepSize * 0.5;\r\n      float deltaHeight = fStepSize * 0.5;\r\n\r\n      vCurrOffset -= deltaOffset;\r\n      fCurrRayHeight += deltaHeight;\r\n\r\n      const int numSearches = 5;\r\n      for (int i=0; i<numSearches; i+=1) {\r\n        deltaOffset *= 0.5;\r\n        deltaHeight *= 0.5;\r\n        float fCurrSampledHeight = texture2D(tHeightMap, uv + vCurrOffset).r;\r\n        if (fCurrSampledHeight > fCurrRayHeight) {\r\n          // below the surface\r\n          vCurrOffset -= deltaOffset;\r\n          fCurrRayHeight += deltaHeight;\r\n        } else {\r\n          // above the surface\r\n          vCurrOffset += deltaOffset;\r\n          fCurrRayHeight -= deltaHeight;\r\n        }\r\n      }\r\n      break;\r\n    } else {\r\n      fCurrRayHeight -= fStepSize;\r\n      vCurrOffset += fStepSize * vMaxOffset;\r\n    }\r\n  }\r\n\r\n  uv += vCurrOffset;",reliefMapFragPars:"uniform float parallaxScale;\r\nuniform sampler2D tHeightMap;",reliefMapUniforms:{parallaxScale:{value:.03},tHeightMap:{value:null}},rimLightFrag:"  float rim = 1.0 - saturate(dot(geometry.normal, geometry.viewDir));\r\n  float LE = pow(max(dot(-geometry.viewDir, directLight.direction), 0.0), 30.0);\r\n  reflectedLight.directSpecular += rimLightColor * rim * LE * rimLightCoef;",rimLightFragPars:"uniform vec3 rimLightColor;\r\nuniform float rimLightCoef;",rimLightUniforms:{rimLightColor:{value:new r.Color},rimLightCoef:{value:1}},roughnessFrag:"  float roughnessFactor = max(0.04, roughness);",roughnessMapFrag:"  vec4 roughnessRGBA = texture2D(tRoughness, uv);\r\n  roughnessFactor *= roughnessRGBA.r;",roughnessMapFragPars:"uniform sampler2D tRoughness;",roughnessMapUniforms:{tRoughness:{value:null}},screenVert:"  vScreenPos = hpos;",screenVertPars:"varying vec4 vScreenPos;",skyDomeFrag:"  float h = normalize(vWorldPosition + offset).y;\r\n  reflectedLight.indirectDiffuse += mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0));",skyDomeFragPars:"uniform vec3 topColor;\r\nuniform vec3 bottomColor;\r\nuniform float offset;\r\nuniform float exponent;",skyDomeUniforms:{topColor:{value:new r.Color(30719)},bottomColor:{value:new r.Color(16777215)},offset:{value:33},exponent:{value:.6}},skyFrag:'  // https://github.com/SimonWallner/kocmoc-demo/blob/RTVIS/media/shaders/scattering.glsl\r\n\r\n  float sunfade = 1.0 - clamp(1.0 - exp((skySunPosition.y / 450000.0)), 0.0, 1.0);\r\n  // luminance = 1.0; // vPos.y / 450000.0 + 0.5; // skySunPosition.y / 450000.0 * 1.0 + 0.5\r\n  // reflectedLight.indirectDiffuse += vec3(sunfade);",\r\n\r\n  float rayleighCoefficient = skyRayleigh - (1.0 * (1.0 - sunfade));\r\n\r\n  vec3 sunDirection = normalize(skySunPosition);\r\n\r\n  float sunE = sunIntensity(dot(sunDirection, up));\r\n\r\n  // extinction (absorbition + out scattering)\r\n  // rayleigh coefiiceneints\r\n  // vec3 betaR = totalRayleigh(lambda) * reyleighCoefficient;\r\n  vec3 betaR = simplifiedRayleigh() * rayleighCoefficient;\r\n\r\n  // mie coefficients\r\n  vec3 betaM = totalMie(lambda, K, skyTurbidity) * skyMieCoefficient;\r\n\r\n  // optical length\r\n  // cutoff angle at 90 to avoid singularity in next formula\r\n  float zenithAngle = acos(max(0.0, dot(up, -geometry.viewDir)));\r\n  float sR = rayleighZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / pi), -1.253));\r\n  float sM = mieZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / pi), -1.253));\r\n\r\n  // combined extinction factor\r\n  vec3 Fex = exp(-(betaR * sR + betaM * sM));\r\n\r\n  // in scattering\r\n\r\n  float cosTheta = dot(-geometry.viewDir, sunDirection);\r\n\r\n  // float rPhase = rayleighPhase(cosTheta);\r\n  float rPhase = rayleighPhase(cosTheta * 0.5 + 0.5);\r\n  vec3 betaRTheta = betaR * rPhase;\r\n\r\n  float mPhase = hgPhase(cosTheta, skyMieDirectionalG);\r\n  vec3 betaMTheta = betaM * mPhase;\r\n\r\n  // vec3 Lin = sunE * ((betaRTheta + betaMTheta) / (betaR + betaM)) * (1.0 - Fex);\r\n  vec3 Lin = pow(sunE * ((betaRTheta + betaMTheta) / (betaR + betaM)) * (1.0 - Fex), vec3(1.5));\r\n  Lin *= mix(vec3(1.0), pow(sunE * ((betaRTheta + betaMTheta) / (betaR + betaM)) * Fex, vec3(0.5)), clamp(pow(1.0 - dot(up, sunDirection), 5.0), 0.0, 1.0));\r\n\r\n  // nightsky\r\n  // float theta = acos(-geometry.viewDir.y); // elevation --\x3e y-axis [-pi/2, pi/2]\r\n  // float phi = atan(-geometry.viewDir.z, -geometry.viewDir.x); // azimuth ---\x3e x-axis [-pi/2, pi/2]\r\n  // vec2 uv = vec2(phi, theta) / vec2(2.0*pi, pi) + vec2(0.5, 0.0);\r\n  // vec3 L0 = texture2D(tSky, uv).rgb * Fex;\r\n  // vec3 L0 = texture2D(tSky, uv).rgb + 0.1 * Fex;\r\n  vec3 L0 = vec3(0.1) * Fex;\r\n\r\n  // composition + solar disc\r\n  // if (cosTheta > sunAngularDiameterCos) {\r\n  //   L0 += sunE * Fex;\r\n  // }\r\n  float sundisk = smoothstep(sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta);\r\n  // "if (-geometry.viewDir.y > 0.0) {\r\n  L0 += (sunE * 19000.0 * Fex) * sundisk;\r\n\r\n  // vec3 whiteScale = 1.0 / Uncharted2ToneMapping(vec3(W));\r\n  vec3 whiteScale = 1.0 / Uncharted2Tonemap(vec3(W));\r\n  // vec3 whiteScale = Uncharted2Tonemap(vec3(toneMappingWhitePoint));\r\n\r\n  vec3 texColor = (Lin + L0);\r\n  texColor *= 0.04;\r\n  texColor += vec3(0.0, 0.001, 0.0025) * 0.3;\r\n\r\n  float g_fMaxLuminance = 1.0;\r\n  float fLumScaled = 0.1 / skyLuminance;\r\n  float fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (g_fMaxLuminance * g_fMaxLuminance)))) / (1.0 + fLumScaled);\r\n\r\n  float ExposureBias = fLumCompressed;\r\n\r\n//   vec3 curr = Uncharted2ToneMapping((log2(2.0 / pow(skyLuminance, 4.0))) * texColor);\r\n  vec3 curr = Uncharted2Tonemap((log2(2.0 / pow(skyLuminance, 4.0))) * texColor * vec3(toneMappingExposure));\r\n  vec3 color = curr * whiteScale;\r\n\r\n  reflectedLight.indirectDiffuse += pow(color, vec3(1.0 / (1.2 + (1.2 * sunfade))));\r\n  // reflectedLight.indirectDiffuse += vec3(uv.x, uv.y, 0.0);\r\n  // reflectedLight.indirectDiffuse += Lin + L0;\r\n  // reflectedLight.indirectDiffuse += texColor;\r\n  // reflectedLight.indirectDiffuse += L0;\r\n  // reflectedLight.indirectDiffuse += Lin;\r\n  // reflectedLight.indirectDiffuse += vec3(cosTheta);\r\n  // reflectedLight.indirectDiffuse += vec3(sundisk);\r\n  // reflectedLight.indirectDiffuse += vec3(max(dot(sunDirection, up), 0.0));\r\n  // reflectedLight.indirectDiffuse += vec3(sunE);\r\n',skyFragPars:"// https://github.com/SimonWallner/kocmoc-demo/blob/RTVIS/media/shaders/scattering.glsl\r\n\r\n// uniform sampler2D tSky;\r\nuniform float skyLuminance;\r\nuniform float skyTurbidity;\r\nuniform float skyRayleigh;\r\nuniform float skyMieCoefficient;\r\nuniform float skyMieDirectionalG;\r\nuniform vec3 skySunPosition;\r\n\r\n// constants for atmospheric scattering\r\nconst float e = 2.71828182845904523536028747135266249775724709369995957;\r\nconst float pi = 3.141592653589793238462643383279502884197169;\r\nconst float n = 1.0003; // refractive index of air\r\nconst float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)\r\nconst float pn = 0.035; // depolatization factor for standard air\r\n\r\n// wavelength of used primaries, according to preetham\r\nconst vec3 lambda = vec3(680E-9, 550E-9, 450E-9);\r\n\r\n// mie stuff\r\n// K koefficient for the primaries\r\nconst vec3 K = vec3(0.686, 0.678, 0.666);\r\nconst float v = 4.0;\r\n\r\n// optical length at zenith for molecules\r\nconst float rayleighZenithLength = 8.4E3;\r\nconst float mieZenithLength = 1.25E3;\r\nconst vec3 up = vec3(0.0, 1.0, 0.0);\r\n\r\nconst float EE = 1000.0; \r\nconst float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324; // 66 arc seconds -> degrees, and the cosine of that\r\n\r\n// earth shadow hack\r\nconst float cutoffAngle = pi / 1.95;\r\nconst float steepness = 1.5;\r\n\r\n// Compute total rayleigh coefficient for a set of wavelengths (usually the tree primaries)\r\n// @param lambda wavelength in m\r\nvec3 totalRayleigh(vec3 lambda) {\r\n  return (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn));\r\n}\r\n\r\n// see http://blenderartists.org/forum/showthread.php?321110-Shaders-and-Skybox-madness\r\n// A simplied version of the total Rayleigh scattering to works on browsers that use ANGLE\r\nvec3 simplifiedRayleigh() {\r\n  return 0.0005 / vec3(94, 40, 18);\r\n//   return 0.0054532832366 / (3.0 * 2.545E25 * pow(lambda, vec3(4.0)) * 6.245);\r\n}\r\n\r\n// Reileight phase function as a function of cos(theta)\r\nfloat rayleighPhase(float cosTheta) {\r\n// NOTE: there are a few scale factors for the phase function\r\n// (1) as give bei Preetheam, normalized over the sphere with 4pi sr\r\n// (2) normalized to intergral = 1\r\n// (3) nasa: integrates to 9pi / 4, looks best\r\n  return (3.0 / (16.0 * pi)) * (1.0 + pow(cosTheta, 2.0));\r\n//   return (1.0 / (3.0 * pi)) * (1.0 + pow(cosTheta, 2.0));\r\n//   return (3.0 / 4.0) * (1.0 + pow(cosTheta, 2.0));\r\n}\r\n\r\n// total mie scattering coefficient\r\n// @param labmda set of wavelengths in m\r\n// @param K corresponding scattering param\r\n// @param T turbidity, somewhere in the range of 0 to 20\r\nvec3 totalMie(vec3 lambda, vec3 K, float T) {\r\n// not the formula given py Preetham\r\n  float c = (0.2 * T) * 10E-18;\r\n  return 0.434 * c * pi * pow((2.0 * pi) / lambda, vec3(v - 2.0)) * K;\r\n}\r\n\r\n// Henyey-Greenstein approximataion as a function of cos(theta)\r\n// @param cosTheta\r\n// @param g geometric constant that defines the shape of the ellipse\r\nfloat hgPhase(float cosTheta, float g) {\r\n  return (1.0 / (4.0 * pi)) * ((1.0 - pow(g, 2.0)) / pow(1.0 - 2.0 * g * cosTheta + pow(g, 2.0), 1.5));\r\n}\r\n\r\nfloat sunIntensity(float zenithAngleCos) {\r\n// This function originally used 'exp(n)', but it returns an incorrect value\r\n// on Samsung S6 phones. So it has been replaced with the equivalent 'pow(e,n)'\r\n// See https://github.com/mrdoob/three.js/issues/8382\r\n  return EE * max(0.0, 1.0 - pow(e, -((cutoffAngle - acos(zenithAngleCos)) / steepness)));\r\n}\r\n\r\n// float logLuminance(vec3 c) {\r\n//   return log(c.r * 0.2126 + c.g * 0.7152 + c.b * 0.0722);\r\n// }\r\n\r\n// Filmic ToneMapping http://filmicgames.com/archives/75\",\r\nfloat A = 0.15;\r\nfloat B = 0.50;\r\nfloat C = 0.10;\r\nfloat D = 0.20;\r\nfloat E = 0.02;\r\nfloat F = 0.30;\r\nfloat W = 1000.0;\r\nvec3 Uncharted2Tonemap(vec3 x) {\r\n  return ((x*(A*x + C*B) + D*E) / (x*(A*x + B) + D*F)) - E/F;\r\n}",skyUniforms:{skyLuminance:{value:1},skyTurbidity:{value:2},skyRayleigh:{value:1},skyMieCoefficient:{value:.005},skyMieDirectionalG:{value:.8},skySunPosition:{value:new r.Vector3}},specularFrag:"  material.specularRoughness = specularStrength;",specularFragPars:"uniform float specularStrength;",specularMapFrag:"  material.specularRoughness = texture2D(tSpecular, vUv).r * specularStrength;",specularMapFragPars:"uniform sampler2D tSpecular;\r\nuniform float specularStrength;",specularMapUniforms:{tSpecular:{value:null},specularStrength:{value:1}},specularUniforms:{specularStrength:{value:1}},ssao2BlurFrag:"#define KERNEL_RADIUS 4\r\nuniform sampler2D tAO;\r\nuniform vec4 blurParams;\r\nvarying vec2 vUv;\r\n\r\nfloat CrossBilateralWeight(float r, float ddiff, inout float w_total) {\r\n  float w = exp(-r*r*blurParams.z) * (ddiff < blurParams.w ? 1.0 : 0.0);\r\n  w_total += w;\r\n  return w;\r\n}\r\n\r\n// Performs a gaussian blur in one direction\r\nvec2 Blur(vec2 texScale) {\r\n  vec2 centerCoord = vUv;\r\n  float w_total = 1.0;\r\n  vec2 aoDepth = texture2D(tAO, centerCoord).xy;\r\n  float totalAo = aoDepth.x;\r\n  float centerZ = aoDepth.y;\r\n  // [unroll]\r\n  for (int i=-KERNEL_RADIUS; i<KERNEL_RADIUS; i++) {\r\n    vec2 texCoord = centerCoord + (float(i)*texScale);\r\n    vec2 sampleAoZ = texture2D(tAO, texCoord).xy;\r\n    float diff = abs(sampleAoZ.y - centerZ);\r\n    float weight = CrossBilateralWeight(float(i), diff, w_total);\r\n    totalAo += sampleAoZ.x * weight;\r\n  }\r\n  \r\n  return vec2(totalAo / w_total, centerZ);\r\n}\r\n\r\nvoid main() {\r\n  gl_FragColor = vec4(Blur(vec2(blurParams.x, blurParams.y)), 0.0, 1.0);\r\n}",ssao2BlurUniforms:{tAO:{value:null},blurParams:{value:new r.Vector4}},ssao2CompositeFrag:"uniform sampler2D tDiffuse;\r\nuniform sampler2D tAO;\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n  vec4 colorRGBA = texture2D(tDiffuse, vUv);\r\n  vec4 aoRGBA = texture2D(tAO, vUv);\r\n  colorRGBA.rgb *= pow(aoRGBA.r, 2.0);\r\n  gl_FragColor = vec4(colorRGBA.rgb, 1.0);\r\n  // gl_FragColor = vec4(vec3(aoRGBA.r), 1.0);\r\n}",ssao2CompositeUniforms:{tDiffuse:{value:null},tAO:{value:null}},ssao2Frag:"#define PI 3.14159265359\r\n#define SAMPLE_FIRST_STEP 1\r\n#define NUM_STEPS 4\r\n#define MAX_STEPS 16\r\n#define NUM_DIRECTIONS 8\r\nuniform sampler2D tDiffuse;\r\nuniform sampler2D tDepth;\r\nuniform vec4 radiusParams;\r\nuniform vec4 biasParams;\r\nuniform vec4 screenParams;\r\nuniform vec4 uvToViewParams;\r\nuniform vec4 focalParams;\r\nuniform vec2 cameraParams;\r\nvarying vec2 vUv;\r\n\r\n#ifndef saturate\r\n#define saturate( a ) clamp( a, 0.0, 1.0 )\r\n#endif\r\n\r\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\r\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\r\n// highp float rand(const in vec2 uv) {\r\n//   const highp float a = 12.9898, b = 78.233, c = 43758.5453;\r\n//   highp float dt = dot(uv.xy, vec2(a,b)), sn = mod(dt, PI);\r\n//   return fract(sin(sn) * c);\r\n// }\r\n// Value Noise by Inigo Quilez - iq/2013\r\n// https://www.shadertoy.com/view/lsf3WH\r\nvec2 rand(vec2 p) {\r\n  p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\r\n  return -1.0 + 2.0 * fract(sin(p)*43758.5453123);\r\n}\r\n\r\n// vec2 round(vec2 a) {\r\n//   return floor(a + 0.5);\r\n// }\r\n\r\nfloat rsqrt(float a) {\r\n  return inversesqrt(a);\r\n}\r\n\r\nconst vec3 PackFactors = vec3(255.0, 65025.0, 16581375.0);\r\nconst vec4 UnpackFactors = vec4(1.0, 1.0 / PackFactors);\r\nconst float ShiftRight8 = 1.0 / 255.0;\r\nfloat unpackRGBAToDepth(vec4 rgba) {\r\n  return dot(rgba, UnpackFactors);\r\n}\r\n\r\nfloat viewZToOrthographicDepth(const in float viewZ, const in float near, const in float far) {\r\n  return (viewZ + near) / (near - far);\r\n}\r\n\r\nfloat perspectiveDepthToViewZ(const in float invClipZ, const in float near, const in float far) {\r\n  return (near * far) / ((far - near) * invClipZ - far);\r\n}\r\n\r\nvec3 uvToView(vec2 uv, float eye_z) {\r\n  uv = uvToViewParams.xy * uv + uvToViewParams.zw;\r\n  return vec3(uv * eye_z, eye_z);\r\n}\r\n\r\nvec3 viewPos(vec2 uv) {\r\n  float depth = texture2D(tDepth, uv).x;\r\n  float viewZ = -perspectiveDepthToViewZ(depth, cameraParams.x, cameraParams.y);\r\n  return uvToView(uv, viewZ);\r\n}\r\n\r\nfloat getLengthSqr(vec3 v) {\r\n  return dot(v,v);\r\n}\r\n\r\nvec3 minOfDiff(vec3 P, vec3 Pr, vec3 Pl) {\r\n  vec3 v1 = Pr - P;\r\n  vec3 v2 = P - Pl;\r\n  return (getLengthSqr(v1) < getLengthSqr(v2)) ? v1 : v2;\r\n}\r\n\r\nfloat falloffFactor(float d2) {\r\n  return d2 * radiusParams.z + 1.0;\r\n}\r\n\r\nvec2 snapUVOffset(vec2 uv) {\r\n  return round(uv * screenParams.xy) * screenParams.zw;\r\n}\r\n\r\nfloat TanToSin(float x) {\r\n  return x * rsqrt(x*x + 1.0);\r\n}\r\n\r\nfloat getTangent(vec3 T) {\r\n  return -T.z * rsqrt(dot(T.xy,T.xy));\r\n}\r\n\r\nfloat integerateOcclusion(\r\n  vec2 uv0,\r\n  vec2 snapped_duv,\r\n  vec3 P,\r\n  vec3 dPdu,\r\n  vec3 dPdv,\r\n  inout float tanH)\r\n{\r\n  float ao = 0.0;\r\n  \r\n  // Compute a tangent vector for snapped_duv\r\n  vec3 tangVec = snapped_duv.x * dPdu + snapped_duv.y * dPdv;\r\n  float invTanLen = rsqrt(dot(tangVec.xy,tangVec.xy));\r\n  float tanT = -tangVec.z * invTanLen;\r\n  tanT += biasParams.y;\r\n  \r\n  float sinT = TanToSin(tanT);\r\n  vec3 S = viewPos(uv0 + snapped_duv);\r\n  vec3 diff = S - P;\r\n  float tanS = getTangent(diff);\r\n  float sinS = TanToSin(tanS);\r\n  float d2 = getLengthSqr(diff);\r\n  \r\n  if ((d2 < radiusParams.y) && (tanS > tanT)) {\r\n    // Compute AO between the tangent plane and the sample\r\n    ao = falloffFactor(d2) * saturate(sinS - sinT);\r\n    \r\n    // Update the horizon angle\r\n    tanH = max(tanH, tanS);\r\n  }\r\n  \r\n  return ao;\r\n}\r\n\r\nfloat calculateHorizonOcclusion(\r\n  vec2 dUv, vec2 texelDeltaUV, vec2 uv0, vec3 P, float numSteps,\r\n  float randstep, vec3 dPdu, vec3 dPdv)\r\n{\r\n  float ao = 0.0;\r\n  \r\n  vec2 uv = uv0 + snapUVOffset(randstep * dUv);\r\n  vec2 deltaUV = snapUVOffset(dUv);\r\n  vec3 T = deltaUV.x * dPdu + deltaUV.y * dPdv;\r\n  \r\n  float invTanLen = rsqrt(dot(T.xy,T.xy));\r\n  float tanH = -T.z * invTanLen;\r\n  tanH += biasParams.y;\r\n  \r\n#if SAMPLE_FIRST_STEP\r\n// Take a first sample between uv0 and uv0 + deltaUV\r\nvec2 snapped_duv = snapUVOffset(randstep * deltaUV + texelDeltaUV);\r\nao = integerateOcclusion(uv0, snapped_duv, P, dPdu, dPdv, tanH);\r\n--numSteps;\r\n#endif\r\n\r\n  float sinH = TanToSin(tanH);\r\n  for (int j=1; j<MAX_STEPS; ++j) {\r\n    if (float(j) >= numSteps) {\r\n      break;\r\n    }\r\n    uv += deltaUV;\r\n    vec3 S = viewPos(uv);\r\n    vec3 diff = S - P;\r\n    float tanS = getTangent(diff);\r\n    float d2 = getLengthSqr(diff);\r\n    \r\n    // Use a merged dynamic branch\r\n    //[branch]\r\n    if ((d2 < radiusParams.y) && (tanS > tanH)) {\r\n      // Accumulate AO betrween the horizon and the sample\r\n      float sinS = TanToSin(tanS);\r\n      ao += falloffFactor(d2) * saturate(sinS - sinH);\r\n      \r\n      // Update the current horizon angle\r\n      tanH = tanS;\r\n      sinH = sinS;\r\n    }\r\n  }\r\n  \r\n  return ao;\r\n}\r\n\r\nvec2 rotateDirections(vec2 Dir, vec2 CosSin) {\r\n  return vec2(Dir.x*CosSin.x - Dir.y*CosSin.y, Dir.x*CosSin.y+Dir.y*CosSin.x);\r\n}\r\n\r\nvec3 randCosSinJitter(vec2 uv) {\r\n  vec2 r = rand(uv);\r\n\tfloat angle = 2.0 * PI * r.x / float(NUM_DIRECTIONS);\r\n  return vec3(cos(angle), sin(angle), r.y);\r\n}\r\n\r\nvoid calculateNumSteps(inout vec2 stepSizeInUV, inout float numSteps, float radiusInPixels, float rand) {\r\n  // Avoid oversampling if NUM_STEPS is greater than the kerenl radius in pixels\r\n  numSteps = min(float(NUM_STEPS), radiusInPixels);\r\n  \r\n  // Divide by Ns+1 so taht the farthest samples are not fully attenuated\r\n  float stepSizeInPixels = radiusInPixels / (numSteps+1.0);\r\n  \r\n  // Clamp numSteps if it is greater than the max kernel footprint\r\n  float maxNumSteps = radiusParams.w / stepSizeInPixels;\r\n  if (maxNumSteps < numSteps) {\r\n    // Use dithering to avoid AO discontinuities\r\n    numSteps = floor(maxNumSteps + rand);\r\n    numSteps = max(numSteps, 1.0);\r\n    stepSizeInPixels = radiusParams.w / numSteps;\r\n  }\r\n  \r\n  // Step size in uv space\r\n  stepSizeInUV = stepSizeInPixels * screenParams.zw;\r\n}\r\n\r\nvoid main() {\r\n  \r\n  vec2 uv = vUv;\r\n  // vec2 uv = vec2(0.5,0.5);\r\n  vec2 scr = vUv*screenParams.xy;\r\n  \r\n  vec3 posCenter = viewPos(uv);\r\n  \r\n  // (cos(alpha), sin(alpha), jitter)\r\n  vec3 rand = randCosSinJitter(uv);\r\n  // vec3 rand = randCosSinJitter(vUv*2.0-1.0);\r\n  // vec3 rand = randomTexture.Sample(PointWrapSampler, IN.position.xy / RANDOM_TEXTURE_WIDTH);\r\n  \r\n  // Compute projection of disk of radius g_R into uv space\r\n  // Multiply by 0.5 to scale from [-1,1]^2 to [0,1]^2\r\n  vec2 diskRadiusInUV = 0.5 * radiusParams.x * focalParams.xy / posCenter.z;\r\n  float radiusInPixels = diskRadiusInUV.x * screenParams.x;\r\n  if (radiusInPixels < 1.0) {\r\n    gl_FragColor = vec4(vec3(1.0), 1.0);\r\n    return;\r\n  }\r\n  \r\n  // vec3 rand = randomTexture.Load(int3(IN.position.xy,0) & 63);\r\n  //calculateNumSteps(stepSize, numSteps, radiusInPixels, rand.z);\r\n  \r\n  // Nearest neighbor pixels on the tangent plane\r\n  vec3 posRight  = viewPos(uv + vec2(screenParams.z, 0));\r\n  vec3 posLeft   = viewPos(uv + vec2(-screenParams.z, 0));\r\n  vec3 posTop    = viewPos(uv + vec2(0, screenParams.w));\r\n  vec3 posBottom = viewPos(uv + vec2(0,-screenParams.w));\r\n  \r\n  // Screen-aligned basis for the tangent plane\r\n  vec3 dPdu = minOfDiff(posCenter, posRight, posLeft);\r\n  vec3 dPdv = minOfDiff(posCenter, posTop, posBottom) * (screenParams.y * screenParams.z);\r\n  \r\n  float ao = 0.0;\r\n  float alpha = 2.0 * PI / float(NUM_DIRECTIONS);\r\n  //vec3 rand;\r\n  float numSteps;\r\n  vec2 stepSize;\r\n  for (int d=0; d<NUM_DIRECTIONS; ++d) {\r\n    //rand = randomTexture.Sample(PointWrapSampler, IN.uv * 100);\r\n    //rand = randomTexture.Load(int3(IN.position.xy + int2(d*5, d*17),0) & 31);\r\n    float angle = alpha * float(d);\r\n    \r\n    calculateNumSteps(stepSize, numSteps, radiusInPixels, rand.z);\r\n    vec2 dir = rotateDirections(vec2(cos(angle), sin(angle)), rand.xy);\r\n    vec2 deltaUV = dir * stepSize.xy;\r\n    vec2 texelDeltaUV = dir * screenParams.zw;\r\n    ao += calculateHorizonOcclusion(deltaUV, texelDeltaUV, uv, posCenter, numSteps, rand.z, dPdu, dPdv);\r\n    \r\n    // vec2 snapped_duv = snapUVOffset(deltaUV);\r\n    // vec2 snapped_uv = snapUVOffset(rand.z * snapped_duv + texelDeltaUV);\r\n    // vec2 snapped_scr = (uv + snapped_uv) * screenParams.xy;\r\n    // vec2 snapped_scr = (uv + snapped_uv) * screenParams.xy;\r\n    // vec2 snapped_scr = uv * screenParams.xy;\r\n    // if (snapped_scr.x >= scr.x && snapped_scr.x <= scr.x+1.0 && snapped_scr.y >= scr.y && snapped_scr.y <= scr.y+1.0) {\r\n    //   gl_FragColor = vec4(1.0,0.0,0.0,1.0);\r\n    //   return;\r\n    // }\r\n  }\r\n  \r\n  ao = 1.0 - ao / float(NUM_DIRECTIONS) * biasParams.z;\r\n  gl_FragColor = vec4(saturate(ao), posCenter.z, 0.0, 1.0);\r\n  // gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\r\n  // gl_FragColor = vec4(normalize(posCenter)*0.5+0.5, 1.0);\r\n  // gl_FragColor = vec4(vec3(saturate(ao)), 1.0);\r\n}\r\n  ",ssao2Uniforms:{tDiffuse:{value:null},tDepth:{value:null},angleBias:{value:40},radius:{value:4.5},maxRadius:{value:.5},strength:{value:10},radiusParams:{value:new r.Vector4},biasParams:{value:new r.Vector4},screenParams:{value:new r.Vector4},uvToViewParams:{value:new r.Vector4},focalParams:{value:new r.Vector4},cameraParams:{value:new r.Vector2}},ssaoFrag:"uniform float cameraNear;\r\nuniform float cameraFar;\r\nuniform bool onlyAO; // use only ambient occulusion pass?\r\nuniform vec2 size; // texture width, height\r\nuniform float aoClamp; // depth clamp - reduces haloing at screen edges\r\nuniform float lumInfluence;  // how much luminance affects occulusion\r\nuniform float radius; // ao radius\r\nuniform float diffArea; // self-shadowing reduction\r\nuniform float gDisplace; // gause bell center\r\nuniform sampler2D tDiffuse;\r\nuniform sampler2D tDepth;\r\nvarying vec2 vUv;\r\n\r\n// #define PI 3.14159265\r\n#define DL 2.399963229728653 // PI * (3.0 - sqrt(5.0))\r\n#define EULER 2.718281828459045\r\n\r\n// user variables\r\nconst int samples = 8; // ao sample count\r\n// const float radius = 5.0; // ao radius\r\nconst bool useNoise = false; // use noise instead of pattern for sample dithering\r\nconst float noiseAmount = 0.0003; // dithering amount\r\n// const float diffArea = 0.4; // self-shadowing reduction\r\n// const float gDisplace = 0.4; // gause bell center\r\n\r\n// generating noise / pattern texture for dithering\r\nvec2 rand(const vec2 coord) {\r\n  vec2 noise;\r\n  if (useNoise) {\r\n    float nx = dot(coord, vec2(12.9898, 78.233));\r\n    float ny = dot(coord, vec2(12.9898, 78.233) * 2.0);\r\n    noise = clamp(fract(43758.5453 * sin(vec2(nx, ny))), 0.0, 1.0);\r\n  } else {\r\n    float ff = fract(1.0 - coord.s * (size.x / 2.0));\r\n    float gg = fract(coord.t * (size.y / 2.0));\r\n    noise = vec2(0.25, 0.75) * vec2(ff) + vec2(0.75, 0.25) * gg;\r\n  }\r\n\r\n  return (noise * 2.0 - 1.0) * noiseAmount;\r\n}\r\n\r\nfloat readDepth(const in vec2 coord) {\r\n  float zfarPlusNear = cameraFar + cameraNear;\r\n  float zfarMinusNear = cameraFar - cameraNear;\r\n  float zcoef = 2.0 * cameraNear;\r\n\r\n//   return (2.0 * cameraNear) / (cameraFar + cameraNear - unpackDepth(texture2D(tDepth, coord)) * (cameraFar - cameraNear));\r\n  // return zcoef / (zfarPlusNear - unpackRGBAToDepth(texture2D(tDepth, coord)) * zfarMinusNear);\r\n  return zcoef / (zfarPlusNear - texture2D(tDepth, coord).r * zfarMinusNear);\r\n}\r\n\r\nfloat compareDepths(const in float depth1, const in float depth2, inout int far) {\r\n  float garea = 2.0; // gauss ball width\r\n  float diff = (depth1 - depth2) * 100.0; // depth difference (0-100)\r\n\r\n// reduce left bell width to avoid self-shadowing\r\n\r\n  if (diff < gDisplace) {\r\n    garea = diffArea;\r\n  } else {\r\n    far = 1;\r\n  }\r\n\r\n  float dd = diff - gDisplace;\r\n  float gauss = pow(EULER, -2.0 * dd * dd / (garea * garea));\r\n  return gauss;\r\n}\r\n\r\nfloat calcAO(float depth, float dw, float dh) {\r\n  float dd = radius - depth * radius;\r\n  vec2 vv = vec2(dw, dh);\r\n\r\n  vec2 coord1 = vUv + dd * vv;\r\n  vec2 coord2 = vUv - dd * vv;\r\n\r\n  float temp1 = 0.0;\r\n  float temp2 = 0.0;\r\n\r\n  int far = 0;\r\n  temp1 = compareDepths(depth, readDepth(coord1), far);\r\n\r\n// DEPTH EXTRAPOLATION\r\n\r\n  if (far > 0) {\r\n    temp2 = compareDepths(readDepth(coord2), depth, far);\r\n    temp1 += (1.0 - temp1) * temp2;\r\n  }\r\n\r\n  return temp1;\r\n}\r\n\r\nvoid main() {\r\n  vec2 noise = rand(vUv);\r\n  float depth = readDepth(vUv);\r\n  float tt = clamp(depth, aoClamp, 1.0);\r\n  float w = (1.0 / size.x) / tt + (noise.x * (1.0 - noise.x));\r\n  float h = (1.0 / size.y) / tt + (noise.y * (1.0 - noise.y));\r\n\r\n  float ao = 0.0;\r\n\r\n  float dz = 1.0 / float(samples);\r\n  float z = 1.0 - dz / 2.0;\r\n  float l = 0.0;\r\n\r\n  for (int i=0; i<=samples; i++) {\r\n    float r = sqrt(1.0 - z);\r\n    float pw = cos(l) * r;\r\n    float ph = sin(l) * r;\r\n    ao += calcAO(depth, pw * w, ph * h);\r\n    z = z - dz;\r\n    l = l + DL;\r\n  }\r\n\r\n  ao /= float(samples);\r\n  ao = 1.0 - ao;\r\n\r\n  vec3 color = texture2D(tDiffuse, vUv).rgb;\r\n\r\n  vec3 lumcoeff = vec3(0.299, 0.587, 0.114);\r\n  float lum = dot(color.rgb, lumcoeff);\r\n  vec3 luminance = vec3(lum);\r\n\r\n  vec3 final = vec3(color * mix(vec3(ao), vec3(1.0), luminance * lumInfluence)); // mix(color * ao, white, luminance)\r\n  if (onlyAO) {\r\n    final = vec3(mix(vec3(ao), vec3(1.0), luminance * lumInfluence));\r\n  }\r\n\r\n  gl_FragColor = vec4(final, 1.0);\r\n}",ssaoUniforms:{tDiffuse:{value:null},tDepth:{value:null},size:{value:new r.Vector2(512,512)},cameraNear:{value:1},cameraFar:{value:100},onlyAO:{value:0},aoClamp:{value:.5},lumInfluence:{value:.5},radius:{value:5},diffArea:{value:.4},gDisplace:{value:.4}},ssaoVert:"varying vec2 vUv;\r\nvoid main() {\r\n  vUv = uv;\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}",standardAreaLightFrag:"void computeAreaLight(const in AreaLight areaLight, const in GeometricContext geometry, const in Material material, inout ReflectedLight reflectedLight) {\r\n  vec3 L = areaLight.position - geometry.position;\r\n  float Ld = length(L);\r\n\r\n  if (areaLight.distance == 0.0 || Ld < areaLight.distance) {\r\n    \r\n    vec3 Ln = normalize(L);\r\n  \r\n    vec3 N = geometry.normal;\r\n    vec3 V = geometry.viewDir;\r\n  \r\n    vec3 r = reflect(-V,N);\r\n    vec3 centerToRay = dot(L,r)*r - L;\r\n    vec3 closestPoint = L + centerToRay * clamp(areaLight.radius / length(centerToRay), 0.0, 1.0);\r\n    Ln = normalize(closestPoint);\r\n    \r\n    float NoL = saturate(dot(N, Ln));\r\n    float NoV = saturate(dot(N, V));\r\n    vec3 H = normalize(Ln+V);\r\n    float NoH = saturate(dot(N, H));\r\n    float VoH = saturate(dot(V, H));\r\n    float LoV = saturate(dot(Ln, V));\r\n    float a = pow2(material.specularRoughness);\r\n    \r\n    float Lc = pow(saturate(-Ld / areaLight.distance + 1.0), areaLight.decay);\r\n    float alphaPrime = clamp(areaLight.distance / (Ld*2.0) + a, 0.0, 1.0);\r\n    float D = D_GGX_AreaLight(a, alphaPrime, NoH);\r\n    float G = PBR_Specular_G(material.specularRoughness, NoV, NoL, NoH, VoH, LoV);\r\n    vec3 F = PBR_Specular_F(material.specularColor, V, H) / (4.0 * NoL * NoV + 1e-5);\r\n    \r\n    vec3 cdiff = DiffuseLambert(material.diffuseColor);\r\n    vec3 cspec = F*(G*D);\r\n    \r\n    vec3 irradiance = areaLight.color * NoL * Lc;\r\n    irradiance *= PI; // punctual light\r\n    \r\n    reflectedLight.directDiffuse += irradiance * cdiff;\r\n    reflectedLight.directSpecular += irradiance * cspec;\r\n  }\r\n}",standardDisneyFrag:'  vec3 X = vTangent;\r\n  vec3 Y = vBinormal;\r\n  float NoL = saturate(dot(N, L));\r\n  float NoV = saturate(dot(N, V));\r\n  vec3 H = normalize(L+V);\r\n  float NoH = saturate(dot(N, H));\r\n  float VoH = saturate(dot(V, H));\r\n  float LoV = saturate(dot(L, V));\r\n  float LoH = saturate(dot(L, H));\r\n  float a = max(0.001, pow2(material.specularRoughness));\r\n        \r\n  float luminance = 0.3 * material.diffuseColor.x + 0.6 * material.diffuseColor.y + 0.1 * material.diffuseColor.z;\r\n        \r\n  vec3 tint = luminance > 0.0 ? material.diffuseColor / luminance : vec3(1.0);\r\n  specularColor = mix(0.5 * 0.08 * mix(vec3(1.0), tint, SpecularTint), material.diffuseColor, Metallic);\r\n  vec3 CSheen = mix(vec3(1.0), tint, SheenTint);\r\n        \r\n  // Diffuse fresnel - go from 1 at normal incidence to .5 at grazing\r\n  // and mxi in diffuse retro-reflection based on roughness\r\n  float FL = F_Schlick_Disney(NoL);\r\n  float FV = F_Schlick_Disney(NoV);\r\n  float Fd90 = 0.5 + 2.0 * LoH * LoH * a;\r\n  float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);\r\n        \r\n  // Based on Hanrahan-Krueger brdf approximation of isotropic bssrdf\r\n  // 1.25 scale is used to (roughly) preserve albedo\r\n  // Fss90 used to "flatten" retroreflection based on roughness\r\n  float Fss90 = LoH * LoH * a;\r\n  float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);\r\n  float ss = 1.25 * (Fss * (1.0 / (NoL + NoV + 1e-5) - 0.5) + 0.5);\r\n        \r\n  // Specular\r\n  float aspect = sqrt(1.0 - Anisotropic * 0.9);\r\n  float ax = max(0.001, pow2(a) / aspect);\r\n  float ay = max(0.001, pow2(a) * aspect);\r\n  float Ds = GTR2_aniso(NoH, dot(H, X), dot(H, Y), ax, ay);\r\n  float FH = F_Schlick_Disney(LoH);\r\n  vec3 Fs = mix(specularColor, vec3(1.0), FH);\r\n  float roughg = pow2(a * 0.5 + 0.5);\r\n  float Gs = smithG_GGX(NoL , roughg) * smithG_GGX(NoV, roughg);\r\n        \r\n  // Sheen\r\n  vec3 Fsheen = FH * Sheen * CSheen;\r\n        \r\n  // Clearcoat (ior = 1.5 -> F0 = 0.04)\r\n  float Dr = GTR1(NoH, mix(0.1, 0.001, ClearcoatGloss));\r\n  float Fr = mix(0.04, 1.0, FH);\r\n  float Gr = smithG_GGX(NoL, 0.25) * smithG_GGX(NoV, 0.25);\r\n  diffuse = ((1.0 / PI) * mix(Fd, ss, Subsurface) * material.diffuseColor + Fsheen) * (1.0 - Metallic);\r\n  reflectedLight.directDiffuse += (diffuse + Gs*Fs*Ds + 0.25*Clearcoat*Gr*Fr*Dr) * NoL * Lc;\r\n  reflectedLight.directSpecular += (0.25*Clearcoat*Gr*Fr*Dr) * NoL * Lc;',standardDisneyFragPars:"uniform float Subsurface;\r\nuniform float SpecularTint;\r\nuniform float Anisotropic;\r\nuniform float Sheen;\r\nuniform float SheenTint;\r\nuniform float Clearcoat;\r\nuniform float ClearcoatGloss;\r\nfloat Metallic;",standardFrag:"  vec3 N = geometry.normal;\r\n  vec3 L = directLight.direction;\r\n  vec3 V = geometry.viewDir;\r\n\r\n  float NoL = saturate(dot(N, L));\r\n  float NoV = saturate(dot(N, V));\r\n  vec3 H = normalize(L+V);\r\n  float NoH = saturate(dot(N, H));\r\n  float VoH = saturate(dot(V, H));\r\n  float LoV = saturate(dot(L, V));\r\n          \r\n  float a = pow2(material.specularRoughness);\r\n\r\n  vec3 cdiff = DiffuseLambert(material.diffuseColor);\r\n  vec3 cspec = PBR_Specular_CookTorrance(material.specularColor, H, V, L, a, NoL, NoV, NoH, VoH, LoV);\r\n\r\n  vec3 irradiance = directLight.color * NoL;\r\n  irradiance *= PI; // punctual light\r\n\r\n  reflectedLight.directDiffuse += cdiff * irradiance;\r\n  reflectedLight.directSpecular += cspec * irradiance;",standardFragPars:"uniform float roughness;\r\nuniform float metalness;\r\n\r\nfloat PBR_Specular_D(float a, float NoH) {\r\n  // return D_BlinnPhong(a, NoH);\r\n  // return D_Beckmann(a, NoH);\r\n  return D_GGX(a, NoH);\r\n}\r\n\r\nfloat PBR_Specular_G(float a, float NoV, float NoL, float NoH, float VoH, float LoV) {\r\n  // return G_Implicit(a, NoV, NoL);\r\n  // return G_Neuman(a, NoV, NoL);\r\n  // return G_CookTorrance(a, NoV, NoL, NoH, VoH);\r\n  // return G_Keleman(a, NoV, NoL, LoV);\r\n  // return G_Smith_Beckmann(a, NoV, NoL);\r\n  // return G_Smith_GGX(a, NoV, NoL);\r\n  return G_Smith_Schlick_GGX(a, NoV, NoL);\r\n  // return G_SmithCorrelated_GGX(a, NoV, NoL);\r\n}\r\n\r\nvec3 PBR_Specular_F(vec3 specularColor, vec3 H, vec3 V) {\r\n  // return F_None(specularColor);\r\n  // return F_Schlick(specularColor, H, V);\r\n  return F_SchlickApprox(specularColor, saturate(dot(H,V)));\r\n  // return F_CookTorrance(specularColor, H, V);\r\n}\r\n\r\n// Calculates specular intensity according to the Cook - Torrance model\r\n// F: Fresnel - 入射角に対する反射光の量\r\n// D: Microfacet Distribution - 与えられた方向に向いているマイクロファセットの割合\r\n// G: Geometrical Attenuation - マイクロファセットの自己シャドウ\r\nvec3 PBR_Specular_CookTorrance(vec3 specularColor, vec3 H, vec3 V, vec3 L, float a, float NoL, float NoV, float NoH, float VoH, float LoV) {\r\n  float D = PBR_Specular_D(a, NoH);\r\n  float G = PBR_Specular_G(a, NoV, NoL, NoH, VoH, LoV);\r\n  vec3 F = PBR_Specular_F(specularColor, V, H) / (4.0 * NoL * NoV + 1e-5);\r\n  return F * (D*G);\r\n}\r\n",standardOrenNayarFrag:"vec3 N = geometry.normal;\r\nvec3 L = directLight.direction;\r\nvec3 V = geometry.viewDir;\r\n\r\nfloat NoL = saturate(dot(N, L));\r\nfloat NoV = saturate(dot(N, V));\r\nvec3 H = normalize(L+V);\r\nfloat NoH = saturate(dot(N, H));\r\nfloat VoH = saturate(dot(V, H));\r\nfloat LoV = saturate(dot(L, V));\r\n        \r\nfloat a = pow2(material.specularRoughness);\r\n\r\nvec3 cdiff = DiffuseOrenNayar(material.diffuseColor, NoV, NoL, LoV, material.specularRoughness);\r\nvec3 cspec = PBR_Specular_CookTorrance(material.specularColor, H, V, L, a, NoL, NoV, NoH, VoH, LoV);\r\n\r\nvec3 irradiance = directLight.color * NoL;\r\nirradiance *= PI; // punctual light\r\n\r\nreflectedLight.directDiffuse += cdiff * directLight.color * PI;\r\nreflectedLight.directSpecular += cspec * irradiance;",standardRectLightFrag:"//------------------------------------------------------------\r\n// Real-time Collision Detection\r\nvec3 closestPointPToRay(in vec3 p, in vec3 start, in vec3 dir) {\r\n  float t = max(dot(p-start, dir) / dot(dir,dir), 0.0);\r\n  return start + dir*t;\r\n}\r\nvec3 closestPointPToSegment(in vec3 p, in vec3 a, in vec3 b) {\r\n  vec3 ab = b-a;\r\n  float t = dot(p-a,ab);\r\n  if (t <= 0.0) {\r\n    return a;\r\n  }\r\n  else {\r\n    float denom = dot(ab,ab);\r\n    if (t >= denom) {\r\n      return b;\r\n    }\r\n    \r\n    return a + ab*(t/denom);\r\n  }\r\n  // vec3 ab = b-a;\r\n  // float t = clamp(dot(p-a, ab) / dot(ab,ab), 0.0, 1.0);\r\n  // return a + ab*t;\r\n}\r\n\r\nvec3 closestPointPToTriangle(in vec3 p, in vec3 a, in vec3 b, in vec3 c) {\r\n  // Check if P in vertex region outside A\r\n  vec3 ap = p-a;\r\n  vec3 ab = b-a;\r\n  vec3 ac = c-a;\r\n  float d1 = dot(ab,ap);\r\n  float d2 = dot(ac,ap);\r\n  if (d1 <= 0.0 && d2 <= 0.0) {\r\n    return a; // voronoi=0. barycentric coordinates (1,0,0)\r\n  }\r\n  \r\n  vec3 bp = p-b;\r\n  \r\n  // Check if P in vertex region outside B\r\n  float d3 = dot(ab,bp);\r\n  float d4 = dot(ac,bp);\r\n  if (d3 >= 0.0 && d4 <= d3) {\r\n    return b; // voronoi=1. barycentric coordinates (0,1,0)\r\n  }\r\n  \r\n  // Check if P in edge region of AB,k if so return projection of P onto AB\r\n  float vc = d1*d4 - d3*d2;\r\n  if (vc <= 0.0 && d1 >= 0.0 && d3 <= 0.0) {\r\n    // float v = d1/(d1-d3)\r\n    return a + ab * (d1/(d1-d3)); // voronoi=2. barycentric coordinates (1-v,v,0)\r\n  }\r\n  \r\n  // Check if P in vertex region outside C\r\n  vec3 cp = p-c;\r\n  float d5 = dot(ab, cp);\r\n  float d6 = dot(ac, cp);\r\n  if (d6 >= 0.0 && d5 <= d6) {\r\n    return c; // voronoi=3. barycentric coordinates (0,0,1)\r\n  }\r\n  \r\n  // Check if P in edge region of AC, if so return projection of P onto AC\r\n  float vb = d5*d2 - d1*d6;\r\n  if (vb <= 0.0 && d2 >= 0.0 && d6 <= 0.0) {\r\n    // float w = d2/(d2-d6)\r\n    return a + ac * (d2/(d2-d6)); // voronoi=4. barycentric cooridnates (1-w,w,0)\r\n  }\r\n  \r\n  // Check if P in edge region of BC, if so return projection of P onto BC\r\n  float va = d3*d6 - d5*d4;\r\n  if (va <= 0.0 && (d4-d3) >= 0.0 && (d5-d6) >= 0.0) {\r\n    // float w = (d4-d3)/(d4-d3+d5-d6)\r\n    return b + (c-b) * ((d4-d3)/(d4-d3+d5-d6)); // voronoi=5. barycentric coordinates (0,1-w,w)\r\n  }\r\n  \r\n  // P inside face region. Compute Q through its barycentric coordinates (u,v,w)\r\n  float denom = 1.0 / (va+vb+vc);\r\n  float v = vb * denom;\r\n  float w = vc * denom;\r\n  return a + ab*v + ac*w; // voronoi=6\r\n}\r\n\r\nint pointInTriangle(in vec3 p, in vec3 a, in vec3 b, in vec3 c) {\r\n  a -= p;\r\n  b -= p;\r\n  c -= p;\r\n  float ab = dot(a,b);\r\n  float ac = dot(a,c);\r\n  float bc = dot(b,c);\r\n  float cc = dot(c,c);\r\n  if (bc*ac - cc*ab < 0.0) return 0;\r\n  float bb = dot(b,b);\r\n  if (ab*bc - ac*bb < 0.0) return 0;\r\n  return 1;\r\n}\r\n//--------------------------------------------------\r\nvec3 Specular_AreaLight(vec3 specularColor, vec3 N, float roughnessFactor, vec3 L, vec3 Lc, vec3 V) {\r\n  // Compute some useful values\r\n  float NoL = saturate(dot(N, L));\r\n  float NoV = saturate(dot(N, V));\r\n  vec3 H = normalize(L+V);\r\n  float NoH = saturate(dot(N, H));\r\n  float VoH = saturate(dot(V, H));\r\n  float LoV = saturate(dot(L, V));\r\n  \r\n  float a = pow2(roughnessFactor);\r\n  \r\n  vec3 cspec = PBR_Specular_CookTorrance(specularColor, H, V, L, a, NoL, NoV, NoH, VoH, LoV);\r\n  return Lc * NoL * cspec;\r\n}\r\n//--------------------------------------------------\r\nvoid computeRectLight_Triangle(const in RectLight rectLight, const in GeometricContext geometry, const in Material material, inout ReflectedLight reflectedLight) {\r\n  \r\n  vec4 lpos[3];\r\n  vec3 lvec[3];\r\n  \r\n  // direction vectors from point to area light corners\r\n  for (int i=0; i<3; ++i) {\r\n    // lpos[i] = lightMatrixWorld * vec4(rectLight.positions[i], 1.0); // in world space\r\n    lpos[i] = vec4(rectLight.positions[i], 1.0); // in camera space\r\n    lvec[i] = normalize(lpos[i].xyz - geometry.position); // dir from vertex to area light\r\n  }\r\n  \r\n  // bail if the point is on the wrong side of the light... there must be a better way...\r\n  float tmp = dot(lvec[0], cross((lpos[2]-lpos[0]).xyz, (lpos[1]-lpos[0]).xyz));\r\n  if (tmp > 0.0) return;\r\n  \r\n  // vector irradiance at point\r\n  vec3 lightVec = vec3(0.0);\r\n  for (int i=0; i<3; ++i) {\r\n    vec3 v0 = lvec[i];\r\n    vec3 v1 = lvec[int(mod(float(i+1), float(3)))];\r\n    // if (tmp > 0.0) { // double side\r\n    //   lightVec += acos(dot(v0,v1)) * normalize(cross(v1,v0));\r\n    // }\r\n    // else {\r\n      lightVec += acos(dot(v0,v1)) * normalize(cross(v0,v1));\r\n    // }\r\n  }\r\n  \r\n  vec3 N = geometry.normal;\r\n  vec3 V = geometry.viewDir;\r\n  \r\n  // irradiance factor at point\r\n  float factor = max(dot(lightVec, N), 0.0) / (2.0 * PI);\r\n  \r\n  vec3 irradiance = rectLight.color * rectLight.intensity * factor;\r\n  irradiance *= PI; // punctual light\r\n  \r\n  \r\n  vec3 planePosition = (lpos[0].xyz + lpos[1].xyz + lpos[2].xyz) / 3.0;\r\n  vec3 planeNormal = rectLight.normal;\r\n  planeNormal = normalize(planeNormal - planePosition);\r\n  \r\n  // project onto plane and calculate direction from center to the projection\r\n  // vec3 projection = projectOnPlane(P, planePosition, planeNormal);\r\n  \r\n  // calculate distance from area\r\n  // vec3 nearestPointInside = closestPointPToTriangle(projection, lpos[0].xyz, lpos[1].xyz, lpos[2].xyz);\r\n  // float Ld = distance(P, nearestPointInside);\r\n  // if (cutoffDistance == 0.0 || Ld < cutoffDistance) {\r\n  //   float Lc = pow(saturate(-Ld / cutoffDistance + 1.0), 2.0);\r\n    // float Lc = pow(saturate(-Ld / cutoffDistance + 1.0), decayExponent);\r\n    float NoL = saturate(dot(N, lightVec));\r\n    reflectedLight.directDiffuse += irradiance * NoL * DiffuseLambert(material.diffuseColor);\r\n  // }\r\n  \r\n  /// SPECULAR\r\n  \r\n  // shoot a ray to calculate specular\r\n  vec3 R = reflect(-V, N);\r\n  vec3 E = linePlaneIntersect(geometry.position, -R, planePosition, planeNormal);\r\n  float specAngle = dot(-R, planeNormal);\r\n  if (specAngle > 0.0) {\r\n    \r\n    if (pointInTriangle(E, lpos[0].xyz, lpos[1].xyz, lpos[2].xyz) == 1) {\r\n      reflectedLight.directSpecular += Specular_AreaLight(material.specularColor, N, material.specularRoughness, R, irradiance * specAngle, V);\r\n    }\r\n    else {\r\n      vec3 nearestPointInside = closestPointPToTriangle(E, lpos[0].xyz, lpos[1].xyz, lpos[2].xyz);\r\n      float Ld = length(nearestPointInside-E);\r\n      \r\n      if (rectLight.distance == 0.0 || Ld < rectLight.distance) {\r\n        float Lc = pow(saturate(-Ld / rectLight.distance + 1.0), rectLight.decay);\r\n        reflectedLight.directSpecular += Specular_AreaLight(material.specularColor, N, material.specularRoughness, R, irradiance * Lc * specAngle, V);\r\n      }\r\n    }\r\n  }\r\n}\r\n//--------------------------------------------------\r\nvoid computeRectLight_Rectangle(const in RectLight rectLight, const in GeometricContext geometry, const in Material material, inout ReflectedLight reflectedLight) {\r\n  \r\n  vec4 lpos[4];\r\n  vec3 lvec[4];\r\n  \r\n  // direction vectors from point to area light corners\r\n  for (int i=0; i<4; ++i) {\r\n    // lpos[i] = lightMatrixWorld * vec4(lightverts[i], 1.0); // in world space\r\n    lpos[i] = vec4(rectLight.positions[i], 1.0); // in camera space\r\n    lvec[i] = normalize(lpos[i].xyz - geometry.position); // dir from vertex to area light\r\n  }\r\n  \r\n  // bail if the point is on the wrong side of the light... there must be a better way...\r\n  float tmp = dot(lvec[0], cross((lpos[2]-lpos[0]).xyz, (lpos[1]-lpos[0]).xyz));\r\n  if (tmp > 0.0) return;\r\n  \r\n  // vector irradiance at point\r\n  vec3 lightVec = vec3(0.0);\r\n  for (int i=0; i<4; ++i) {\r\n    vec3 v0 = lvec[i];\r\n    vec3 v1 = lvec[int(mod(float(i+1), 4.0))];\r\n    // if (tmp > 0.0) { // double side\r\n    //   lightVec += acos(dot(v0,v1)) * normalize(cross(v1,v0));\r\n    // }\r\n    // else {\r\n      lightVec += acos(dot(v0,v1)) * normalize(cross(v0,v1));\r\n    // }\r\n  }\r\n  \r\n  vec3 N = geometry.normal;\r\n  vec3 V = geometry.viewDir;\r\n  \r\n  // irradiance factor at point\r\n  float factor = max(dot(lightVec, N), 0.0) / (2.0 * PI);\r\n  \r\n  vec3 irradiance = rectLight.color * rectLight.intensity * factor;\r\n  irradiance *= PI; // punctual light\r\n  \r\n  vec3 planePosition = (lpos[0].xyz + lpos[1].xyz + lpos[2].xyz + lpos[3].xyz) / 4.0;\r\n  vec3 planeNormal = rectLight.normal;\r\n  vec3 right = rectLight.tangent;\r\n  planeNormal = normalize(planeNormal - planePosition);\r\n  right = normalize(right - planePosition);\r\n  vec3 up = normalize(cross(right, planeNormal));\r\n  \r\n  // project onto plane and calculate direction from center to the projection\r\n  // vec3 projection = projectOnPlane(P, planePosition, planeNormal);\r\n  // vec3 dir = projection - planePosition;\r\n  \r\n  // calculate distance from area\r\n  // vec2 diagonal = vec2(dot(dir,right), dot(dir,up));\r\n  // vec2 nearest2D = vec2(clamp(diagonal.x, -width, width), clamp(diagonal.y, -height, height));\r\n  // vec3 nearestPointInside = planePosition + (right*nearest2D.x + up*nearest2D.y);\r\n  \r\n  // float Ld = distance(P, nearestPointInside); // real distance to area rectangle\r\n  // if (cutoffDistance == 0.0 || Ld < cutoffDistance) {\r\n  //   float Lc = pow(saturate(-Ld / cutoffDistance + 1.0), 2.0);\r\n    float NoL = saturate(dot(N, lightVec));\r\n    reflectedLight.directDiffuse += irradiance * NoL * DiffuseLambert(material.diffuseColor);\r\n  // }\r\n  \r\n  // shoot a ray to calculate specular\r\n  vec3 R = reflect(-V, N);\r\n  vec3 E = linePlaneIntersect(geometry.position, -R, planePosition, planeNormal);\r\n  float specAngle = dot(-R, planeNormal);\r\n  if (specAngle > 0.0) {\r\n    vec3 dirSpec = E - planePosition;\r\n    vec2 dirSpec2D = vec2(dot(dirSpec,right), dot(dirSpec,up));\r\n    vec2 nearestSpec2D = vec2(clamp(dirSpec2D.x,-rectLight.width,rectLight.width), clamp(dirSpec2D.y,-rectLight.height,rectLight.height));\r\n    \r\n    float Ld = length(nearestSpec2D-dirSpec2D);\r\n    if (rectLight.distance == 0.0 || Ld < rectLight.distance) {\r\n      float Lc = pow(saturate(-Ld / rectLight.distance + 1.0), rectLight.decay);\r\n      reflectedLight.directSpecular += Specular_AreaLight(material.specularColor, N, material.specularRoughness, R, irradiance * Lc * specAngle, V);\r\n    }\r\n  }\r\n}\r\n//------------------------------------------------------------\r\nvoid computeRectLight(const in RectLight rectLight, const in GeometricContext geometry, const in Material material, inout ReflectedLight reflectedLight) {\r\n  \r\n  if (rectLight.numPositions <= 3) {\r\n    computeRectLight_Triangle(rectLight, geometry, material, reflectedLight);\r\n  }\r\n  else {\r\n    computeRectLight_Rectangle(rectLight, geometry, material, reflectedLight);\r\n  }\r\n}",standardTubeLightFrag:"void computeTubeLight(const in TubeLight tubeLight, const in GeometricContext geometry, const in Material material, inout ReflectedLight reflectedLight) {\r\n  \r\n  vec3 N = geometry.normal;\r\n  vec3 V = geometry.viewDir;\r\n  \r\n  vec3 r = reflect(-V, N);\r\n  vec3 L0 = tubeLight.start - geometry.position;\r\n  vec3 L1 = tubeLight.end - geometry.position;\r\n  float Ld0 = length(L0);\r\n  float Ld1 = length(L1);\r\n  float NoL0 = dot(L0, N) / (2.0 * Ld0);\r\n  float NoL1 = dot(L1, N) / (2.0 * Ld1);\r\n  float NoL = (2.0 * clamp(NoL0 + NoL1, 0.0, 1.0)) / (Ld0 * Ld1 + dot(L0,L1) + 2.0);\r\n  vec3 Lv = L1-L0;\r\n  float RoL0 = dot(r, L0);\r\n  float RoLv = dot(r, Lv);\r\n  float LoLv = dot(L0, Lv);\r\n  float Ld = length(Lv);\r\n  float t = (RoL0 * RoLv - LoLv) / (Ld*Ld - RoLv*RoLv);\r\n  \r\n  vec3 closestPoint = L0 + Lv * clamp(t, 0.0, 1.0);\r\n  vec3 centerToRay = dot(closestPoint, r) * r - closestPoint;\r\n  closestPoint = closestPoint + centerToRay * clamp(tubeLight.radius / length(centerToRay), 0.0, 1.0);\r\n  vec3 Ln = normalize(closestPoint);\r\n  \r\n  // float NoL = saturate(dot(N, Ln));\r\n  float NoV = saturate(dot(N, V));\r\n  vec3 H = normalize(Ln+V);\r\n  float NoH = saturate(dot(N, H));\r\n  float VoH = saturate(dot(V, H));\r\n  float LoV = saturate(dot(Ln, V));\r\n  float a = pow2(material.specularRoughness);\r\n  \r\n  Ld = length(closestPoint);\r\n  float Lc = pow(saturate(-Ld / tubeLight.distance + 1.0), tubeLight.decay);\r\n  float alphaPrime = clamp(tubeLight.radius / (Ld*2.0) + a, 0.0, 1.0);\r\n  float D = D_GGX_AreaLight(a, alphaPrime, NoH);\r\n  float G = PBR_Specular_G(material.specularRoughness, NoV, NoL, NoH, VoH, LoV);\r\n  vec3 F = PBR_Specular_F(material.specularColor, V, H) / (4.0 * NoL * NoV + 1e-5);\r\n  \r\n  vec3 cdiff = DiffuseLambert(material.diffuseColor);\r\n  vec3 cspec = F*(G*D);\r\n  \r\n  // vec3 irradiance = areaLight.color * NoL * Lc;\r\n  vec3 irradiance = tubeLight.color * Lc;\r\n  irradiance *= PI; // punctual light\r\n  \r\n  reflectedLight.directDiffuse += irradiance * cdiff;\r\n  reflectedLight.directSpecular += irradiance * cspec;\r\n}",standardUniforms:{roughness:{value:1},metalness:{value:0}},tangentFragPars:"varying vec3 vTangent;\r\nvarying vec3 vBinormal;",tangentVert:"  vNormal = normalize(normalMatrix * normal);\r\n  vTangent = normalize(normalMatrix * tangent.xyz);\r\n  vBinormal = normalize(cross(vNormal, vTangent) * tangent.w);",tangentVertPars:"attribute vec4 tangent;\r\nvarying vec3 vTangent;\r\nvarying vec3 vBinormal;",timePars:"uniform float time;",timeUniforms:{time:{value:0}},toneMapFrag:"uniform float exposure;\r\nuniform float whitePoint;\r\nuniform sampler2D tDiffuse;\r\n\r\n#ifndef saturate\r\n#define saturate( a ) clamp( a, 0.0, 1.0 )\r\n#endif\r\n\r\n// exposure only\r\nvec3 PixyLinearToneMapping(vec3 color) {\r\n  return exposure * color;\r\n}\r\n\r\n// source: https://www.cs.utah.edu/~reinhard/cdrom/\r\nvec3 PixyReinhardToneMapping(vec3 color) {\r\n  color *= exposure;\r\n  return saturate(color / (vec3(1.0) + color));\r\n}\r\n\r\n// source: http://filmicgames.com/archives/75\r\n#define PixyUncharted2Helper(x) max(((x * (0.15 * x + 0.10 * 0.50) + 0.20 * 0.02) / (x * (0.15 * x + 0.50) + 0.20 * 0.30)) - 0.02 / 0.30, vec3(0.0))\r\nvec3 PixyUncharted2ToneMapping(vec3 color) {\r\n// John Hable's filmic operator from Uncharted 2 video game\r\n  color *= exposure;\r\n  return saturate(PixyUncharted2Helper(color) / PixyUncharted2Helper(vec3(whitePoint)));\r\n}\r\n\r\n// source: http://filmicgames.com/archives/75\r\nvec3 PixyOptimizedCineonToneMapping(vec3 color) {\r\n// optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\r\n  color *= exposure;\r\n  color = max(vec3(0.0), color - 0.004);\r\n  return pow((color * (6.2 * color + 0.5)) / (color * (6.2 * color + 1.7) + 0.06), vec3(2.2));\r\n}\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n  vec4 colorRGBA = texture2D(tDiffuse, vUv);\r\n  gl_FragColor = vec4(PixyUncharted2ToneMapping(colorRGBA.rgb), 1.0);\r\n  \r\n}\r\n",toneMappingFrag:"  outgoingLight.rgb = toneMapping(outgoingLight.rgb);",toneMappingFragPars:'uniform float toneMappingExposure;\r\nuniform float toneMappingWhitePoint;\r\n// \r\n// // exposure only\r\n// vec3 LinearToneMapping(vec3 color) {\r\n//   return toneMappingExposure * color;\r\n// }\r\n// \r\n// // source: https://www.cs.utah.edu/~reinhard/cdrom/\r\n// vec3 ReinhardToneMapping(vec3 color) {\r\n//   color *= toneMappingExposure;\r\n//   return saturate(color / (vec3(1.0) + color));\r\n// }\r\n// \r\n// source: http://filmicgames.com/archives/75\r\n#define Uncharted2Helper(x) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\r\nvec3 Uncharted2ToneMapping(vec3 color) {\r\n// John Hable\'s filmic operator from Uncharted 2 video game\r\n  color *= toneMappingExposure;\r\n  return saturate(Uncharted2Helper(color) / Uncharted2Helper(vec3(toneMappingWhitePoint)));\r\n}\r\n// \r\n// // source: http://filmicgames.com/archives/75\r\n// vec3 OptimizedCineonToneMapping(vec3 color) {\r\n// // optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\r\n//   color *= toneMappingExposure;\r\n//   color = max(vec3(0.0), color - 0.004);\r\n//   return pow((color * (6.2 * color + 0.5)) / (color * (6.2 * color + 1.7) + 0.06), vec3(2.2));\r\n// "}"\r\n',toneMappingUniforms:{toneMappingExposure:{value:3},toneMappingWhitePoint:{value:5}},toneMapUniforms:{exposure:{value:3},whitePoint:{value:5},tDiffuse:{value:null}},toneMapVert:"varying vec2 vUv;\r\n\r\nvoid main() {\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n  vUv = uv;\r\n}",toonFrag:"  float NoL = dot(directLight.direction, geometry.normal);\r\n  vec3 H = normalize(geometry.viewDir + directLight.direction);\r\n  float HoN = max(dot(H, geometry.normal), 0.0);\r\n\r\n  vec2 toonUV = vec2(NoL * 0.495 + 0.5, 1.0 - (HoN * 0.98 + 0.01));\r\n  vec3 toonColor = texture2D(tToon, toonUV).rgb;\r\n  reflectedLight.directDiffuse += material.diffuseColor * directLight.color * toonColor;\r\n\r\n  // reflectedLight.directSpecular += material.specularStrength * directLight.color * toonColor;",toonFragPars:"uniform sampler2D tToon;",toonUniforms:{tToon:{value:null}},uvFrag:"  vec2 uv = vUv;",uvHemiSphericalFrag:"  vec3 wdir = normalize(vWorldPosition);\r\n  float theta = acos(wdir.y); // y-axis [0, pi]\r\n  float phi = atan(wdir.z, wdir.x); // x-axis [-pi/2, pi/2]\r\n  // uv = vec2(0.5, 1.0) - vec2(phi, theta * 2.0 - PI) / vec2(2.0*PI, PI);\r\n  uv = vec2(0.5 - phi / (2.0 * PI), 1.0 - theta * 2.0 / PI);",uvProjectionVert:"  vUv = hpos.xy / hpos.w;",uvScaleFrag:"  uv *= uvScale;",uvScaleFragPars:"uniform float uvScale;",uvScaleUniforms:{uvScale:{value:1}},uvScroll2Vert:"  vUv2 += fract(vec2(uvScrollSpeedU, uvScrollSpeedV) * uvScrollTime);",uvScrollUniforms:{uvScrollTime:{value:0},uvScrollSpeedU:{value:1},uvScrollSpeedV:{value:1}},uvScrollVert:"  vUv += fract(vec2(uvScrollSpeedU, uvScrollSpeedV) * uvScrollTime);",uvScrollVertPars:"uniform float uvScrollTime;\r\nuniform float uvScrollSpeedU;\r\nuniform float uvScrollSpeedV;",uvSphericalFrag:"  vec3 wdir = normalize(vWorldPosition);\r\n  float theta = acos(wdir.y); // y-axis [0, pi]\r\n  float phi = atan(wdir.z, wdir.x); // x-axis [-pi/2, pi/2]\r\n  uv = vec2(0.5, 1.0) - vec2(phi, theta) / vec2(2.0*PI, PI);",uvVert:"  vUv = uv;",uvVertFragPars:"varying vec2 vUv;",velvetFrag:"  // float NoL = max(dot(directLight.direction, geometry.normal), 0.0);\r\n  reflectedLight.directDiffuse += surfaceColor * directLight.color * NoL;\r\n\r\n  float subLamb = max(smoothstep(-rollOff, 1.0, NoL) - smoothstep(0.0, 1.0, NoL), 0.0);\r\n  reflectedLight.directDiffuse += subColor * subLamb * velvetStrength;\r\n\r\n  float VoN = 1.0 - dot(geometry.viewDir, geometry.normal);\r\n  reflectedLight.directSpecular += (vec3(VoN) * fuzzySpecColor) * velvetStrength;",velvetFragPars:"uniform vec3 surfaceColor;\r\nuniform vec3 fuzzySpecColor;\r\nuniform vec3 subColor;\r\nuniform float rollOff;\r\nuniform float velvetStrength;",velvetUniforms:{surfaceColor:{value:new r.Color},fuzzySpecColor:{value:new r.Color},subColor:{value:new r.Color},rollOff:{value:.3},velvetStrength:{value:.3}},viewFrag:"#include <packing>\r\nuniform sampler2D tDiffuse;\r\nuniform int type;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\nvarying vec2 vUv;\r\n\r\nfloat readDepth(sampler2D depthSampler, vec2 coord) {\r\n  float fragCoordZ = texture2D(depthSampler, coord).x;\r\n  float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\r\n  return viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);\r\n}\r\n\r\nvoid main() {\r\n  vec4 diffuse = texture2D(tDiffuse, vUv);\r\n  if (type == 0) {\r\n    gl_FragColor = vec4(diffuse.xyz, 1.0);\r\n  } else if (type == 1) {\r\n    gl_FragColor = vec4(diffuse.www, 1.0);\r\n  } else if (type == 2) {\r\n    gl_FragColor = vec4(diffuse.xxx, 1.0);\r\n  } else if (type == 3) {\r\n    gl_FragColor = vec4(diffuse.yyy, 1.0);\r\n  } else if (type == 4) {\r\n    gl_FragColor = vec4(diffuse.zzz, 1.0);\r\n  } else if (type == 5) {\r\n    gl_FragColor = vec4(diffuse.xyz*2.0-1.0, 1.0);\r\n  } else if (type == 6) {\r\n    float depth = unpackRGBAToDepth(diffuse);\r\n    gl_FragColor = vec4(depth, depth, depth, 1.0);\r\n  } else if (type == 7) {\r\n    float depth = readDepth(tDiffuse, vUv);\r\n    gl_FragColor = vec4(depth, depth, depth, 1.0);\r\n  } else {\r\n    gl_FragColor = diffuse;\r\n  }\r\n}",viewUniforms:{tDiffuse:{value:null},type:{value:0},cameraNear:{value:1},cameraFar:{value:100}},worldPositionVert:"  vWorldPosition = (modelMatrix * vec4(transformed, 1.0)).xyz;",worldPositionVertFragPars:"varying vec3 vWorldPosition;"};const t={UpdateShaderParameters(r,e,n){n.updateMatrixWorld(),n.matrixWorldInverse=n.matrixWorld.clone().invert();const t=n.matrixWorldInverse;r.isEnable(["AMBIENT","HEMISPHERE"])&&r.uniforms.skyDirection.value.set(e.skyDirectionX,e.skyDirectionY,e.skyDirectionZ).normalize().transformDirection(t);const o=r.enables.DIRECTLIGHT||0,a=r.enables.POINTLIGHT||0,i=r.enables.SPOTLIGHT||0;if(o>0)for(let n=0;n<o;++n)r.uniforms.directLights.value[n].direction.set(e.directLightX,e.directLightY,e.directLightZ).normalize().transformDirection(t);if(a>0)for(let n=0;n<a;++n)r.uniforms.pointLights.value[n].position.set(e.pointLightX,e.pointLightY,e.pointLightZ),r.uniforms.pointLights.value[n].position.applyMatrix4(t);if(i>0)for(let n=0;n<i;++n)r.uniforms.spotLights.value[n].position.set(e.spotLightX,e.spotLightY,e.spotLightZ),r.uniforms.spotLights.value[n].position.applyMatrix4(t),r.uniforms.spotLights.value[n].direction.copy(r.uniforms.spotLights.value[n].position).normalize()},GenerateShaderParametersGUI(r,n){const t=new e;let o,a={};void 0===n&&(n=function(r,e){});const i=function(e,t){r.uniforms[e].value=t,n(e,t)};if(o=t.addFolder("Base"),r.isEnable("SKYDOME")?(a.topColor=r.uniforms.topColor.value.getHex(),a.bottomColor=r.uniforms.bottomColor.value.getHex(),a.exponent=r.uniforms.exponent.value,o.addColor(a,"topColor").onChange((function(e){r.uniforms.topColor.value.setHex(e),n("topColor",e)})),o.addColor(a,"bottomColor").onChange((function(e){r.uniforms.bottomColor.value.setHex(e),n("bottomColor",e)})),o.add(a,"exponent",0,1).onChange((function(r){i("exponent",r)}))):(a.baseColor=r.uniforms.diffuseColor.value.getHex(),a.opacity=r.uniforms.opacity.value,o.addColor(a,"baseColor").onChange((function(e){r.uniforms.diffuseColor.value.setHex(e),n("baseColor",e)})),o.add(a,"opacity",0,1).onChange((function(r){i("opacity",r)}))),r.isEnable("STANDARD")&&(a.roughness=r.uniforms.roughness.value,a.metalness=r.uniforms.metalness.value,o.add(a,"roughness",0,1,.01).onChange((function(r){i("roughness",r)})),o.add(a,"metalness",0,1,.01).onChange((function(r){i("metalness",r)}))),r.isEnable(["+PHONG","+FRESNEL","+REFLECTION","+ANISOTROPY"])&&(o=t.addFolder("Specular"),r.isEnable("FRESNEL")&&(a.fresnelExponent=r.uniforms.fresnelExponent.value,a.fresnelReflectionScale=r.uniforms.fresnelReflectionScale.value,o.add(a,"fresnelExponent",0,5,.025).name("fresnel exponent").onChange((function(r){i("fresnelExponent",r)})),o.add(a,"fresnelReflectionScale",0,1,.025).name("fresnel scale").onChange((function(r){i("fresnelReflectionScale",r)}))),r.isEnable("REFLECTION")&&(a.reflectionStrength=r.uniforms.reflectionStrength.value,o.add(a,"reflectionStrength",0,1,.025).name("reflectionStrength").onChange((function(r){i("reflectionStrength",r)}))),r.isEnable("PHONG")&&(a.shininess=r.uniforms.shininess.value,o.add(a,"shininess",1,400,1).onChange((function(r){i("shininess",r)}))),r.isEnable(["+PHONG","+SPECULARMAP"])&&(a.specularStrength=r.uniforms.specularStrength.value,o.add(a,"specularStrength",0,1,.025).onChange((function(r){i("specularStrength",r)}))),r.isEnable("ANISOTROPY")&&(a.anisotropyExponent=r.uniforms.anisotropyExponent.value,a.anisotropyStrength=r.uniforms.anisotropyStrength.value,a.anisotropyFresnel=r.uniforms.anisotropyFresnel.value,a.anisotropyColor=r.uniforms.anisotropyColor.value.getHex(),o.add(a,"anisotropyExponent",0,5e3,1).onChange((function(r){i("anisotropyExponent",r)})),o.add(a,"anisotropyStrength",0,1,.025).onChange((function(r){i("anisotropyStrength",r)})),o.add(a,"anisotropyFresnel",0,1,.025).onChange((function(r){i("anisotropyFresnel",r)})),o.addColor(a,"anisotropyColor").onChange((function(e){r.uniforms.anisotropyColor.value.setHex(e),n("anisotropyColor",e)})))),r.isEnable("EMISSIVE")){o=t.addFolder("Emissive"),a.emissiveR=r.uniforms.emissiveColor.value.r,a.emissiveG=r.uniforms.emissiveColor.value.g,a.emissiveB=r.uniforms.emissiveColor.value.b;const e=function(e){r.uniforms.emissiveColor.value.setRGB(a.emissiveR,a.emissiveG,a.emissiveB),n("emissiveColor",r.uniforms.emissiveColor.value)};o.add(a,"emissiveR",0,5,.01).onChange(e),o.add(a,"emissiveG",0,5,.01).onChange(e),o.add(a,"emissiveB",0,5,.01).onChange(e)}if(r.isEnable(["+NORMALMAP","+BUMPMAP","+PARALLAXMAP"])&&(o=t.addFolder("Bump"),r.isEnable(["+NORMALMAP","+BUMPMAP"])&&(a.bumpiness=r.uniforms.bumpiness.value,o.add(a,"bumpiness",0,1,.01).onChange((function(r){i("bumpiness",r)}))),r.isEnable("PARALLAXMAP")&&(a.parallaxHeight=r.uniforms.parallaxHeight.value,a.parallaxScale=r.uniforms.parallaxScale.value,o.add(a,"parallaxHeight",-1,1,.025).onChange((function(r){i("parallaxHeight",r)})),o.add(a,"parallaxScale",-1,1,.025).onChange((function(r){i("parallaxScale",r)})))),r.isEnable(["+BUMPOFFSET","+PARALLAXOCCLUSIONMAP","+RELIEFMAP"])&&(o=t.addFolder("Parallax"),r.isEnable("BUMPOFFSET")&&(a.parallaxHeight=r.uniforms.parallaxHeight.value,o.add(a,"parallaxHeight",0,.5,.001).onChange((function(r){i("parallaxHeight",r)}))),r.isEnable(["+PARALLAXOCCLUSIONMAP","+RELIEFMAP"])&&(a.parallaxScale=r.uniforms.parallaxScale.value,o.add(a,"parallaxScale",0,.2,.001).onChange((function(r){i("parallaxScale",r)})))),r.isEnable("AOMAP")&&(o=t.addFolder("Ambient Occlusion"),a.aoStrength=r.uniforms.aoStrength.value,o.add(a,"aoStrength",0,1,.01).onChange((function(r){i("aoStrength",r)}))),r.isEnable("VELVET")&&(o=t.addFolder("Velvet"),a.surfaceColor=r.uniforms.surfaceColor.value.getHex(),a.fuzzySpecColor=r.uniforms.fuzzySpecColor.value.getHex(),a.subColor=r.uniforms.subColor.value.getHex(),a.rollOff=r.uniforms.rollOff.value,a.velvetStrength=r.uniforms.velvetStrength.value,o.addColor(a,"surfaceColor").onChange((function(e){r.unifomrs.surfaceColor.value.setHex(e),n("surfaceColor",e)})),o.addColor(a,"fuzzySpecColor").onChange((function(e){r.uniforms.fuzzySpecColor.value.setHex(e),n("fuzzySpecColor",e)})),o.addColor(a,"subColor").onChange((function(e){r.uniforms.subColor.value.setHex(e),n("subColor",e)})),o.add(a,"rollOff",0,1,.025).onChange((function(r){i("rollOff",r)})),o.add(a,"velvetStrength",0,1,.025).onChange((function(r){i("velvetStrength",r)}))),r.isEnable("INNERGLOW")&&(o=t.addFolder("InnerGlow"),a.innerGlowColor=r.uniforms.innerGlowColor.value.getHex(),a.innerGlowBase=r.uniforms.innerGlowBase.value,a.innerGlowSub=r.uniforms.innerGlowSub.value,a.innerGlowRange=r.uniforms.innerGlowRange.value,o.addColor(a,"innerGlowColor").onChange((function(e){r.uniforms.innerGlowColor.value.setHex(e),n("innerGlowColor",e)})),o.add(a,"innerGlowBase",0,128,.1).onChange((function(r){i("innerGlowBase",r)})),o.add(a,"innerGlowSub",0,10,.05).onChange((function(r){i("innerGlowSub",r)})),o.add(a,"innerGlowRange",0,1,.05).onChange((function(r){i("innerGlowRange",r)}))),r.isEnable("LINEGLOW")){o=t.addFolder("LineGlow"),a.lineGlowRange=r.uniforms.lineGlowRange.value,a.lineGlowPower=r.uniforms.lineGlowPower.value,a.lineGlowPlaneX=r.uniforms.lineGlowPlane.value.x,a.lineGlowPlaneY=r.uniforms.lineGlowPlane.value.y,a.lineGlowPlaneZ=r.uniforms.lineGlowPlane.value.z;const e=function(e){r.uniforms.lineGlowPlane.value.set(a.lineGlowPlaneX,a.lineGlowPlaneY,a.lineGlowPlaneZ,r.uniforms.lineGlowPlane.value.w),n("lienGlowPlane",r.uniforms.lineGlowPlane.value)};o.add(a,"lineGlowRange",0,5,.05).onChange((function(r){i("lineGlowRange",r)})),o.add(a,"lineGlowPower",0,10,.05).onChange((function(r){i("lineGlowPower",r)})),o.add(a,"lineGlowPlaneX",0,1,.05).onChange(e),o.add(a,"lineGlowPlaneY",0,1,.05).onChange(e),o.add(a,"lineGlowPlaneZ",0,1,.05).onChange(e)}r.isEnable("DISTORTION")&&(o=t.addFolder("Distortion"),a.distortionStrength=r.uniforms.distortionStrength.value,o.add(a,"distortionStrength",-5,5,.05).onChange((function(r){i("distortionStrength",r)}))),r.isEnable("UVSCROLL")&&(o=t.addFolder("UV Scroll"),a.uvScrollSpeedU=r.uniforms.uvScrollSpeedU.value,a.uvScrollSpeedV=r.uniforms.uvScrollSpeedV.value,o.add(a,"uvScrollSpeedU",-5,5,.01).onChange((function(r){i("uvScrollSpeedU",r)})),o.add(a,"uvScrollSpeedV",-5,5,.01).onChange((function(r){i("uvScrollSpeedV",r)}))),r.isEnable("GLASS")&&(o=t.addFolder("Glass"),a.glassStrength=r.uniforms.glassStrength.value,a.glassCurvature=r.uniforms.glassCurvature.value,o.add(a,"glassStrength",0,1,.01).onChange((function(r){i("glassStrength",r)})),o.add(a,"glassCurvature",0,2,.01).onChange((function(r){i("glassCurvature",r)}))),r.isEnable("AMBIENT")&&(o=t.addFolder("Ambient Light"),a.ambientColor=r.uniforms.ambientColor.value.getHex(),o.addColor(a,"ambientColor").onChange((function(e){r.uniforms.ambientColor.value.setHex(e),n("ambientColor",e)})),r.isEnable("HEMISPHERE")&&(a.skyDirectionX=r.uniforms.skyDirection.value.x,a.skyDirectionY=r.uniforms.skyDirection.value.y,a.skyDirectionZ=r.uniforms.skyDirection.value.z,a.groundColor=r.uniforms.groundColor.value.getHex(),o.add(a,"skyDirectionX",0,1,.025).onChange((function(r){n("skyDirectionX",r)})),o.add(a,"skyDirectionY",0,1,.025).onChange((function(r){n("skyDirectionY",r)})),o.add(a,"skyDirectionZ",0,1,.025).onChange((function(r){n("skyDirectionZ",r)})),o.addColor(a,"groundColor").onChange((function(e){r.uniforms.groundColor.value.setHex(e),n("groundColor",e)}))));const s=r.enables.DIRECTLIGHT||0,l=r.enables.POINTLIGHT||0,c=r.enables.SPOTLIGHT||0;if((s>0||l>0||c>0)&&(s>0&&(o=t.addFolder("Direct Light"),a.directLightX=r.uniforms.directLights.value[0].direction.x,a.directLightY=r.uniforms.directLights.value[0].direction.y,a.directLightZ=r.uniforms.directLights.value[0].direction.z,a.directLightColor=r.uniforms.directLights.value[0].color.getHex(),o.add(a,"directLightX",-1,1,.025).name("x").onChange((function(r){n("directLightX",r)})),o.add(a,"directLightY",-1,1,.025).name("y").onChange((function(r){n("directLightY",r)})),o.add(a,"directLightZ",-1,1,.025).name("z").onChange((function(r){n("directLightZ",r)})),o.addColor(a,"directLightColor").name("color").onChange((function(e){r.uniforms.directLights.value[0].color.setHex(e),n("directLightColor",e)}))),l>0&&(o=t.addFolder("Point Light"),a.pointLightX=r.uniforms.pointLights.value[0].position.x,a.pointLightY=r.uniforms.pointLights.value[0].position.y,a.pointLightZ=r.uniforms.pointLights.value[0].position.z,a.pointLightColor=r.uniforms.pointLights.value[0].color.getHex(),a.pointLightDistance=r.uniforms.pointLights.value[0].distance,a.pointLightDecay=r.uniforms.pointLights.value[0].decay,o.add(a,"pointLightX",-10,10,.025).name("x").onChange((function(r){n("pointLightX",r)})),o.add(a,"pointLightY",-10,10,.025).name("y").onChange((function(r){n("pointLightY",r)})),o.add(a,"pointLightZ",-10,10,.025).name("z").onChange((function(r){n("pointLightZ",r)})),o.addColor(a,"pointLightColor").name("color").onChange((function(e){r.uniforms.pointLights.value[0].color.setHex(e),n("pointLightColor",e)})),o.add(a,"pointLightDistance",0,100,1).onChange((function(e){r.uniforms.pointLights.value[0].distance=e,n("pointLightDistance",e)})),o.add(a,"pointLightDecay",0,10,.025).onChange((function(e){r.uniforms.pointLights.value[0].decay=e,n("pointLightDecay",e)}))),c>0&&(o=t.addFolder("Spot Light"),a.spotLightX=r.uniforms.spotLights.value[0].position.x,a.spotLightY=r.uniforms.spotLights.value[0].position.y,a.spotLightZ=r.uniforms.spotLights.value[0].position.z,a.spotLightColor=r.uniforms.spotLights.value[0].color.getHex(),a.spotLightDistance=r.uniforms.spotLights.value[0].distance,a.spotLightDecay=r.uniforms.spotLights.value[0].decay,a.spotLightAngle=r.uniforms.spotLights.value[0].coneCos,a.spotLightPenumbra=r.uniforms.spotLights.value[0].penumbraCos,o.add(a,"spotLightX",-10,10,.025).name("x").onChange((function(r){n("spotLightX",r)})),o.add(a,"spotLightY",-10,10,.025).name("y").onChange((function(r){n("spotLightY",r)})),o.add(a,"spotLightZ",-10,10,.025).name("z").onChange((function(r){n("spotLightZ",r)})),o.addColor(a,"spotLightColor").name("color").onChange((function(e){r.uniforms.spotLights.value[0].color.setHex(e),n("spotLightColor",e)})),o.add(a,"spotLightDistance",0,50,1).onChange((function(e){r.uniforms.spotLights.value[0].distance=e,n("spotLightDistance",e)})),o.add(a,"spotLightDecay",1,10,.025).onChange((function(e){r.uniforms.spotLights.value[0].decay=e,n("spotLightDecay",e)})),o.add(a,"spotLightAngle",1e-4,Math.PI/2,.025).onChange((function(e){r.uniforms.spotLights.value[0].coneCos=Math.cos(e),n("spotLightConeCos",e)})),o.add(a,"spotLightPenumbra",0,1,.025).onChange((function(e){r.uniforms.spotLights.value[0].penumbraCos=Math.cos(a.spotLightAngle*(1-e)),n("spotLightPenumbraCos",e)})))),r.isEnable("RIMLIGHT")&&(o=t.addFolder("Rim Light"),a.rimLightColor=r.uniforms.rimLightColor.value.getHex(),a.rimLightCoef=r.uniforms.rimLightCoef.value,o.addColor(a,"rimLightColor").onChange((function(e){r.uniforms.rimLightColor.value.setHex(e),n("rimLightColor",e)})),o.add(a,"rimLightCoef",0,1,.05).onChange((function(r){i("rimLightCoef",r)}))),r.isEnable("LIGHTMAP")&&(o=t.addFolder("Light Map"),a.lightMapPower=r.uniforms.lightMapPower.value,a.lightMapStrength=r.uniforms.lightMapStrength.value,o.add(a,"lightMapPower",0,10,.025).onChange((function(r){i("lightMapPower",r)})),o.add(a,"lightMapStrength",0,1,.025).onChange((function(r){i("lightMapStrength",r)}))),r.isEnable(["+FOG","+HEIGHTFOG"])&&(o=t.addFolder("Fog"),r.isEnable("FOG")&&(a.fogAlpha=r.uniforms.fogAlpha.value,a.fogFar=r.uniforms.fogFar.value,a.fogNear=r.uniforms.fogNear.value,a.fogColor=r.uniforms.fogColor.value.getHex(),o.add(a,"fogAlpha",0,1,.025).onChange((function(r){i("fogAlpha",r)})),o.add(a,"fogFar",0,100,.1).onChange((function(r){i("fogFar",r)})),o.add(a,"fogNear",0,100,.1).onChange((function(r){i("fogNear",r)})),o.addColor(a,"fogColor").onChange((function(e){r.uniforms.fogColor.value.setHex(e),n("fogColor",e)}))),r.isEnable("HEIGHTFOG")&&(a.heightFogAlpha=r.uniforms.heightFogAlpha.value,a.heightFogFar=r.uniforms.heightFogFar.value,a.heightFogNear=r.uniforms.heightFogNear.value,a.heightFogColor=r.uniforms.heightFogColor.value.getHex(),o.add(a,"heightFogAlpha",0,1,.025).onChange((function(r){i("heightFogAlpha",r)})),o.add(a,"heightFogFar",0,100,.1).onChange((function(r){i("heightFogFar",r)})),o.add(a,"heightFogNear",0,100,.1).onChange((function(r){i("heightFogNear",r)})),o.addColor(a,"heightFogColor").onChange((function(e){r.uniforms.heightFogColor.value.setHex(e),n("heightFogColor",e)})))),r.isEnable("DISPLACEMENT")&&(o=t.addFolder("Displacement"),a.displacementScale=r.uniforms.displacementScale.value,a.displacementBias=r.uniforms.displacementBias.value,o.add(a,"displacementScale",0,10,.025).onChange((function(r){i("displacementScale",r)})),o.add(a,"displacementBias",0,10,.025).onChange((function(r){i("displacementBias",r)}))),r.isEnable("SKY")&&(o=t.addFolder("Sky"),a.skyTurbidity=r.uniforms.skyTurbidity.value,a.skyRayleigh=r.uniforms.skyRayleigh.value,a.skyMieCoefficient=r.uniforms.skyMieCoefficient.value,a.skyMieDirectionalG=r.uniforms.skyMieDirectionalG.value,a.skyLuminance=r.uniforms.skyLuminance.value,o.add(a,"skyTurbidity",1,20,.1).onChange((function(r){i("skyTurbidity",r)})),o.add(a,"skyRayleigh",0,4,.001).onChange((function(r){i("skyRayleigh",r)})),o.add(a,"skyMieCoefficient",0,.1,.001).onChange((function(r){i("skyMieCoefficient",r)})),o.add(a,"skyMieDirectionalG",0,1,.001).onChange((function(r){i("skyMieDirectionalG",r)})),o.add(a,"skyLuminance",0,2,.1).onChange((function(r){i("skyLuminance",r)}))),r.isEnable("GRASS")){o=t.addFolder("Grass"),a.grassWindDirectionX=r.uniforms.grassWindDirection.value.x,a.grassWindDirectionY=r.uniforms.grassWindDirection.value.y,a.grassWindDirectionZ=r.uniforms.grassWindDirection.value.z,a.grassWindPower=r.uniforms.grassWindPower.value;var f=function(e){r.uniforms.grassWindDirection.value.set(a.grassWindDirectionX,a.grassWindDirectionY,a.grassWindDirectionZ),n("grassWindDirection",r.uniforms.grassWindDirection.value)};o.add(a,"grassWindDirectionX",0,1,.025).onChange(f),o.add(a,"grassWindDirectionY",0,1,.025).onChange(f),o.add(a,"grassWindDirectionZ",0,1,.025).onChange(f),o.add(a,"grassWindPower",0,2,.025).onChange((function(r){i("grassWindPower",r)}))}return r.isEnable("CLOUDS")&&(o=t.addFolder("Clouds"),a.cloudsScale=r.uniforms.cloudsScale.value,a.cloudsBrightness=r.uniforms.cloudsBrightness.value,o.add(a,"cloudsScale",0,1).onChange((function(r){i("cloudsScale",r)})),o.add(a,"cloudsBrightness",0,1).onChange((function(r){i("cloudsBrightness",r)}))),r.isEnable("GODRAY")&&(o=t.addFolder("GodRay"),a.godRayStrength=r.uniforms.godRayStrength.value,a.godRayIntensity=r.uniforms.godRayIntensity.value,a.godRaySunColor=r.uniforms.godRaySunColor.value.getHex(),a.godRayBgColor=r.uniforms.godRayBgColor.value.getHex(),o.add(a,"godRayStrength",0,1).onChange((function(r){i("godRayStrength",r)})),o.add(a,"godRayIntensity",0,2).onChange((function(r){i("godRayIntensity",r)})),o.addColor(a,"godRaySunColor").onChange((function(e){r.uniforms.godRaySunColor.value.setHex(e),n("godRaySunColor",e)})),o.addColor(a,"godRayBgColor").onChange((function(e){r.uniforms.godRayBgColor.value.setHex(e),n("godRayBgColor",e)}))),r.isEnable("RECEIVESHADOW")&&(o=t.addFolder("Shadow"),a.shadowBias=r.uniforms.shadowBias.value,a.shadowDensity=r.uniforms.shadowDensity.value,o.add(a,"shadowBias",0,1,.025).onChange((function(r){i("shadowBias",r)})),o.add(a,"shadowDensity",0,1,.025).onChange((function(r){i("shadowDensity",r)}))),(r.isEnable("TONEMAPPING")||r.isEnable("SKY"))&&(o=t.addFolder("ToneMapping",0,10),a.toneMappingExposure=r.uniforms.toneMappingExposure.value,a.toneMappingWhitePoint=r.uniforms.toneMappingWhitePoint.value,o.add(a,"toneMappingExposure",0,10).onChange((function(r){i("toneMappingExposure",r)})),o.add(a,"toneMappingWhitePoint",0,10).onChange((function(r){i("toneMappingWhitePoint",r)}))),{gui:t,parameters:a}}};class o{constructor(){this.position=new r.Vector3,this.color=new r.Color(16777215),this.distance=50,this.decay=1,this.radius=1}}class a{constructor(){this.start=new r.Vector3,this.end=new r.Vector3,this.color=new r.Color(16777215),this.distance=50,this.decay=1,this.radius=1}}class i{constructor(){this.positions=[],this.normal=new r.Vector3(0,0,1),this.tangent=new r.Vector3(1,0,0),this.color=new r.Color(16777215),this.intensity=1,this.width=1,this.height=1,this.distance=50,this.decay=1,this.matrix=new r.Matrix4,this.numPositions=4}}class s{constructor(){this.enables={},this.uniforms=[],this.material=null,this.debugCode=[]}enable(r,e){this.enables[r]=void 0===e?1:e}clear(){this.enables={}}setParameter(e,n){if(e in this.uniforms)if(this.uniforms[e].value instanceof r.Color)n instanceof r.Color?this.uniforms[e].value.copy(n):this.uniforms[e].value.copy(new r.Color(n));else if(this.uniforms[e].value instanceof r.Color||this.uniforms[e].value instanceof r.Vector2||this.uniforms[e].value instanceof r.Vector3||this.uniforms[e].value instanceof r.Vector4||this.uniforms[e].value instanceof r.Matrix3||this.uniforms[e].value instanceof r.Matrix4)this.uniforms[e].value.copy(n);else if(this.uniforms[e].value instanceof r.CubeTexture||this.uniforms[e].value instanceof r.Texture)this.uniforms[e].value=n;else if(this.uniforms[e].value instanceof Array)for(let r=0;r<n.length;++r)this.uniforms[e].value[r]=n[r];else this.uniforms[e].value=n}setParameters(r){for(let e in r)this.setParameter(e,r[e])}setArrayParameter(e,n,t,o){if(e in this.uniforms&&t in this.uniforms[e].value[n])if(this.uniforms[e].value[n][t]instanceof r.Color||this.uniforms[e].value[n][t]instanceof r.Vector2||this.uniforms[e].value[n][t]instanceof r.Vector3||this.uniforms[e].value[n][t]instanceof r.Vector4||this.uniforms[e].value[n][t]instanceof r.Matrix3||this.uniforms[e].value[n][t]instanceof r.Matrix4)this.uniforms[e].value[n][t].copy(o);else if(this.uniforms[e].value[n][t]instanceof r.CubeTexture||this.uniforms[e].value[n][t]instanceof r.Texture)this.uniforms[e].value[n][t]=o;else if(this.uniforms[e].value[n][t]instanceof Array)for(var a=0;a<o.length;++a)this.uniforms[e].value[n][t][a]=o[a];else this.uniforms[e].value[n][t]=o}setLightParameter(e,n,t){if(t.updateMatrixWorld(),t.matrixWorldInverse=t.matrixWorld.clone().invert(),n instanceof r.DirectionalLight){const r=n.position.clone().applyMatrix4(t.matrixWorldInverse),o=n.target.position.clone().applyMatrix4(t.matrixWorldInverse);r.sub(o).normalize(),this.setDirectLightParameter(e,r,n.color)}else if(n instanceof r.PointLight){const r=n.position.clone();r.applyMatrix4(t.matrixWorldInverse),this.setPointLightParameter(e,r,n.color,n.distance,n.decay)}else if(n instanceof r.SpotLight){const r=n.position.clone();r.applyMatrix4(t.matrixWorldInverse);const o=r.clone().normalize();this.setSpotLightParameter(e,r,o,n.color,n.distance,n.decay,Math.cos(n.angle),Math.cos(n.angle*(1-n.penumbra)))}else if(n instanceof r.AmbientLight)this.setParameter("ambientColor",n.color);else if(n instanceof o){const r=n.position.clone();r.applyMatrix4(t.matrixWorldInverse),this.setAreaLightParameter(e,r,n.color,n.distance,n.decay,n.radius)}else if(n instanceof a){const o=(new r.Vector3).copy(n.start);o.applyMatrix4(t.matrixWorldInverse);const a=(new r.Vector3).copy(n.end);a.applyMatrix4(t.matrixWorldInverse),this.setTubeLightParameter(e,o,a,n.color,n.distance,n.decay,n.radius)}else if(n instanceof i){const o=new r.Matrix4;o.copy(t.matrixWorldInverse),o.multiply(n.matrix);const a=[];for(let e=0;e<n.positions.length;++e){const t=(new r.Vector3).copy(n.positions[e]);t.applyMatrix4(o),a.push(t)}const i=new r.Vector3(0,0,1).applyMatrix4(o),s=new r.Vector3(1,0,0).applyMatrix4(o);this.setRectLightParameter(e,a,i,s,n.width,n.height,n.color,n.intensity,n.distance,n.decay)}}setDirectLightParameter(r,e,n){this.setArrayParameter("directLights",r,"direction",e),this.setArrayParameter("directLights",r,"color",n)}setPointLightParameter(r,e,n,t,o){this.setArrayParameter("pointLights",r,"position",e),this.setArrayParameter("pointLights",r,"color",n),this.setArrayParameter("pointLights",r,"distance",t),this.setArrayParameter("pointLights",r,"decay",o)}setSpotLightParameter(r,e,n,t,o,a,i,s){this.setArrayParameter("spotLights",r,"position",e),this.setArrayParameter("spotLights",r,"direction",n),this.setArrayParameter("spotLights",r,"color",t),this.setArrayParameter("spotLights",r,"distance",o),this.setArrayParameter("spotLights",r,"decay",a),this.setArrayParameter("spotLights",r,"coneCos",i),this.setArrayParameter("spotLights",r,"penumbraCos",s)}setAreaLightParameter(r,e,n,t,o,a){this.setArrayParameter("areaLights",r,"position",e),this.setArrayParameter("areaLights",r,"color",n),this.setArrayParameter("areaLights",r,"distance",t),this.setArrayParameter("areaLights",r,"decay",o),this.setArrayParameter("areaLights",r,"radius",a)}setTubeLightParameter(r,e,n,t,o,a,i){this.setArrayParameter("tubeLights",r,"start",e),this.setArrayParameter("tubeLights",r,"end",n),this.setArrayParameter("tubeLights",r,"color",t),this.setArrayParameter("tubeLights",r,"distance",o),this.setArrayParameter("tubeLights",r,"decay",a),this.setArrayParameter("tubeLights",r,"radius",i)}setRectLightParameter(r,e,n,t,o,a,i,s,l,c){this.setArrayParameter("rectLights",r,"numPositions",e.length);for(let n=0;n<e.length;++n)this.uniforms.rectLights.value[r].positions[n].copy(e[n]);this.setArrayParameter("rectLights",r,"normal",n),this.setArrayParameter("rectLights",r,"tangent",t),this.setArrayParameter("rectLights",r,"width",o),this.setArrayParameter("rectLights",r,"height",a),this.setArrayParameter("rectLights",r,"color",i),this.setArrayParameter("rectLights",r,"intensity",s),this.setArrayParameter("rectLights",r,"distance",l),this.setArrayParameter("rectLights",r,"decay",c)}isEnable(r){if(!r)return!0;if(r instanceof Array){if(0===r.length)return!0;let e=0;for(let n in r)if("-"===r[n][0]){if(this.isEnable(r[n].substr(1)))return!1}else if("+"===r[n][0])0===e&&(e=1),this.isEnable(r[n].substr(1))&&(e=2);else if(!1===this.isEnable(r[n]))return!1;return!(e>0&&e<2)}return r in this.enables}_addUniform(r,e,t){this.isEnable(e)&&r.push(n[t])}_generateUniforms(){const e=[];e.push({diffuseColor:{value:new r.Color},opacity:{value:1}});const t=this.enables.DIRECTLIGHT||0,o=this.enables.POINTLIGHT||0,a=this.enables.SPOTLIGHT||0;t>0&&e.push(n.lightsDirectUniforms),o>0&&e.push(n.lightsPointUniforms),a>0&&e.push(n.lightsSpotUniforms);const i=this.enables.AREALIGHT||0,s=this.enables.TUBELIGHT||0,l=this.enables.RECTLIGHT||0;return i>0&&e.push(n.lightsAreaLightUniforms),s>0&&e.push(n.lightsTubeLightUniforms),l>0&&e.push(n.lightsRectLightUniforms),this._addUniform(e,["AMBIENT"],"ambientUniforms"),this._addUniform(e,["AMBIENT","HEMISPHERE"],"ambientHemisphereUniforms"),this._addUniform(e,["PHONG"],"phongUniforms"),this._addUniform(e,["PHONG","SPECULARMAP"],"specularMapUniforms"),this._addUniform(e,["PHONG","-SPECULARMAP"],"specularUniforms"),this._addUniform(e,["STANDARD"],"standardUniforms"),this._addUniform(e,["ROUGHNESSMAP"],"roughnessMapUniforms"),this._addUniform(e,["METALNESSMAP"],"metalnessMapUniforms"),this._addUniform(e,["TOON"],"toonUniforms"),this._addUniform(e,["REFLECTION"],"reflectionUniforms"),this._addUniform(e,["REFLECTION","FRESNEL"],"fresnelUniforms"),this._addUniform(e,["VELVET"],"velvetUniforms"),this._addUniform(e,["INNERGLOW"],"innerGlowUniforms"),this._addUniform(e,["LINEGLOW"],"lineGlowUniforms"),this._addUniform(e,["RIMLIGHT"],"rimLightUniforms"),this._addUniform(e,["COLORMAP"],"colorMapUniforms"),this._addUniform(e,["NORMALMAP"],"normalMapUniforms"),this._addUniform(e,["BUMPMAP"],"bumpMapUniforms"),this._addUniform(e,["+BUMPOFFSET","+PARALLAXMAP"],"parallaxMapUniforms"),this._addUniform(e,["PARALLAXOCCLUSIONMAP"],"parallaxOcclusionMapUniforms"),this._addUniform(e,["RELIEFMAP"],"reliefMapUniforms"),this._addUniform(e,["DISTORTION"],"distortionUniforms"),this._addUniform(e,["+UVSCROLL","+UVSCROLL2"],"uvScrollUniforms"),this._addUniform(e,["UVSCALE"],"uvScaleUniforms"),this._addUniform(e,["GLASS"],"glassUniforms"),this._addUniform(e,["ANISOTROPY"],"anisotropyUniforms"),this._addUniform(e,["AOMAP"],"aoMapUniforms"),this._addUniform(e,["LIGHTMAP"],"lightMapUniforms"),this._addUniform(e,["BILLBOARD"],"billboardUniforms"),this._addUniform(e,["FOG"],"fogUniforms"),this._addUniform(e,["HEIGHTFOG"],"heightFogUniforms"),this._addUniform(e,["HEIGHTFOG","HEIGHTFOGMAP"],"heightFogMapUniforms"),this._addUniform(e,["PROJECTIONMAP"],"projectionMapUniforms"),this._addUniform(e,["DISPLACEMENTMAP"],"displacementMapUniforms"),this._addUniform(e,["CLIPPINGPLANE"],"clippingPlaneUniforms"),this._addUniform(e,["SKY"],"skyUniforms"),this._addUniform(e,["SKYDOME"],"skyDomeUniforms"),this._addUniform(e,["GRASS"],"grassUniforms"),this._addUniform(e,["OVERLAY"],"overlayUniforms"),this._addUniform(e,["OVERLAYNORMAL"],"overlayNormalUniforms"),this._addUniform(e,["+DITHER"],"timeUniforms"),this._addUniform(e,["CASTSHADOW"],"castShadowUniforms"),this._addUniform(e,["RECEIVESHADOW"],"receiveShadowUniforms"),this._addUniform(e,["DEPTHSHADOW"],"depthShadowUniforms"),this._addUniform(e,["CLOUDS"],"cloudsUniforms"),this._addUniform(e,["+TONEMAPPING","+SKY"],"toneMappingUniforms"),this._addUniform(e,["DEFERRED_GEOMETRY"],"deferredGeometryUniforms"),this._addUniform(e,["DEFERRED_LIGHT"],"deferredLightUniforms"),this._addUniform(e,["VIEW"],"viewUniforms"),this._addUniform(e,["EMISSIVE"],"emissiveUniforms"),this._addUniform(e,["EMISSIVEMAP"],"emissiveMapUniforms"),r.UniformsUtils.clone(r.UniformsUtils.merge(e))}_addCode(r,e,t,o){this.isEnable(e)?(r.push("// begin ["+t+"]"),r.push(n[t]),r.push("// end ["+t+"]"),r.push("")):void 0!==o&&(r.push("// begin ["+o+"]"),r.push(n[o]),r.push("// end ["+o+"]"),r.push(""))}_addDebugCode(r,e){if(this.isEnable(e)){r.push("// begin [DEBUGCODE]");for(let e of this.debugCode)r.push(e);r.push("// end [DEBUGCODE]"),r.push("")}}_generateVertexShader(){const r=[];return this._addCode(r,["GLSL3"],"glsl3Vert"),this.isEnable("DEFERRED_GEOMETRY")?(this._addCode(r,[],"deferredGeometryVert"),r.join("\n")):this.isEnable("DEFERRED_LIGHT")?(this._addCode(r,[],"deferredLightVert"),r.join("\n")):(this._addCode(r,[],"common"),this._addCode(r,["+CASTSHADOW","+RECEIVESHADOW"],"packing"),this._addCode(r,[],"worldPositionVertFragPars"),r.push("varying vec3 vViewPosition;"),r.push("varying vec3 vNormal;"),r.push(""),this._addCode(r,["+COLORMAP","+NORMALMAP","+BUMPMAP","+PROJECTIONMAP","+OVERLAY","+DEPTHSHADOW","+CLOUDS","+VIEW","+EMISSIVEMAP"],"uvVertFragPars"),this._addCode(r,["+NORMALMAP","+BUMPOFFSET","+PARALLAXOCCLUSIONMAP","+RELIEFMAP","+ANISOTROPY","+OVERLAYNORMAL"],"tangentVertPars"),this._addCode(r,["+UVSCROLL","+UVSCROLL2"],"uvScrollVertPars"),this._addCode(r,["+GLASS","+DITHER"],"screenVertPars"),this._addCode(r,["DISTORTION"],"distortionVertPars"),this._addCode(r,["ANISOTROPY"],"anisotropyVertPars"),this._addCode(r,["FOG"],"fogVertPars"),this._addCode(r,["HEIGHTFOG"],"heightFogVertPars"),this._addCode(r,["PROJECTIONMAP"],"projectionMapVertPars"),this._addCode(r,["DISPLACEMENTMAP"],"displacementMapVertPars"),this._addCode(r,["GRASS"],"grassVertPars"),this._addCode(r,["CASTSHADOW","GRASS"],"instanceCastShadowVertPars"),this._addCode(r,["CASTSHADOW","-GRASS"],"castShadowVertPars"),this._addCode(r,["RECEIVESHADOW"],"receiveShadowVertPars"),this.isEnable(["BILLBOARD"])?(this._addCode(r,[],"billboardVertPars"),this._addCode(r,[],"billboardVert"),this._addCode(r,["BILLBOARDY"],"billboardYVert","billboardDefaultVert"),this._addCode(r,["BILLBOARDROTZ"],"billboardRotZVertEnd","billboardVertEnd")):this.isEnable(["CASTSHADOW"])?(r.push("void main() {"),this._addCode(r,["GRASS"],"instanceCastShadowVert"),this._addCode(r,["-GRASS"],"castShadowVert")):(r.push("void main() {"),r.push("  vec3 transformed = position;"),r.push("  vec3 objectNormal = vec3(normal);"),this._addCode(r,["DISPLACEMENTMAP"],"displacementMapVert"),this._addCode(r,[],"worldPositionVert"),this._addCode(r,["GRASS"],"grassVert"),r.push("  vec4 mvPosition = viewMatrix * vec4(vWorldPosition, 1.0);"),r.push("  vec4 hpos = projectionMatrix * mvPosition;"),this.isEnable(["+NORMALMAP","+ANISOTROPY","+OVERLAYNORMAL"])?r.push("  vNormal.xyz = inverseTransformDirection(objectNormal, modelMatrix);"):r.push("  vNormal.xyz = normalMatrix * objectNormal;"),r.push("  vViewPosition = -mvPosition.xyz;"),r.push("")),this.isEnable(["+COLORMAP","+NORMALMAP","+BUMPMAP","+OVERLAY","+DEPTHSHADOW","+CLOUDS","+VIEW","+EMISSIVEMAP"])&&(this._addCode(r,["UVPROJECTION"],"uvProjectionVert","uvVert"),this._addCode(r,["UVSCROLL"],"uvScrollVert"),this._addCode(r,["DISTORTION"],"distortionVert"),this._addCode(r,["UVSCROLL2"],"uvScroll2Vert")),this._addCode(r,["+NORMALMAP","+BUMPOFFSET","+PARALLAXOCCLUSIONMAP","+RELIEFMAP","+ANISOTROPY","+OVERLAYNORMAL"],"tangentVert"),this._addCode(r,["+GLASS","+DITHER"],"screenVert"),this._addCode(r,["GLASS"],"glassVert"),this._addCode(r,["ANISOTRPY"],"anisotropyVert"),this._addCode(r,["FOG"],"fogVert"),this._addCode(r,["HEIGHTFOG"],"heightFogVert"),this._addCode(r,["PROJECTIONMAP"],"projectionMapVert"),this._addCode(r,["RECEIVESHADOW"],"receiveShadowVert"),r.push("  gl_Position = hpos;"),r.push("}"),r.join("\n"))}_generateFragmentShader(){const r=[];if(this.isEnable("DEFERRED_GEOMETRY"))return r.push("#define MULTIRENDERCOLOR"),this._addCode(r,["GLSL3"],"glsl3Frag"),this._addCode(r,[],"deferredGeometryFrag"),r.join("\n");if(this.isEnable("DEFERRED_LIGHT"))return this._addCode(r,["GLSL3"],"glsl3Frag"),this._addCode(r,[],"deferredLightFrag"),r.join("\n");if(this._addCode(r,["GLSL3"],"glsl3Frag"),this.isEnable("VIEW"))return this._addCode(r,[],"viewFrag"),r.join("\n");if(this._addCode(r,[],"common"),this.isEnable(["CASTSHADOW"]))return this._addCode(r,[],"packing"),this._addCode(r,[],"castShadowFragPars"),this._addCode(r,["GRASS"],"uvVertFragPars"),this._addCode(r,["GRASS"],"colorMapFragPars"),r.push(""),r.push("void main() {"),this._addCode(r,["GRASS"],"instanceColorMapDiscardFrag"),this._addCode(r,[],"castShadowFrag"),r.push("}"),r.join("\n");if(this.isEnable(["DEPTHSHADOW"]))return this._addCode(r,[],"packing"),this._addCode(r,[],"uvVertFragPars"),this._addCode(r,[],"depthShadowFragPars"),r.push(""),r.push("void main() {"),this._addCode(r,[],"depthShadowFrag"),r.push("}"),r.join("\n");if(this.isEnable(["DEPTH"]))return this._addCode(r,[],"depthFragPars"),r.push(""),r.push("void main() {"),this._addCode(r,[],"depthFrag"),r.push("}"),r.join("\n");this._addCode(r,["RECEIVESHADOW"],"packing"),this._addCode(r,["AMBIENT"],"ambientFragPars"),this._addCode(r,["AMBIENT","HEMISPHERE"],"ambientHemisphereFragPars");const e=this.enables.DIRECTLIGHT||0,n=this.enables.POINTLIGHT||0,t=this.enables.SPOTLIGHT||0;r.push(this._generateLightsFragPars(e,n,t));const o=this.enables.AREALIGHT||0,a=this.enables.TUBELIGHT||0,i=this.enables.RECTLIGHT||0;return r.push(this._generateAreaLightsFragPars(o,a,i)),r.push("uniform vec3 diffuseColor;"),r.push("uniform float opacity;"),r.push("varying vec3 vNormal;"),r.push("varying vec3 vViewPosition;"),r.push(""),this._addCode(r,[],"worldPositionVertFragPars"),this._addCode(r,["STANDARD"],"bsdfs"),this._addCode(r,["STANDARD"],"standardFragPars"),this._addCode(r,["STANDARD","ROUGHNESSMAP"],"roughnessMapFragPars"),this._addCode(r,["STANDARD","METALNESSMAP"],"metalnessMapFragPars"),this._addCode(r,["PHONG"],"phongFragPars"),this._addCode(r,["PHONG","SPECULARMAP"],"specularMapFragPars"),this._addCode(r,["PHONG","-SPECULARMAP"],"specularFragPars"),this._addCode(r,["TOON"],"toonFragPars"),this._addCode(r,["REFLECTION"],"reflectionFragPars"),this._addCode(r,["REFLECTION","FRESNEL"],"fresnelFragPars"),this._addCode(r,["REFLECTION","-FRESNEL","STANDARD"],"lightsPars"),this._addCode(r,["VELVET"],"velvetFragPars"),this._addCode(r,["INNERGLOW"],"innerGlowFragPars"),this._addCode(r,["LINEGLOW"],"lineGlowFragPars"),this._addCode(r,["RIMLIGHT"],"rimLightFragPars"),this._addCode(r,["+COLORMAP","+NORMALMAP","+PROJECTIONMAP","+OVERLAY","+CLOUDS","+EMISSIVEMAP"],"uvVertFragPars"),this._addCode(r,["UVSCALE"],"uvScaleFragPars"),this._addCode(r,["COLORMAP"],"colorMapFragPars"),this._addCode(r,["+NORMALMAP","+BUMPOFFSET","+PARALLAXOCCLUSIONMAP","+RELIEFMAP","+ANISOTROPY","+OVERLAYNORMAL"],"tangentFragPars"),this._addCode(r,["NORMALMAP"],"normalMapFragPars"),this._addCode(r,["+BUMPOFFSET","+PARALLAXMAP"],"parallaxMapFragPars"),this._addCode(r,["PARALLAXOCCLUSIONMAP"],"parallaxOcclusionMapFragPars"),this._addCode(r,["RELIEFMAP"],"reliefMapFragPars"),this._addCode(r,["BUMPMAP"],"bumpMapFragPars"),this._addCode(r,["PROJECTIONMAP"],"projectionMapFragPars"),this._addCode(r,["DISTORTION"],"distortionFragPars"),this._addCode(r,["GLASS"],"glassFragPars"),this._addCode(r,["ANISOTROPY"],"anisotropyFragPars"),this._addCode(r,["AOMAP"],"aoMapFragPars"),this._addCode(r,["LIGHTMAP"],"lightMapFragPars"),this._addCode(r,["FOG"],"fogFragPars"),this._addCode(r,["HEIGHTFOG"],"heightFogFragPars"),this._addCode(r,["HEIGHTFOG","HEIGHTFOGMAP"],"heightFogMapFragPars"),this._addCode(r,["CLIPPINGPLANE"],"clippingPlaneFragPars"),this._addCode(r,["SKY"],"skyFragPars"),this._addCode(r,["SKYDOME"],"skyDomeFragPars"),this._addCode(r,["OVERLAY"],"overlayFragPars"),this._addCode(r,["OVERLAYNORMAL"],"overlayNormalFragPars"),this._addCode(r,["DITHER"],"ditherFragPars"),this._addCode(r,["+DITHER"],"timeFragPars"),this._addCode(r,["RECEIVESHADOW"],"receiveShadowFragPars"),this._addCode(r,["CLOUDS"],"cloudsFragPars"),this._addCode(r,["+TONEMAPPING","+SKY"],"toneMappingFragPars"),this._addCode(r,["EMISSIVE"],"emissiveFragPars"),this._addCode(r,["EMISSIVEMAP"],"emissiveMapFragPars"),o>0&&this._addCode(r,[],"standardAreaLightFrag"),a>0&&this._addCode(r,[],"standardTubeLightFrag"),i>0&&this._addCode(r,[],"standardRectLightFrag"),(e>0||n>0||t>0)&&(r.push("void updateLight(inout IncidentLight directLight) {"),this._addCode(r,["-SKY","-NOLIT","RECEIVESHADOW"],"receiveShadowFrag"),r.push("}"),r.push(""),r.push("void computeLight(const in IncidentLight directLight, const in GeometricContext geometry, const in Material material, inout ReflectedLight reflectedLight) {"),this._addCode(r,["PHONG","TOON"],"toonFrag"),this._addCode(r,["PHONG","-TOON"],"phongFrag"),this._addCode(r,["STANDARD","ORENNAYAR"],"standardOrenNayarFrag"),this._addCode(r,["STANDARD","-ORENNAYAR"],"standardFrag"),this._addCode(r,["-STANDARD","-PHONG"],"lambertFrag"),this._addCode(r,["VELVET"],"velvetFrag"),this._addCode(r,["RIMLIGHT"],"rimLightFrag"),this._addCode(r,["ANISOTROPY"],"anisotropyFrag"),r.push("}"),r.push("")),r.push("void main() {"),this._addCode(r,["CLIPPINGPLANE"],"clippingPlaneFrag"),this._addCode(r,[],"beginFrag"),this._addCode(r,["DEBUG"],"beginFragDebug"),this._addCode(r,["AMBIENT","HEMISPHERE"],"ambientHemisphereFrag"),this._addCode(r,["AMBIENT","-HEMISPHERE"],"ambientFrag"),this._addCode(r,["+COLORMAP","+NORMALMAP","+BUMPMAP","+OVERLAY","+CLOUDS","+EMISSIVEMAP"],"uvFrag"),this._addCode(r,["UVSPHERICAL"],"uvSphericalFrag"),this._addCode(r,["UVHEMISPHERICAL"],"uvHemiSphericalFrag"),this._addCode(r,["UVSCALE"],"uvScaleFrag"),this._addCode(r,["PARALLAXMAP"],"parallaxMapFrag"),this._addCode(r,["PARALLAXOCCLUSIONMAP"],"parallaxOcclusionMapFrag"),this._addCode(r,["RELIEFMAP"],"reliefMapFrag"),this._addCode(r,["BUMPOFFSET"],"parallaxFrag"),this._addCode(r,["DISTORTION"],"distortionFrag"),this._addCode(r,["COLORMAP"],"colorMapFrag"),this._addCode(r,["COLORMAP","COLORMAPALPHA"],"colorMapAlphaFrag"),this._addCode(r,["OPACITY"],"opacityFrag"),this._addCode(r,["DITHER"],"ditherFrag"),this._addCode(r,["DISCARD"],"discardFrag"),this._addCode(r,["OVERLAY"],"overlayFrag"),this._addCode(r,["OVERLAYNORMAL"],"overlayNormalFrag"),this._addCode(r,["NORMALMAP"],"normalMapFrag"),this._addCode(r,["BUMPMAP"],"bumpMapFrag"),this._addCode(r,["PHONG","SPECULARMAP"],"specularMapFrag"),this._addCode(r,["PHONG","-SPECULARMAP"],"specularFrag"),this._addCode(r,["STANDARD"],"roughnessFrag"),this._addCode(r,["STANDARD","ROUGHNESSMAP"],"roughnessMapFrag"),this._addCode(r,["STANDARD"],"metalnessFrag"),this._addCode(r,["STANDARD","METALNESSMAP"],"metalnessMapFrag"),this._addCode(r,["STANDARD"],"lightsStandardFrag"),this._addCode(r,["SKY"],"skyFrag"),this._addCode(r,["-SKY","NOLIT"],"nolitFrag"),this.isEnable(["-SKY","-NOLIT"])&&(r.push(this._generateLightsFrag(e,n,t)),r.push(this._generateAreaLightsFrag(o,a,i))),this._addCode(r,["SKYDOME"],"skyDomeFrag"),this._addCode(r,["REFLECTION","FRESNEL"],"fresnelFrag"),this._addCode(r,["REFLECTION","-FRESNEL","STANDARD"],"reflectionStandardFrag"),this._addCode(r,["REFLECTION","-FRESNEL","-STANDARD"],"reflectionFrag"),this._addCode(r,["LIGHTMAP"],"lightMapFrag"),this._addCode(r,["GLASS"],"glassFrag"),this._addCode(r,["AOMAP"],"aoMapFrag"),this._addCode(r,["PROJECTIONMAP"],"projectionMapFrag"),this._addCode(r,["INNERGLOW","INNERGLOWSUBTRACT"],"innerGlowSubtractFrag"),this._addCode(r,["INNERGLOW","-INNERGLOWSUBTRACT"],"innerGlowFrag"),this._addCode(r,["LINEGLOW"],"lineGlowFrag"),this._addCode(r,["CLOUDS"],"cloudsFrag"),this._addCode(r,["EMISSIVE"],"emissiveFrag"),this._addCode(r,["EMISSIVEMAP"],"emissiveMapFrag"),this._addCode(r,[],"accumulateFrag"),this._addCode(r,["FOG"],"fogFrag"),this._addCode(r,["HEIGHTFOG","HEIGHTFOGMAP"],"heightFogMapFrag"),this._addCode(r,["HEIGHTFOG","-HEIGHTFOGMAP"],"heightFogFrag"),this._addCode(r,["TONEMAPPING"],"toneMappingFrag"),this._addCode(r,[],"endFrag"),this._addCode(r,["DEBUG"],"endFragDebug"),this._addDebugCode(r,["DEBUGCODE"]),r.push("}"),r.join("\n")}_generateLightsFragPars(r,e,t){if(r<=0&&e<=0&&t<=0)return"";const o=[];return o.push(n.lightsFragPars),r>0&&(o.push("#define PIXY_DIRECT_LIGHTS_NUM "+r),o.push("uniform DirectLight directLights[ PIXY_DIRECT_LIGHTS_NUM ];")),e>0&&(o.push("#define PIXY_POINT_LIGHTS_NUM "+e),o.push("uniform PointLight pointLights[ PIXY_POINT_LIGHTS_NUM ];")),t>0&&(o.push("#define PIXY_SPOT_LIGHTS_NUM "+t),o.push("uniform SpotLight spotLights[ PIXY_SPOT_LIGHTS_NUM ];")),o.join("\n")}_generateAreaLightsFragPars(r,e,t){if(r<=0&&e<=0&&t<=0)return"";const o=[];return o.push(n.lightsFragPars),r>0&&(o.push("#define PIXY_AREA_LIGHTS_NUM "+r),o.push("uniform AreaLight areaLights[ PIXY_AREA_LIGHTS_NUM ];")),e>0&&(o.push("#define PIXY_TUBE_LIGHTS_NUM "+e),o.push("uniform TubeLight tubeLights[ PIXY_TUBE_LIGHTS_NUM ];")),t>0&&(o.push("#define PIXY_RECT_LIGHTS_NUM "+t),o.push("uniform RectLight rectLights[ PIXY_RECT_LIGHTS_NUM ];")),o.join("\n")}_generateLightsFrag(r,e,t){if(r<=0&&e<=0&&t<=0)return"";const o=[];return o.push("  IncidentLight directLight;"),1==r?o.push(n.lightsDirectFragUnroll):r>0&&o.push(n.lightsDirectFrag),1==e?o.push(n.lightsPointFragUnroll):e>0&&o.push(n.lightsPointFrag),1==t?o.push(n.lightsSpotFragUnroll):t>0&&o.push(n.lightsSpotFrag),o.join("\n")}_generateAreaLightsFrag(r,e,t){if(r<=0&&e<=0&&t<=0)return"";const o=[];return o.push("  IncidentLight directLight;"),1==r?o.push(n.lightsAreaLightFragUnroll):r>0&&o.push(n.lightsAreaLightFrag),1==e?o.push(n.lightsTubeLightFragUnroll):e>0&&o.push(n.lightsTubeLightFrag),1==t?o.push(n.lightsRectLightFragUnroll):t>0&&o.push(n.lightsRectLightFrag),o.join("\n")}setDebugCode(r){this.debugCode=r}build(e){this.uniforms=this._generateUniforms();const n={uniforms:this.uniforms,vertexShader:this._generateVertexShader(),fragmentShader:this._generateFragmentShader()};if(this.isEnable(["+DEFERRED_GEOMETRY","+DEFERRED_LIGHT"]))return this.material=new r.RawShaderMaterial(Object.assign(n,e)),this.isEnable(["GLSL3"])&&(this.material.glslVersion=r.GLSL3),void(this.material.extensions.derivatives=!0);this.material=new r.ShaderMaterial(Object.assign(n,e)),this.isEnable("BUMPMAP")&&(this.material.extensions.derivatives=!0),this.isEnable(["STANDARD","REFLECTION"])&&(this.material.extensions.shaderTextureLOD=!0)}}const l={copy:{uniforms:r.UniformsUtils.merge([n.copyUniforms]),vertexShader:n.copyVert,fragmentShader:n.copyFrag},id:{uniforms:r.UniformsUtils.merge([n.idUniforms]),vertexShader:n.idVert,fragmentShader:n.idFrag},edge:{uniforms:r.UniformsUtils.merge([n.edgeUniforms]),vertexShader:n.edgeVert,fragmentShader:n.edgeFrag},edgeExpand:{uniforms:r.UniformsUtils.merge([n.edgeExpandUniforms]),vertexShader:n.edgeExpandVert,fragmentShader:n.edgeExpnadFrag},edgeID:{uniforms:r.UniformsUtils.merge([n.edgeIDUniforms]),vertexShader:n.edgeIDVert,fragmentShader:n.edgeIDFrag},edgeComposite:{uniforms:r.UniformsUtils.merge([n.edgeCompositeUniforms]),vertexShader:n.edgeCompositeVert,fragmentShader:n.edgeCompositeFrag},luminosityHighPass:{uniforms:r.UniformsUtils.merge([n.luminosityHighPassUniforms]),vertexShader:n.luminosityHighPassVert,fragmentShader:n.luminosityHighPassFrag},luminosity:{uniforms:r.UniformsUtils.merge([n.luminosityUniforms]),vertexShader:n.luminosityVert,fragmentShader:n.luminosityFrag},toneMap:{uniforms:r.UniformsUtils.merge([n.toneMapUniforms]),vertexShader:n.toneMapVert,fragmentShader:n.toneMapFrag},ssao:{uniforms:r.UniformsUtils.merge([n.ssaoUniforms]),vertexShader:n.ssaoVert,fragmentShader:n.ssaoFrag},ssao2:{uniforms:r.UniformsUtils.merge([n.ssao2Uniforms]),vertexShader:n.ssaoVert,fragmentShader:n.ssao2Frag},ssao2Blur:{uniforms:r.UniformsUtils.merge([n.ssao2BlurUniforms]),vertexShader:n.copyVert,fragmentShader:n.ssao2BlurFrag},ssao2Composite:{uniforms:r.UniformsUtils.merge([n.ssao2CompositeUniforms]),vertexShader:n.copyVert,fragmentShader:n.ssao2CompositeFrag},fxaa:{uniforms:r.UniformsUtils.merge([n.antiAliasUniforms]),vertexShader:n.antiAliasVert,fragmentShader:n.antiAliasFrag},colorBalance:{uniforms:r.UniformsUtils.merge([n.colorBalanceUniforms]),vertexShader:n.copyVert,fragmentShader:n.colorBalanceFrag},view:{uniforms:r.UniformsUtils.merge([n.viewUniforms]),vertexShader:n.copyVert,fragmentShader:n.viewFrag}};function c(r){for(let e=0;e<r.length;++e)if(r[e])return!0;return!1}function f(r){for(let e=0;e<r.length;++e)if(!r[e])return!1;return!0}function d(r){return r*Math.PI/180}function u(r){return 180*r/Math.PI}function v(r){return r*r}function m(r,e){return Math.exp(-r*r/(2*e*e))}function h(r){let e=2*Math.ceil(3*r)+1;e>25&&(e=25);const n=.5*(e-1),t=new Array(e),o=0;for(let a=0;a<e;++a)t[a]=m(a-n,r),o+=t[a];for(let r=0;r<e;++r)t[r]/=o;return t}function p(r,e){const n=new Array(e),t=r*r;let o=0;for(let r=0;r<n.length;++r){const e=1+2*r;n[r]=Math.exp(e*e*-.5/t),o+=n[r]}for(let r=0;r<n.length;++r)n[r]/=o;return n}function g(e,n){const t=new r.Matrix4;return t.set(1-Math.pow(2*e.x,2),-2*e.x*e.y,-2*e.x*e.z,0,-2*e.x*e.y,1-Math.pow(2*e.y,2),-2*e.y*e.z,0,-2*e.x*e.z,-2*e.y*e.z,1-Math.pow(2*e.z,2),0,-2*n*e.x,-2*n*e.y,-2*n*e.z,1),t}function x(e,n,t,o,a){const i=new r.DirectionalLight(o,a);return i.position.set(e,n,t),i.castShadow=!0,i.shadow.camera.left=-1,i.shadow.camera.right=1,i.shadow.camera.top=1,i.shadow.camera.bottom=-1,i.shadow.camera.near=1,i.shadow.camera.far=4,i.shadow.mapSize.width=1024,i.shadow.mapSize.height=1024,i.shadow.bias=-.005,i}function y(r){document.getElementById(r).innerHTML=""}function w(r,e){document.getElementById(r).innerHTML+=e+"<br>"}function b(r){let e="";for(let n=0;n<4;++n)e+=("        "+r.elements[4*n+0]).slice(-8)+", ",e+=("        "+r.elements[4*n+1]).slice(-8)+", ",e+=("        "+r.elements[4*n+2]).slice(-8)+", ",e+=("        "+r.elements[4*n+3]).slice(-8)+"<br>";w(e.replace(/\ /g,"&nbsp;"))}function C(r,e){const n=Math.pow(10,e);return Math.ceil(r*n)/n}function S(r){const e="";for(const n=0;n<4;++n)e+=("        "+C(r.elements[4*n+0],5)).slice(-8)+", ",e+=("        "+C(r.elements[4*n+1],5)).slice(-8)+", ",e+=("        "+C(r.elements[4*n+2],5)).slice(-8)+", ",e+=("        "+C(r.elements[4*n+3],5)).slice(-8)+"\n";console.log(e)}const P={calcJulianDate:function(r){const e=r.getFullYear(),n=r.getMonth()+1,t=r.getDate();n<=2&&(e--,n+=12);const o=Math.floor(e/100),a=2-o+Math.floor(o/4);return Math.floor(365.25*(e+4716))+Math.floor(30.6001*(n+1))+t+a-1524.5},calcTimeDecimal:function(r){return r.getHours()+r.getMinutes()/60+r.getSeconds()/3600},getOffset:function(r){return 9},calcTimeJulian:function(r){return(this.calcJulianDate(r)+(this.calcTimeDecimal(r)-this.getOffset(r))/24-2451545)/36525},calcMeanObliquityOfEcliptic:function(r){return 23+(26+(21.448-r*(46.815+r*(59e-5-.001813*r)))/60)/60},calcObliquityCorrection:function(r){const e=125.04-1934.136*r;return this.calcMeanObliquityOfEcliptic(r)+.00256*Math.cos(d(e))},calcGeomMeanLongSun:function(r){let e=280.46646+r*(36000.76983+3032e-7*r);for(;e>360;)e-=360;for(;e<0;)e+=360;return e},calcGeomMeanAnomalySun:function(r){return 357.52911+r*(35999.05029-1537e-7*r)},calcEccentricityEarthOrbit:function(r){return.016708634-r*(42037e-9+1.267e-7*r)},calcSunEqOfCenter:function(r){const e=this.calcGeomMeanAnomalySun(r);return Math.sin(d(e))*(1.914602-r*(.004817+14e-6*r))+Math.sin(d(2*e))*(.019993-101e-6*r)+289e-6*Math.sin(d(3*e))},calcSunTrueLong:function(r){return this.calcGeomMeanLongSun(r)+this.calcSunEqOfCenter(r)},calcSunApparentLong:function(r){const e=125.04-1934.136*r;return this.calcSunTrueLong(r)-.00569-.00478*Math.sin(d(e))},calcSolarDeclination:function(r){const e=this.calcTimeJulian(r),n=this.calcObliquityCorrection(e),t=this.calcSunApparentLong(e),o=Math.sin(d(n))*Math.sin(d(t));return u(Math.asin(o))},calcEquationOfTime:function(r){const e=this.calcTimeJulian(r),n=this.calcObliquityCorrection(e),t=this.calcGeomMeanLongSun(e),o=this.calcEccentricityEarthOrbit(e),a=this.calcGeomMeanAnomalySun(e),i=v(Math.tan(d(n/2))),s=Math.sin(d(2*t)),l=Math.sin(d(a));return 4*u(i*s-2*o*l+4*o*i*l*Math.cos(d(2*t))-.5*i*i*Math.sin(d(4*t))-1.25*o*o*Math.sin(d(2*a)))},calcTrueSolarTime:function(r,e){const n=this.calcEquationOfTime(r);let t=60*this.calcTimeDecimal(r)+(n+4*e-60*this.getOffset(r));for(;t>1440;)t-=1440;return t},calcHourAngle:function(r,e){let n=this.calcTrueSolarTime(r,e)/4-180;return n<-180&&(n+=360),n},calcSolarZenith:function(r,e,n,t){const o=this.calcSolarDeclination(r),a=this.calcHourAngle(r,n),i=Math.sin(d(o)),s=Math.cos(d(o)),l=Math.sin(d(e))*i+Math.cos(d(e))*s*Math.cos(d(a));let c=u(Math.acos(l));if(t){const r=90-c;let e=0;const n=Math.tan(d(r));e=r<=85&&r>5?58.1/n-.07/Math.pow(n,3)+86e-6/Math.pow(n,5):r<=85&&r>-.575?1735+r*(r*(103.4+r*(.711*r-12.79))-518.2):-20.774/n,c-=e}return c},calcSolarAzimuth:function(r,e,n){const t=this.calcSolarDeclination(r),o=this.calcHourAngle(r,n),a=this.calcSolarZenith(r,e,n,!1),i=Math.sin(d(a)),s=Math.cos(d(a)),l=Math.sin(d(e)),c=Math.cos(d(e));let f=Math.acos((s*l-Math.sin(d(t)))/(i*c));return f=u(f),o>0?(f+180)%360:(540-f)%360},calcSolarAltitude:function(r,e,n){return 90-this.calcSolarZenith(r,e,n)},calcAirMass:function(r,e,n){const t=this.calcSolarZenith(r,e,n);if(t<90){const r=d(t);return(1.002432*Math.pow(Math.cos(r),2)+.148386*Math.cos(r)+.0096467)/(Math.pow(Math.cos(r),3)+.149864*Math.pow(Math.cos(r),2)+.0102963*Math.cos(r)+303978e-9)}return 0},calcExtraIrradiance:function(r){const e=new Date(r.getFullYear(),0,0),n=(r.getTime()-e.getTime())/864e5;return 1367*(1+Math.cos(d(360*n/365))/30)},calcSolarAttenuation:function(r,e){let n=[0,0,0];if(93.885-r/Math.PI*180<0)return n;const t=.0460836582205*e-.04586025928522,o=1/(Math.cos(r)+.15*Math.pow(93.885-r/Math.PI*180,-1.253)),a=[.65,.57,.475];for(let r=0;r<3;r++){const e=Math.exp(.008735*-o*Math.pow(a[r],-4.08)),i=1.3,s=Math.exp(-o*t*Math.pow(a[r],-i));n[r]=e*s}return n}},L={uniforms:{mirrorSampler:{value:null},normalSampler:{value:null},envSampler:{value:null},alpha:{value:1},time:{value:0},distortionScale:{value:20},reflectionScale:{value:.05},noiseScale:{value:1},sunColor:{value:new r.Color(8355711)},sunDirection:{value:new r.Vector3(.70707,460551,0)},eye:{value:new r.Vector3},waterColor:{value:new r.Color(5592405)},textureMatrix:{value:new r.Matrix4}},vertexShader:["uniform mat4 textureMatrix;","uniform float time;","varying vec4 mirrorCoord;","varying vec3 worldPosition;","varying vec3 worldNormal;","void main() {","  mirrorCoord = modelMatrix * vec4(position, 1.0);","  worldPosition = mirrorCoord.xyz;","  mirrorCoord = textureMatrix * mirrorCoord;","  worldNormal = normalize(mat3(modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz) * normal);","  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);","}"].join("\n"),fragmentShader:["precision highp float;","uniform sampler2D mirrorSampler;","uniform float alpha;","uniform float time;","uniform float distortionScale;","uniform float reflectionScale;","uniform sampler2D normalSampler;","uniform vec3 sunColor;","uniform vec3 sunDirection;","uniform vec3 eye;","uniform vec3 waterColor;","uniform samplerCube envSampler;","varying vec4 mirrorCoord;","varying vec3 worldPosition;","varying vec3 worldNormal;","vec4 getNoise(vec2 uv) {","  vec2 uv0 = (uv / 103.0) + vec2(time / 17.0, time / 29.0);","  vec2 uv1 = uv / 107.0 - vec2(time / -19.0, time / 31.0);","  vec2 uv2 = uv / vec2(8907.0, 9803.0) + vec2(time / 101.0, time / 97.0);","  vec2 uv3 = uv / vec2(1091.0, 1027.0) - vec2(time / 109.0, time / -113.0);","  vec4 noise = texture2D(normalSampler, uv0) + ","    texture2D(normalSampler, uv1) + ","    texture2D(normalSampler, uv2) + ","    texture2D(normalSampler, uv3);","  return noise * 0.5 - 1.0;","}","void sunLight(const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor) {","  vec3 reflection = normalize(reflect(-sunDirection, surfaceNormal));","  float direction = max(0.0, dot(eyeDirection, reflection));","  specularColor += pow(direction, shiny) * sunColor * spec;","  diffuseColor += max(dot(sunDirection, surfaceNormal), 0.0) * sunColor * diffuse;","}",r.ShaderChunk.common,r.ShaderChunk.fog_pars_fragment,"void main() {","  vec4 noise = getNoise(worldPosition.xz);","  vec3 surfaceNormal = normalize(noise.xzy * vec3(1.5, 1.0, 1.5));","  vec3 diffuseLight = vec3(0.0);","  vec3 specularLight = vec3(0.0);","  vec3 worldToEye = eye - worldPosition;","  vec3 eyeDirection = normalize(worldToEye);","  sunLight(surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight);","  float distance = length(worldToEye);","  vec2 distortion = surfaceNormal.xz * (0.001 + 1.0 / distance) * distortionScale;","  vec3 reflectionSample = vec3(texture2D(mirrorSampler, mirrorCoord.xy / mirrorCoord.z + distortion));","  float theta = max(dot(eyeDirection, surfaceNormal), 0.0);","  float rf0 = 0.3;","  float reflectance = rf0 + (1.0 - rf0) * pow((1.0 - theta), 5.0);","  vec3 scatter = max(0.0, dot(surfaceNormal, eyeDirection)) * waterColor;","  vec3 albedo = mix(sunColor * diffuseLight * 0.3 + scatter, (vec3(0.1) + reflectionSample * 0.9 + reflectionSample * specularLight), reflectance);","  vec3 outgoingLight = albedo;",r.ShaderChunk.fog_fragment,"  gl_FragColor = vec4(outgoingLight, alpha);",r.ShaderChunk.tonemapping_fragment,"}"].join("\n")};class D extends r.Object3D{constructor(e,n,t,o){function a(r,e){return void 0!==r?r:e}super(),this.name="ocean_"+this.id,o=o||{},this.matrixNeedsUpdate=!0;const i=a(o.textureWidth,512),s=a(o.textureHeight,512);this.clipBias=a(o.clipBias,0),this.alpha=a(o.alpha,1),this.time=a(o.time,0),this.normalSampler=a(o.waterNormals,null),this.sunDirection=a(o.sunDirection,new r.Vector3(.70707,.70707,0)),this.sunColor=new r.Color(a(o.sunColor,16777215)),this.waterColor=new r.Color(a(o.waterColor,8355711)),this.eye=a(o.eye,new r.Vector3(0,0,0)),this.distortionScale=a(o.distortionScale,20),this.reflectionScale=a(o.reflectionScale,.01),this.side=a(o.side,r.FrontSide),this.fog=a(o.fog,!1),this.envSampler=a(o.envMap,null),this.renderer=e,this.scene=t,this.mirrorPlane=new r.Plane,this.normal=new r.Vector3(0,0,1),this.mirrorWorldPosition=new r.Vector3,this.cameraWorldPosition=new r.Vector3,this.rotationMatrix=new r.Matrix4,this.lookAtPosition=new r.Vector3(0,0,-1),this.clipPlane=new r.Vector4,n instanceof r.PerspectiveCamera?this.camera=n:(this.camera=new r.PerspectiveCamera,console.log(this.name+": camera is not a PerspectiveCamera")),this.textureMatrix=new r.Matrix4,this.mirrorCamera=this.camera.clone(),this.mirrorCamera.matrixAutoUpdate=!0,this.renderTarget=new r.WebGLRenderTarget(i,s);const l=L,c=r.UniformsUtils.clone(l.uniforms);this.material=new r.ShaderMaterial({fragmentShader:l.fragmentShader,vertexShader:l.vertexShader,uniforms:c,transparent:!0,side:this.side,fog:this.fog}),this.material.uniforms.mirrorSampler.value=this.renderTarget.texture,this.material.uniforms.textureMatrix.value=this.textureMatrix,this.material.uniforms.alpha.value=this.alpha,this.material.uniforms.time.value=this.time,this.material.uniforms.normalSampler.value=this.normalSampler,this.material.uniforms.sunColor.value=this.sunColor,this.material.uniforms.waterColor.value=this.waterColor,this.material.uniforms.sunDirection.value=this.sunDirection,this.material.uniforms.distortionScale.value=this.distortionScale,this.material.uniforms.reflectionScale.value=this.reflectionScale,this.material.uniforms.eye.value=this.eye,this.material.uniforms.envSampler.value=this.envSampler,r.MathUtils.isPowerOfTwo(i)&&r.MathUtils.isPowerOfTwo(s)||(this.renderTarget.texture.generateMipmaps=!1,this.renderTarget.texture.minFilter=r.LinearFilter),this.updateTextureMatrix(),this.render()}updateTextureMatrix(){this.updateMatrixWorld(),this.camera.updateMatrixWorld(),this.mirrorWorldPosition.setFromMatrixPosition(this.matrixWorld),this.cameraWorldPosition.setFromMatrixPosition(this.camera.matrixWorld),this.rotationMatrix.extractRotation(this.matrixWorld),this.normal.set(0,0,1),this.normal.applyMatrix4(this.rotationMatrix);const e=this.mirrorWorldPosition.clone().sub(this.cameraWorldPosition);e.reflect(this.normal).negate(),e.add(this.mirrorWorldPosition),this.rotationMatrix.extractRotation(this.camera.matrixWorld),this.lookAtPosition.set(0,0,-1),this.lookAtPosition.applyMatrix4(this.rotationMatrix),this.lookAtPosition.add(this.cameraWorldPosition);const n=this.mirrorWorldPosition.clone().sub(this.lookAtPosition);n.reflect(this.normal).negate(),n.add(this.mirrorWorldPosition),this.up.set(0,-1,0),this.up.applyMatrix4(this.rotationMatrix),this.up.reflect(this.normal).negate(),this.mirrorCamera.position.copy(e),this.mirrorCamera.up=this.up,this.mirrorCamera.lookAt(n),this.mirrorCamera.updateProjectionMatrix(),this.mirrorCamera.updateMatrixWorld(),this.mirrorCamera.matrixWorld.copy(this.mirrorCamera.matrixWorldInverse).invert(),this.textureMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),this.textureMatrix.multiply(this.mirrorCamera.projectionMatrix),this.textureMatrix.multiply(this.mirrorCamera.matrixWorldInverse),this.mirrorPlane.setFromNormalAndCoplanarPoint(this.normal,this.mirrorWorldPosition),this.mirrorPlane.applyMatrix4(this.mirrorCamera.matrixWorldInverse),this.clipPlane.set(this.mirrorPlane.normal.x,this.mirrorPlane.normal.y,this.mirrorPlane.normal.z,this.mirrorPlane.constant);const t=new r.Vector4,o=this.mirrorCamera.projectionMatrix;t.x=(Math.sign(this.clipPlane.x)+o.elements[8])/o.elements[0],t.y=(Math.sign(this.clipPlane.y)+o.elements[9])/o.elements[5],t.z=-1,t.w=(1+o.elements[10])/o.elements[14];let a=new r.Vector4;a=this.clipPlane.multiplyScalar(2/this.clipPlane.dot(t)),o.elements[2]=a.x,o.elements[6]=a.y,o.elements[10]=a.z+1-this.clipBias,o.elements[14]=a.w;const i=new r.Vector3;i.setFromMatrixPosition(this.camera.matrixWorld),this.eye=i,this.material.uniforms.eye.value=this.eye}render(){this.matrixNeedsUpdate&&this.updateTextureMatrix(),this.matrixNeedsUpdate=!0;for(var e=this;null!==e.parent;)e=e.parent;if(void 0!==e&&e instanceof r.Scene){var n=this.material.visible;this.material.visible=!1,this.renderer.setRenderTarget(this.renderTarget),this.renderer.clear(),this.renderer.render(e,this.mirrorCamera),this.renderer.setRenderTarget(null),this.material.visible=n}}}class F extends r.Mesh{constructor(e,n){const t=new r.MeshBasicMaterial(Object.assign({color:0,transparent:!0,opacity:.6,depthWrite:!1},n));super(e.geometry,t),this.meshMatrix=e.matrixWorld,this.frustumCulled=!1,this.matrixAutoUpdate=!1}update(){var e=new r.Matrix4;return function(r,n){var t=r.normal.x*n.x+r.normal.y*n.y+r.normal.z*n.z+-r.constant*n.w,o=e.elements;o[0]=t-n.x*r.normal.x,o[4]=-n.x*r.normal.y,o[8]=-n.x*r.normal.z,o[12]=-n.x*-r.constant,o[1]=-n.y*r.normal.x,o[5]=t-n.y*r.normal.y,o[9]=-n.y*r.normal.z,o[13]=-n.y*-r.constant,o[2]=-n.z*r.normal.x,o[6]=-n.z*r.normal.y,o[10]=t-n.z*r.normal.z,o[14]=-n.z*-r.constant,o[3]=-n.w*r.normal.x,o[7]=-n.w*r.normal.y,o[11]=-n.w*r.normal.z,o[15]=t-n.w*-r.constant,this.matrix.multiplyMatrices(e,this.meshMatrix)}}}const N={uniforms:{tDiffuse:{value:null},time:{value:0},timeRange:{value:5},color:{value:new r.Color(1,1,1)},opacity:{value:1},particleSize:{value:.75},screenWidth:{value:window.innerWidth},timeOffset:{value:0},numFrames:{value:1},frameDuration:{value:1},additiveFactor:{value:0},viewSize:{value:new r.Vector2(window.innerWidth,window.innerHeight)},tDepth:{value:null},cameraNearFar:{value:new r.Vector2(1,100)}},vertexShader:["precision highp float;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform float time;","uniform float timeRange;","uniform float timeOffset;","uniform float particleSize;","uniform float screenWidth;","attribute vec3 position;","attribute vec4 velocitySpinStart;","attribute vec4 accelerationSpinSpeed;","attribute vec4 startSizeEndSizeStartTimeLifeTime;","varying vec4 vSpinLifeTime;","varying vec4 vClipPosition;","void main() {","  float startSize = startSizeEndSizeStartTimeLifeTime.x;","  float endSize = startSizeEndSizeStartTimeLifeTime.y;","  float startTime = startSizeEndSizeStartTimeLifeTime.z;","  float lifeTime = startSizeEndSizeStartTimeLifeTime.w;","  vec3 velocity = velocitySpinStart.xyz;","  float spinStart = velocitySpinStart.w;","  vec3 acceleration = accelerationSpinSpeed.xyz;","  float spinSpeed = accelerationSpinSpeed.w;","  float localTime = mod((time - timeOffset - startTime), timeRange);","  float percentLife = localTime / lifeTime;","  vec3 newPosition = position + velocity * localTime + acceleration * localTime * localTime;","  vec4 mvPosition = modelViewMatrix * vec4(newPosition, 1.0);","  gl_Position = projectionMatrix * mvPosition;","  vClipPosition = gl_Position;","  float currentSize = particleSize * mix(startSize, endSize, percentLife);","  currentSize *= step(0.0, percentLife);","  currentSize *= step(-1.0, -percentLife);","  if (currentSize == 0.0) gl_Position = vec4(-100000000.0);","  vec4 projectedCorner = projectionMatrix * vec4(currentSize, currentSize, mvPosition.z, mvPosition.w);","  gl_PointSize = screenWidth * projectedCorner.x / projectedCorner.w;","  percentLife *= step(0.0, percentLife);","  percentLife *= step(-1.0, -percentLife);","  vSpinLifeTime = vec4(spinStart, spinSpeed, percentLife, localTime);","}"].join("\n"),fragmentShader:["precision highp float;","uniform sampler2D tDiffuse;","uniform sampler2D tDepth;","uniform vec3 color;","uniform float opacity;","uniform float time;","uniform float numFrames;","uniform float frameDuration;","uniform vec2 cameraNearFar;","uniform vec2 viewSize;","uniform float additiveFactor;","varying vec4 vSpinLifeTime;","varying vec4 vClipPosition;","float linearizeDepth(float depth, vec2 cameraNearFar) {","  return -cameraNearFar.y * cameraNearFar.x / (depth * (cameraNearFar.y - cameraNearFar.x) - cameraNearFar.y);","}","void main() {","  float spinStart = vSpinLifeTime.x;","  float spinSpeed = vSpinLifeTime.y;","  float percentLife = vSpinLifeTime.z;","  float localTime = vSpinLifeTime.w;","  const float frameStart = 0.0;","  vec2 texcoord = vec2(gl_PointCoord.x, 1.0-gl_PointCoord.y)-0.5;","  float s = sin(spinStart + spinSpeed * time);","  float c = cos(spinStart + spinSpeed * time);","  vec2 rotatedCoord1 = vec2(texcoord.x * c + texcoord.y * s, -texcoord.x * s + texcoord.y * c) + 0.5;","  rotatedCoord1 = clamp(rotatedCoord1, 0.0, 1.0);","  float frame1 = mod(floor(localTime / frameDuration + frameStart), numFrames);","  float uOffset1 = frame1 / numFrames;","  rotatedCoord1.x = uOffset1 + (rotatedCoord1.x) * (1.0 / numFrames);","  vec4 pixel1 = texture2D(tDiffuse, rotatedCoord1);","  if (pixel1.a < 0.001) discard;","  vec2 screenCoord = gl_FragCoord.xy / viewSize;","  float myDepth = vClipPosition.z / vClipPosition.w;","  float myLinearDepth = linearizeDepth(myDepth, cameraNearFar);","  float sceneDepth = texture2D(tDepth, screenCoord).x * 2.0 - 1.0;","  float sceneLinearDepth = linearizeDepth(sceneDepth, cameraNearFar);","  const float scale = 0.1;","  float zFade = clamp(scale * abs(myLinearDepth - sceneLinearDepth), 0.0, 1.0);","  if (myDepth > sceneDepth) discard;","  vec4 particleColor = pixel1 * vec4(color, opacity);","  particleColor.a *= zFade;","  gl_FragColor = particleColor;","}"].join("\n")};class M extends r.Points{constructor(e,n){const t=new r.BufferGeometry,o=new Float32Array(3*e),a=new Float32Array(4*e),i=new Float32Array(4*e),s=new Float32Array(4*e),l={position:new r.Vector3,velocity:new r.Vector3,acceleration:new r.Vector3,spinStart:0,spinSpeed:0,startSize:1,endSize:1,startTime:0,lifeTime:1};let c=0,f=0;for(let r=0;r<e;++r)n(r,l),o[c+0]=l.position.x,o[c+1]=l.position.y,o[c+2]=l.position.z,a[f+0]=l.velocity.x,a[f+1]=l.velocity.y,a[f+2]=l.velocity.z,i[f+0]=l.acceleration.x,i[f+1]=l.acceleration.y,i[f+2]=l.acceleration.z,a[f+3]=l.spinStart,i[f+3]=l.spinSpeed,s[f+0]=l.startSize,s[f+1]=l.endSize,s[f+2]=l.startTime,s[f+3]=l.lifeTime,c+=3,f+=4;t.setAttribute("position",new r.BufferAttribute(o,3)),t.setAttribute("velocitySpinStart",new r.BufferAttribute(a,4)),t.setAttribute("accelerationSpinSpeed",new r.BufferAttribute(i,4)),t.setAttribute("startSizeEndSizeStartTimeLifeTime",new r.BufferAttribute(s,4));super(t,new r.RawShaderMaterial({uniforms:r.UniformsUtils.clone(N.uniforms),vertexShader:N.vertexShader,fragmentShader:N.fragmentShader,transparent:!0,depthTest:!0,depthWrite:!1,blending:r.AdditiveBlending}))}}class R{constructor(){}generate(e,n){const t=this.__getHeightData(e,n),o=new r.PlaneGeometry(e.width,e.height,e.width-1,e.height-1);o.rotateX(-Math.PI/2);const a=o.attributes.position.array;for(var i=0;i<t.length;i++)a[3*i+1]=t[i];return o.computeVertexNormals(),o}__getHeightData(r,e){const n=document.createElement("canvas");n.width=r.width,n.height=r.height;const t=n.getContext("2d"),o=r.width*r.height,a=new Float32Array(o);t.drawImage(r,0,0);for(let r=0;r<o;r++)a[r]=0;const i=t.getImageData(0,0,r.width,r.height).data;let s=0;for(let r=0;r<i.length;r+=4){const n=i[r]+i[r+1]+i[r+2];a[s++]=n/(12*e)}return a}generateHeight(e){function n(r,e){return void 0!==r?r:e}e=e||{},this.widthExtents=n(e.widthExtents,100),this.depthExtents=n(e.depthExtents,100),this.width=n(e.width,128),this.depth=n(e.depth,128),this.maxHeight=n(e.maxHeight,2),this.minHeight=n(e.minHeight,-2),this.heightData=this.__generateHeight(this.width,this.depth,this.minHeight,this.maxHeight);const t=new r.PlaneGeometry(this.widthExtents,this.depthExtents,this.width-1,this.depth-1);t.rotateX(-Math.PI/2);const o=t.attributes.position.array;for(var a=0,i=0,s=o.length;a<s;a++,i+=3)o[i+1]=this.heightData[a];return t.computeVertexNormals(),t}__generateHeight(r,e,n,t){const o=new Float32Array(r*e),a=t-n,i=r/2,s=e/2;let l=0;for(let t=0;t<e;t++)for(let e=0;e<r;e++){const r=Math.sqrt(Math.pow((e-i)/i,2)+Math.pow((t-s)/s,2)),c=.5*(Math.sin(24*r)+1)*a+n;o[l]=c,l++}return o}}class U{constructor(e,n){this.sw=window.innerWidth,this.sh=window.innerHeight,n&&(this.sw=n.width,this.sh=n.height);const t=this,o={x:10,y:10,width:this.sw,height:this.sh};this.camera=new r.OrthographicCamera(-this.sw/2,this.sw/2,this.sh/2,-this.sh/2,1,10),this.camera.position.set(0,0,2),this.scene=new r.Scene;const a=new r.PlaneGeometry(o.width,o.height),i=new r.Mesh(a,e);this.scene.add(i),this.enabled=!0,this.size={width:o.width,height:o.height,set:function(r,e){this.width=r,this.height=e,i.scale.set(this.width/o.width,this.height/o.height,1),t.position.set(t.position.x,t.position.y)}},this.position={x:o.x,y:o.y,set:function(r,e){this.x=r,this.y=e;const n=t.size.width,o=t.size.height;i.position.set(-t.sw/2+n/2+this.x,t.sh/2-o/2-this.y,0)}},this.update()}render(r){this.enabled&&r.render(this.scene,this.camera)}updateForWindowResize(){this.enabled&&(this.sw=window.innerWidth,this.sh=window.innerHeight,this.camera.left=-window.innerWidth/2,this.camera.right=window.innerWidth/2,this.camera.top=window.innerHeight/2,this.camera.bottom=-window.innerHeight/2)}updateForCanvasResize(r){this.enabled&&(this.sw=r.width,this.sh=r.height,this.camera.left=-r.width/2,this.camera.right=r.width/2,this.camera.top=r.height/2,this.camera.bottom=-r.height/2)}update(){this.position.set(this.position.x,this.position.y),this.size.set(this.size.width,this.size.height)}}class E{constructor(r){this.renderer=r,this.passes=[]}addPass(r,e,n,t,o){this.passes.push({pass:r,readBuffer:e,writeBuffer:n,clear:t,clearDepth:o})}insertPass(r,e){this.passes.splice(e,0,r)}render(r){for(let e=0;e<this.passes.length;e++){const n=this.passes[e];if(!1===n.pass.enabled)continue;const t=this.renderer.autoClear,o=this.renderer.autoClearDepth;void 0!==n.clear&&(this.renderer.autoClear=n.clear),void 0!==n.clearDepth&&(this.renderer.autoClearDepth=n.clearDepth),n.pass.render(this.renderer,n.writeBuffer,n.readBuffer,r,false),this.renderer.autoClear=t,this.renderer.autoClearDepth=o}}}class T{constructor(){this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(r,e){}render(r,e,n,t,o){console.error("PIXY.Pass: .render() must be implemented in derived pass.")}}class A extends T{constructor(r,e){super(),this.needsSwap=!1,this.clearColor=void 0!==r?r:0,this.clearAlpha=void 0!==e?e:0}render(r,e,n,t,o){let a,i,s;this.clearColor&&(a=new THREE.Color,r.getClearColor(a),i=r.getClearAlpha(),r.setClearColor(this.clearColor,this.clearAlpha)),this.clearDepth&&(s=r.autoClearDepth,r.autoClearDepth=this.clearDepth),this.colorMask&&r.getContext().colorMask(this.colorMask[0],this.colorMask[1],this.colorMask[2],this.colorMask[3]),r.setRenderTarget(this.renderToScreen?null:e),r.clear(),this.clearColor&&r.setClearColor(a,i),this.clearDepth&&(r.autoClearDepth=s),this.colorMask&&r.getContext().colorMask(!0,!0,!0,!0)}}class I extends T{constructor(r,e){super(),this.scene=r,this.camera=e,this.clear=!0,this.needsSwap=!1,this.inverse=!1}render(r,e,n,t,o){const a=r.context,i=r.state;let s,l;i.buffers.color.setMask(!1),i.buffers.depth.setMask(!1),i.buffers.color.setLocked(!0),i.buffers.depth.setLocked(!0),this.inverse?(s=0,l=1):(s=1,l=0),i.buffers.stencil.setTest(!0),i.buffers.stencil.setOp(a.REPLACE,a.REPLACE,a.REPLACE),i.buffers.stencil.setFunc(a.ALWAYS,s,4294967295),i.buffers.stencil.setClear(l);const c=r.getRenderTarget(),f=r.autoClear;r.autoClear=!1,r.setRenderTarget(e),this.clear&&r.clear(),r.render(this.scene,this.camera),r.setRenderTarget(c),r.autoClear=f,i.buffers.stencil.setFunc(a.EQUAL,1,4294967295),i.buffers.stencil.setOp(a.KEEP,a.KEEP,a.KEEP)}}class z extends T{constructor(){super(),this.needsSwap=!1}render(r,e,n,t,o){r.state.buffers.stencil.setTest(!1)}}class _ extends T{constructor(r,e,n,t,o){super(),this.scene=r,this.camera=e,this.overrideMaterial=n||null,this.clearColor=t||0,this.clearAlpha=o||0,this.clear=!0,this.clearDepth=!0,this.needsSwap=!1}render(r,e,n,t,o){const a=r.autoClear,i=r.autoClearDepth;let s,l;r.autoClear=!1,r.autoClearDepth=this.clearDepth,this.scene.overrideMaterial=this.overrideMaterial,this.clearColor&&(s=new THREE.Color,r.getClearColor(s),l=r.getClearAlpha(),r.setClearColor(this.clearColor,this.clearAlpha)),this.colorMask&&r.getContext().colorMask(this.colorMask[0],this.colorMask[1],this.colorMask[2],this.colorMask[3]);const c=r.getRenderTarget();r.setRenderTarget(this.renderToScreen?null:e),this.clear&&r.clear(),r.render(this.scene,this.camera),r.setRenderTarget(c),this.clearColor&&r.setClearColor(s,l),this.colorMask&&r.getContext().colorMask(!0,!0,!0,!0),this.scene.overrideMaterial=null,r.autoClear=a,r.autoClearDepth=i}}class O extends T{constructor(e,n){super(),this.textureID=void 0!==n?n:"tDiffuse",e instanceof r.ShaderMaterial?(this.uniforms=e.uniforms,this.material=e):e&&(this.uniforms=r.UniformsUtils.clone(e.uniforms),this.material=new r.ShaderMaterial({defines:e.defines||{},uniforms:this.uniforms,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader,depthTest:!1,depthWrite:!1})),this.camera=new r.OrthographicCamera(-1,1,1,-1,0,1),this.scene=new r.Scene,this.quad=new r.Mesh(new r.PlaneGeometry(2,2),null),this.scene.add(this.quad)}render(r,e,n,t,o){if(this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=n.texture),this.quad.material=this.material,this.colorMask&&r.getContext().colorMask(this.colorMask[0],this.colorMask[1],this.colorMask[2],this.colorMask[3]),this.renderToScreen)r.render(this.scene,this.camera);else{var a=r.getRenderTarget();r.setRenderTarget(e),this.clear&&r.clear(),r.render(this.scene,this.camera),r.setRenderTarget(a)}this.colorMask&&r.getContext().colorMask(!0,!0,!0,!0)}}class V extends T{constructor(){super(),this.camera=new r.OrthographicCamera(-1,1,1,-1,0,1),this.scene=new r.Scene,this.quad=new r.Mesh(new r.PlaneGeometry(2,2),null),this.scene.add(this.quad)}render(r,e,n,t,o){const a=r.getRenderTarget(),i=r.autoClear;r.autoClear=!1,r.setRenderTarget(e),this.clear&&r.clear(),r.render(this.scene,this.camera),r.setRenderTarget(a),r.autoClear=i}}class G extends O{constructor(){super(l.copy)}}class H extends V{constructor(e,n,t,o,a){super(),this.aspect=e,this.strength=n,this.color=t,this.idedge=o,this.source=null;const i={minFilter:r.LinearFilter,magFilter:r.LinearFilter,format:r.RGBFormat,stencilBuffer:!1};this.edgeBuffer=new r.WebGLRenderTarget(a,a,i),this.edgeExpandBuffer=new r.WebGLRenderTarget(a,a,i);const s=l.edge;this.edgeUniforms=r.UniformsUtils.clone(s.uniforms),this.edgeMaterial=new r.ShaderMaterial({uniforms:this.edgeUniforms,vertexShader:s.vertexShader,fragmentShader:s.fragmentShader});const c=l.edgeExpand;this.edgeExpandUniforms=r.UniformsUtils.clone(c.uniforms),this.edgeExpandMaterial=new r.ShaderMaterial({uniforms:this.edgeExpandUniforms,vertexShader:c.vertexShader,fragmentShader:c.fragmentShader});const f=l.edgeID;this.idUniforms=r.UniformsUtils.clone(f.uniforms),this.idMaterial=new r.ShaderMaterial({uniforms:this.idUniforms,vertexShader:f.vertexShader,fragmentShader:f.fragmentShader});const d=l.edgeComposite;this.compositeUniforms=r.UniformsUtils.clone(d.uniforms),this.compositeMaterial=new r.ShaderMaterial({uniforms:this.compositeUniforms,vertexShader:d.vertexShader,fragmentShader:d.fragmentShader})}render(r,e,n,t,o){const a=r.getRenderTarget(),i=r.autoClear;r.autoClear=!1,this.idedge?(this.idUniforms.aspect.value=this.aspect,this.idUniforms.step.value=1,this.idUniforms.tDiffuse.value=this.source,this.quad.material=this.idMaterial,r.setRenderTarget(this.edgeBuffer),r.render(this.scene,this.camera),this.quad.material=null):(this.edgeUniforms.aspect.value=this.aspect,this.edgeUniforms.tDiffuse.value=this.source,this.quad.material=this.edgeMaterial,r.setRenderTarget(this.edgeBuffer),r.render(this.scene,this.camera),this.quad.material=null);const s=this.edgeBuffer.texture;this.strength>0&&(this.edgeExpandUniforms.aspect.value=this.aspect,this.edgeExpandUniforms.strength.value=this.strength,this.edgeExpandUniforms.tDiffuse.value=this.edgeBuffer.texture,this.quad.material=this.edgeExpandMaterial,r.setRenderTarget(this.edgeExpandBuffer),r.render(this.scene,this.camera),this.quad.material=null,s=this.edgeExpandBuffer.texture),this.compositeUniforms.edgeColor.value=this.color,this.compositeUniforms.tEdge.value=s,this.compositeUniforms.tDiffuse.value=n.texture,this.quad.material=this.compositeMaterial,r.setRenderTargeT(e),this.clear&&r.clear(),r.render(this.scene,this.camera),this.quad.material=null,r.setRenderTarget(a),r.autoClear=i}}class k extends T{constructor(e,n,t,o){super(),this.scene=e,this.camera=n,this.sampleLevel=4,this.unbiased=!0,this.clearColor=void 0!==t?t:0,this.clearAlpha=void 0!==o?o:0;const a=l.copy;this.copyUniforms=r.UniformsUtils.clone(a.uniforms),this.copyMaterial=new r.ShaderMaterial({uniforms:this.copyUniforms,vertexShader:a.vertexShader,fragmentShader:a.fragmentShader,premultipliedAlpha:!0,transparent:!0,blending:r.AdditiveBlending,depthTest:!1,depthWrite:!1}),this.camera2=new r.OrthographicCamera(-1,1,1,-1,0,1),this.scene2=new r.Scene,this.quad2=new r.Mesh(new r.PlaneGeometry(2,2),this.copyMaterial),this.quad2.frustumCulled=!1,this.scene2.add(this.quad2)}dispose(){this.sampleRenderTarget&&(this.sampleRenderTarget.dispose(),this.sampleRenderTarget=null)}render(e,n,t,o,a){this.sampleRenderTarget||(this.sampleRenderTarget=new r.WebGLRenderTarget(t.width,t.height,{minFilter:r.LinearFilter,magFilter:r.LinearFilter,format:r.RGBAFormat}));const i=k.JitterVectors[Math.max(0,Math.min(this.sampleLevel,5))],s=e.autoClear;e.autoClear=!1;const l=e.getRenderTarget(),c=new r.Color;e.getClearColor(c);const f=e.getClearAlpha(),d=1/i.length;this.copyUniforms.tDiffuse.value=this.sampleRenderTarget.texture;const u=t.width,v=t.height;for(let r=0;r<i.length;r++){const t=i[r];this.camera.setViewOffset&&this.camera.setViewOffset(u,v,.0625*t[0],.0625*t[1],u,v);let o=d;if(this.unbiased){o+=.03125*((r+.5)/i.length-.5)}this.copyUniforms.opacity.value=o,e.setClearColor(this.clearColor,this.clearAlpha),e.setRenderTargeT(this.sampleRenderTarget),e.clear(),e.render(this.scene,this.camera),0===r&&e.setClearColor(0,1),e.setRenderTarget(n),0===r&&e.clear(),e.render(this.scene2,this.camera2)}this.camera.clearViewOffset&&this.camera.clearViewOffset(),e.autoClear=s,e.setClearColor(c,f),e.setRenderTarget(l)}}k.JitterVectors=[[[0,0]],[[4,4],[-4,-4]],[[-2,-6],[6,-2],[-6,2],[2,6]],[[1,-3],[-1,3],[5,1],[-3,-5],[-5,5],[-7,-1],[3,7],[7,-7]],[[1,1],[-1,-3],[-3,2],[4,-1],[-5,-2],[2,5],[5,3],[3,-5],[-2,6],[0,-7],[-4,-6],[-6,4],[-8,0],[7,-4],[6,7],[-7,-8]],[[-4,-7],[-7,-5],[-3,-5],[-5,-4],[-1,-4],[-2,-2],[-6,-1],[-4,0],[-7,1],[-1,2],[-6,3],[-3,3],[-7,6],[-3,6],[-5,7],[-1,7],[5,-7],[1,-6],[6,-5],[4,-4],[2,-3],[7,-2],[1,-1],[4,-1],[2,1],[6,2],[0,4],[4,4],[2,5],[7,5],[5,6],[3,7]]];class q extends k{constructor(r,e,n){super(r,e,n),this.sampleLevel=0,this.accumulate=!1}render(e,n,t,o){if(!this.accumulate)return super.render(e,n,t,o),void(this.accumulateIndex=-1);const a=q.JitterVectors[5];this.sampleRenderTarget||(this.sampleRenderTarget=new r.WebGLRenderTarget(t.width,t.eheight,this.params)),this.holdRenderTarget||(this.holdRenderTarget=new r.WebGLRenderTarget(t.width,t.eheight,this.params)),this.accumulate&&-1===this.accumulateIndex&&(super.render(e,this.holdRenderTarget,t,o),this.accumulateIndex=0);const i=e.getRenderTarget(),s=e.autoClear;e.autoClear=!1;const l=1/a.length;if(this.accumulateIndex>=0&&this.accumulateIndex<a.length){this.copyUniforms.opacity.value=l,this.copyUniforms.tDiffsue.value=n.texture;const r=Math.pow(2,this.sampleLevel);for(let o=0;o<r;o++){const r=a[this.accumulateIndex];if(this.camera.setViewOffset&&this.camera.setViewOffset(t.width,t.height,.0625*r[0],.0625*r[1],t.width,t.height),e.setRenderTarget(n),e.clear(),e.render(this.scene,this.camera),e.setRenderTarget(this.sampleRenderTarget),0===this.accumulateIndex&&e.clear(),e.render(this.scene2,this.camera2),this.accumulateIndex++,this.accumulateIndex>=a.length)break}this.camera.clearViewOffset&&this.camera.clearViewOffset()}const c=this.accumulateIndex*l;c>0&&(this.copyUniforms.opacity.value=1,this.copyUniforms.tDiffuse.value=this.sampleRenderTarget.texture,e.setRenderTarget(n),e.clear(),e.render(this.scene2,this.camera2)),c<1&&(this.copyUniforms.opacity.value=1-c,this.copyUniforms.tDiffuse.value=this.holdRenderTarget.texture,e.setRenderTarget(n),0===c&&e.clear(),e.render(this.scene2,this.camera2)),e.setRenderTarget(i),e.autoClear=s}}class B extends V{constructor(e,n,t,o,a){super(),this.strength=void 0!==n?n:1,this.radius=void 0!==t?t:1,this.threshold=void 0!==o?o:1,this.resolution=void 0!==e?new r.Vector2(e.x,e.y):new r.Vector2(256,256);const i={minFilter:r.LinearFilter,magFilter:r.LinearFilter,format:r.RGBAFormat};a&&(i.type=r.FloatType),this.rtHori=[],this.rtVert=[],this.nMips=5;let s=Math.round(this.resolution.x/2),c=Math.round(this.resolution.y/2);this.rtBright=new r.WebGLRenderTarget(s,c,i),this.rtBright.texture.generateMipmaps=!1;for(let e=0;e<this.nMips;e++){let e=new r.WebGLRenderTarget(s,c,i);e.texture.generateMipmaps=!1,this.rtHori.push(e),e=new r.WebGLRenderTarget(s,c,i),e.texture.generateMipmaps=!1,this.rtVert.push(e),s=Math.round(s/2),c=Math.round(c/2)}const f=l.luminosityHighPass;this.highPassUniforms=r.UniformsUtils.clone(f.uniforms),this.highPassUniforms.luminosityThreshold.value=this.threshold,this.highPassUniforms.smoothWidth.value=.01,this.highPassMaterial=new r.ShaderMaterial({uniforms:this.highPassUniforms,vertexShader:f.vertexShader,fragmentShader:f.fragmentShader,depthTest:!1,depthWrite:!1}),this.separableBlurMaterials=[];const d=[3,5,7,9,11];s=Math.round(this.resolution.x/2),c=Math.round(this.resolution.y/2);for(let e=0;e<this.nMips;e++)this.separableBlurMaterials.push(this.getSeparableBlurMaterial(d[e])),this.separableBlurMaterials[e].uniforms.texSize.value=new r.Vector2(s,c),s=Math.round(s/2),c=Math.round(c/2);this.compositeMaterial=this.getCompositeMaterial(this.nMips),this.compositeMaterial.uniforms.blurTexture1.value=this.rtVert[0].texture,this.compositeMaterial.uniforms.blurTexture2.value=this.rtVert[1].texture,this.compositeMaterial.uniforms.blurTexture3.value=this.rtVert[2].texture,this.compositeMaterial.uniforms.blurTexture4.value=this.rtVert[3].texture,this.compositeMaterial.uniforms.blurTexture5.value=this.rtVert[4].texture,this.compositeMaterial.uniforms.bloomStrength.value=this.strength,this.compositeMaterial.uniforms.bloomRadius.value=.1,this.compositeMaterial.needsUpdate=!0;this.compositeMaterial.uniforms.bloomFactors.value=[1,.8,.6,.4,.2],this.bloomTintColors=[new r.Vector3(1,1,1),new r.Vector3(1,1,1),new r.Vector3(1,1,1),new r.Vector3(1,1,1),new r.Vector3(1,1,1)],this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors;const u=l.copy;this.copyUniforms=r.UniformsUtils.clone(u.uniforms),this.copyUniforms.opacity.value=1,this.copyMaterial=new r.ShaderMaterial({uniforms:this.copyUniforms,vertexShader:u.vertexShader,fragmentShader:u.fragmentShader,blending:r.AdditiveBlending,depthTest:!1,depthWrite:!1,transparent:!0}),this.enabled=!0,this.needsSwap=!1,this.oldClearColor=new r.Color,this.oldClearAlpha=1,this.quad.frustumCulled=!1}dispose(){for(let r=0;r<this.rtHori.length();r++)this.rtHori[r].dispose();for(let r=0;r<this.rtVert.length();r++)this.rtVert[r].dispose();this.rtBright.dispose()}render(e,n,t,o,a){this.oldClearColor=new r.Color,e.getClearColor(this.oldClearColor),this.oldClearAlpha=e.getClearAlpha();const i=e.getRenderTarget(),s=e.autoClear;e.autoClear=!1,e.setClearColor(new r.Color(0,0,0),0),a&&e.context.disable(e.context.STENCIL_TEST),this.highPassUniforms.tDiffuse.value=t.texture,this.highPassUniforms.luminosityThreshold.value=this.threshold,this.quad.material=this.highPassMaterial,e.setRenderTarget(this.rtBright),e.clear(),e.render(this.scene,this.camera);let l=this.rtBright;for(let r=0;r<this.nMips;r++)this.quad.material=this.separableBlurMaterials[r],this.separableBlurMaterials[r].uniforms.tDiffuse.value=l.texture,this.separableBlurMaterials[r].uniforms.direction.value=B.BlurDirectionX,e.setRenderTarget(this.rtHori[r]),e.clear(),e.render(this.scene,this.camera),this.separableBlurMaterials[r].uniforms.tDiffuse.value=this.rtHori[r].texture,this.separableBlurMaterials[r].uniforms.direction.value=B.BlurDirectionY,e.setRenderTarget(this.rtVert[r]),e.clear(),e.render(this.scene,this.camera),l=this.rtVert[r];this.quad.material=this.compositeMaterial,this.compositeMaterial.uniforms.bloomStrength.value=this.strength,this.compositeMaterial.uniforms.bloomRadius.value=this.radius,this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,e.setRenderTarget(this.rtHori[0]),e.clear(),e.render(this.scene,this.camera),this.quad.material=this.copyMaterial,this.copyUniforms.tDiffuse.value=this.rtHori[0].texture,a&&e.context.enable(e.context.STENCIL_TEST),e.setRenderTarget(n),e.render(this.scene,this.camera),e.setClearColor(this.oldClearColor,this.oldClearAlpha),e.setRenderTarget(i),e.autoClear=s}getSeparableBlurMaterial(e){return new r.ShaderMaterial({defines:{KERNEL_RADIUS:e,SIGMA:e},uniforms:{tDiffuse:{value:null},texSize:{value:new r.Vector2(.5,.5)},direction:{value:new r.Vector2(.5,.5)}},vertexShader:["varying vec2 vUv;","void main() {","  vUv = uv;","  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);","}"].join("\n"),fragmentShader:["#include <common>","varying vec2 vUv;","uniform sampler2D tDiffuse;","uniform vec2 texSize;","uniform vec2 direction;","float gaussianPdf(in float x, in float sigma) {","  return 0.39894 * exp(-0.5 * x * x / (sigma * sigma)) / sigma;","}","void main() {","  vec2 invSize = 1.0 / texSize;","  float fSigma = float(SIGMA);","  float weightSum = gaussianPdf(0.0, fSigma);","  vec3 diffuseSum = texture2D(tDiffuse, vUv).rgb * weightSum;","  for (int i=0; i<KERNEL_RADIUS; i++) {","    float x = float(i);","    float w = gaussianPdf(x, fSigma);","    vec2 uvOffset = direction * invSize * x;","    vec3 sample1 = texture2D(tDiffuse, vUv + uvOffset).rgb;","    vec3 sample2 = texture2D(tDiffuse, vUv - uvOffset).rgb;","    diffuseSum += (sample1 + sample2) * w;","    weightSum += 2.0 * w;","  }","  gl_FragColor = vec4(diffuseSum / weightSum, 1.0);","}"].join("\n"),depthTest:!1,depthWrite:!1})}getCompositeMaterial(e){return new r.ShaderMaterial({defines:{NUM_MIPS:e},uniforms:{blurTexture1:{value:null},blurTexture2:{value:null},blurTexture3:{value:null},blurTexture4:{value:null},blurTexture5:{value:null},dirtTexture:{value:null},bloomStrength:{value:1},bloomFactors:{value:null},bloomTintColors:{value:null},bloomRadius:{value:0}},vertexShader:["varying vec2 vUv;","void main() {","  vUv = uv;","  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);","}"].join("\n"),fragmentShader:["varying vec2 vUv;","uniform sampler2D blurTexture1;","uniform sampler2D blurTexture2;","uniform sampler2D blurTexture3;","uniform sampler2D blurTexture4;","uniform sampler2D blurTexture5;","uniform sampler2D dirtTexture;","uniform float bloomStrength;","uniform float bloomRadius;","uniform float bloomFactors[NUM_MIPS];","uniform vec3 bloomTintColors[NUM_MIPS];","float lerpBloomFactor(const in float factor) {","  float mirrorFactor = 1.2 - factor;","  return mix(factor, mirrorFactor, bloomRadius);","}","void main() {","  gl_FragColor = bloomStrength * ","    (lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + ","     lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + ","     lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + ","     lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + ","     lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv));","}"].join("\n"),depthTest:!1,depthWrite:!1})}}B.BlurDirectionX=new r.Vector2(1,0),B.BlurDirectionY=new r.Vector2(0,1);const W=0,j=1,X=2,Y=3,K=4,Z=5,J=6,Q=7;class $ extends V{constructor(e){super(),this.angleBias=e.angleBias||40,this.radius=e.radius||4.5,this.maxRadius=e.maxRadius||.5,this.strength=e.strength||10,this.resolution=e.resolution||new r.Vector2(512,512),this.depthTexture=e.depthTexture||null,this.sceneCamera=e.camera||null,this.downsampling=e.downsampling||2,this.ssaoOnly=!1;const n={minFilter:r.LinearFilter,magFilter:r.LinearFilter,format:r.RGBFormat,generateMipmaps:!1,stencilBuffer:!1};this.rtBlur1=new r.WebGLRenderTarget(this.resolution.x/this.downsampling,this.resolution.y/this.downsampling,n),this.rtBlur2=new r.WebGLRenderTarget(this.resolution.x/this.downsampling,this.resolution.y/this.downsampling,n),this.makeUniforms=r.UniformsUtils.clone(l.ssao2.uniforms),this.makeMaterial=new r.ShaderMaterial({uniforms:this.makeUniforms,vertexShader:l.ssao2.vertexShader,fragmentShader:l.ssao2.fragmentShader,depthTest:!1,depthWrite:!1}),this.blurXUniforms=r.UniformsUtils.clone(l.ssao2Blur.uniforms),this.blurXMaterial=new r.ShaderMaterial({uniforms:this.blurXUniforms,vertexShader:l.ssao2Blur.vertexShader,fragmentShader:l.ssao2Blur.fragmentShader,depthTest:!1,depthWrite:!1}),this.blurYUniforms=r.UniformsUtils.clone(l.ssao2Blur.uniforms),this.blurYMaterial=new r.ShaderMaterial({uniforms:this.blurYUniforms,vertexShader:l.ssao2Blur.vertexShader,fragmentShader:l.ssao2Blur.fragmentShader,depthTest:!1,depthWrite:!1});const t=1.44269504/12.5,o=1/this.resolution.x;this.blurXUniforms.tAO.value=this.rtBlur1.texture,this.blurXUniforms.blurParams.value.set(o,0,t,1),this.blurYUniforms.tAO.value=this.rtBlur2.texture,this.blurYUniforms.blurParams.value.set(0,o,t,1),this.compositeUniforms=r.UniformsUtils.clone(l.ssao2Composite.uniforms),this.compositeMaterial=new r.ShaderMaterial({uniforms:this.compositeUniforms,vertexShader:l.ssao2Composite.vertexShader,fragmentShader:l.ssao2Composite.fragmentShader,depthTest:!1,depthWrite:!1}),this.viewUniforms=r.UniformsUtils.clone(l.view.uniforms),this.viewMaterial=new r.ShaderMaterial({uniforms:this.viewUniforms,vertexShader:l.view.vertexShader,fragmentShader:l.view.fragmentShader,depthTest:!1,depthWrite:!1}),this.viewUniforms.type.value=2}render(r,e,n,t,o){o&&r.context.disable(r.context.STENCIL_TEST);const a=this.radius,i=a*a,s=-1/i,l=d(this.angleBias),c=Math.tan(l),f=1/Math.tan(d(.5*this.sceneCamera.fov)),u=this.resolution.x,v=this.resolution.y,m=this.maxRadius*Math.min(this.resolution.x,this.resolution.y),h=1/this.resolution.x,p=1/this.resolution.y,g=f*(this.resolution.y/this.resolution.x),x=f,y=1/g,w=1/x,b=2*y,C=-2*w,S=-1*y,P=1*w;this.makeUniforms.radiusParams.value.set(a,i,s,m),this.makeUniforms.biasParams.value.set(l,c,this.strength,1),this.makeUniforms.screenParams.value.set(u,v,h,p),this.makeUniforms.uvToViewParams.value.set(b,C,S,P),this.makeUniforms.focalParams.value.set(g,x,y,w),this.makeUniforms.cameraParams.value.set(this.sceneCamera.near,this.sceneCamera.far),this.makeUniforms.tDepth.value=this.depthTexture;const L=r.getRenderTarget(),D=r.autoClear;r.autoClear=!1,this.quad.material=this.makeMaterial,r.setRenderTarget(this.rtBlur1),r.render(this.scene,this.camera);for(let e=0;e<2;++e)this.quad.material=this.blurXMaterial,r.setRenderTarget(this.rtBlur2),r.render(this.scene,this.camera),this.quad.material=this.blurYMaterial,r.setRenderTarget(this.rtBlur1),r.render(this.scene,this.camera);const F=this.rtBlur1;this.ssaoOnly?(this.quad.material=this.viewMaterial,this.viewUniforms.tDiffuse.value=F.texture):(this.quad.material=this.compositeMaterial,this.compositeUniforms.tDiffuse.value=n.texture,this.compositeUniforms.tAO.value=F.texture),r.setRenderTarget(e),r.render(this.scene,this.camera),r.setRenderTarget(L),r.autoClear=D}}var rr={binaryMatrixFrag:"vec2 I = pin.coord+vec2(16,32);\r\nfloat g = 3.0 - length((modf(I/vec2(16,32),I)-0.5)*mat2(12,12,32,12)[int(length(I)*1e5-time)&1]); \r\nvec3 o = vec3(g, g, g);\r\no *= mat3(2.0,2.0,2.0, 2.8,2.8,2.8, 2.0,2.0,2.0)[int(length(I)*1e5-time)&1] - o;\r\npout.color = o;",blocksFrag:"// http://glslsandbox.com/e#34145.1\r\n\r\n#define SHOW_BLOCKS\r\nconst float speed = 0.7;\r\nconst float spread = 1.6;\r\nconst int numBlocks = 35;\r\n\r\nfloat pulse = 0.5;\r\n\r\nvec2 uv = pin.position * 0.5;\r\nvec3 baseColor = vec3(0.0, 0.3, 0.6);\r\nvec3 color = pulse * baseColor * 0.5 * (0.9 - cos(uv.x*8.0));\r\nfor (int i=0; i<numBlocks; ++i) {\r\n  float z = 1.0 - 0.7*rand(float(i)*1.4333); // 0=far , 1=near\r\n  float tickTime = time * z * speed + float(i) * 1.23753;\r\n  float tick = floor(tickTime);\r\n//   vec2 pos = vec2(0.6 * (rand(tick)-0.5), sign(uv.x)*spread*(0.5-fract(tickTime)));\r\n//   vec2 pos = vec2(0.6 * (rand(tick)-0.5), abs(sign(uv.x))*spread*(0.5-fract(tickTime)));\r\n  vec2 pos = vec2(0.6 * (rand(tick)-0.5), 0.6 * (rand(tick+0.2)-0.5));\r\n//   pos.x += 0.24*sign(pos.x);\r\n//   if (abs(pos.x) < 0.1) pos.x++;\r\n\r\n  vec2 size = 1.8*z*vec2(0.04, 0.04 + 0.1 * rand(tick+0.2)) * sin(tickTime);\r\n  float b = box(uv - pos, size, 0.01);\r\n  float dust = z * smoothstep(0.22, 0.0, b) * pulse * 0.5;\r\n#ifdef SHOW_BLOCKS\r\n  float block = 0.2*z*smoothstep(0.002, 0.0, b);\r\n  float shine = 0.6*z*pulse*smoothstep(-0.002, b, 0.007);\r\n  color += dust * baseColor + block*z + shine;\r\n#else\r\n  color += dust * baseColor;\r\n#endif\r\n}\r\npout.color = color;",bonfireFrag:"vec2 drag = vec2(0.0, 0.0);\r\nvec2 offset = vec2(0.0, 0.0);\r\n\r\nfloat clip = 210.0;\r\nfloat ypartClip = pin.coord.y/clip;\r\nfloat ypartClippedFalloff = clamp(2.0-ypartClip, 0.0, 1.0);\r\nfloat ypartClipped = min(ypartClip, 1.0);\r\nfloat ypartClippedn = 1.0 - ypartClipped;\r\n\r\nfloat xfuel = 1.0 - abs(2.0*pin.uv.x-1.0);\r\n// float xfuel = pow(1.0 - abs(2.0*pin.uv.x-1.0),0.5);\r\n\r\nfloat realTime = cSpeed * time;\r\n\r\nvec2 coordScaled = cDensity * 0.01 * pin.coord.xy - 0.02 * vec2(offset.x, 0.0);\r\nvec3 position = vec3(coordScaled,0.0) + vec3(1223.0,6443.0,8425.0);\r\nvec3 flow = vec3(4.1*(0.5-pin.uv.x)*pow(ypartClippedn,4.0),-2.0*xfuel*pow(ypartClippedn,64.0),0.0);\r\nvec3 timing = realTime * vec3(0.0,-1.7*cStrength*10.0,1.1) + flow;\r\n\r\nvec3 displacePos = vec3(1.0,0.5,1.0)*2.4*position + realTime*vec3(0.01,-0.7,1.3);\r\nvec3 displace3 = vec3(noiseStackUV(displacePos, 2, 0.4, 0.1),0.0);\r\n\r\nvec3 noiseCoord = (vec3(2.0,1.0,1.0)*position + timing + 0.4*displace3);\r\nfloat noise = noiseStack(noiseCoord, 3, 0.4);\r\n\r\nfloat flames = pow(ypartClipped, 0.3*xfuel) * pow(noise, 0.3*xfuel);\r\n\r\nfloat f = ypartClippedFalloff * pow(1.0 - flames*flames*flames, 8.0);\r\nfloat fff = f*f*f;\r\nvec3 fire = cIntensity * vec3(f, fff, fff*fff);\r\n\r\n// smoke\r\n// float smokeNoise = 0.5 + snoise(0.4*position + timing*vec3(1.0,1.0,0.2))/2.0;\r\n// vec3 smoke = vec3(0.3 * pow(xfuel,3.0)*pow(pin.uv.y,2.0) * (smokeNoise + 0.4*(1.0-noise)));\r\n\r\n// sparks\r\nfloat sparkGridSize = cSize*10.0;\r\nvec2 sparkCoord = pin.coord.xy - vec2(2.0*offset.x,190.0*realTime);\r\nsparkCoord -= 30.0*noiseStackUV(0.01*vec3(sparkCoord,30.0*time), 1, 0.4, 0.1);\r\nsparkCoord += 100.0 * flow.xy;\r\nif (mod(sparkCoord.y/sparkGridSize,2.0) < 1.0) sparkCoord.x += 0.5 * sparkGridSize;\r\nvec2 sparkGridIndex = vec2(floor(sparkCoord/sparkGridSize));\r\nfloat sparkRandom = prng(sparkGridIndex);\r\nfloat sparkLife = min(10.0*(1.0-min((sparkGridIndex.y + (190.0*realTime/sparkGridSize))/(24.0-20.0*sparkRandom), 1.0)), 1.0);\r\nvec3 sparks = vec3(0.0);\r\nif (sparkLife > 0.0) {\r\n  float sparkSize = xfuel*xfuel*sparkRandom*0.08;\r\n  float sparkRadians = 999.0*sparkRandom*2.0*PI + 2.0*time;\r\n  vec2 sparkCircular = vec2(sin(sparkRadians), cos(sparkRadians));\r\n  vec2 sparkOffset = (0.5-sparkSize) * sparkGridSize * sparkCircular;\r\n  vec2 sparkModules = mod(sparkCoord + sparkOffset, sparkGridSize) - 0.5*vec2(sparkGridSize);\r\n  float sparkLength = length(sparkModules);\r\n  float sparksGray = max(0.0, 1.0 - sparkLength/(sparkSize*sparkGridSize));\r\n  sparks = sparkLife * sparksGray * vec3(1.0,0.3,0.0);\r\n}\r\n\r\n// vec3 color = max(fire,sparks) + smoke;\r\nvec3 color = max(fire,sparks);\r\nvec3 gray = vec3(rgb2gray(color));\r\npout.color = mix(gray, color, cColor);",bonfireFragPars:"uniform float cSpeed;\r\nuniform float cIntensity;\r\nuniform float cStrength;\r\nuniform float cDensity;\r\nuniform float cSize;\r\nuniform float cColor;\r\n\r\nfloat noiseStack(vec3 pos, int octaves, float falloff) {\r\n  float noise = snoise(pos);\r\n  float off = 1.0;\r\n  if (octaves > 1) {\r\n    off *= falloff;\r\n    noise = (1.0-off)*noise + off*snoise(pos);\r\n  }\r\n  if (octaves > 2) {\r\n    pos *= 2.0;\r\n    off *= falloff;\r\n    noise = (1.0-off)*noise + off*snoise(pos);\r\n  }\r\n  if (octaves > 3) {\r\n    pos *= 2.0;\r\n    off *= falloff;\r\n    noise = (1.0-off)*noise + off*snoise(pos);\r\n  }\r\n  return (1.0+noise)/2.0;\r\n}\r\nvec2 noiseStackUV(vec3 pos, int octaves, float falloff, float diff) {\r\n  float displaceA = noiseStack(pos, octaves, falloff);\r\n  float displaceB = noiseStack(pos + vec3(3984.293,423.21,5235.19), octaves, falloff);\r\n  return vec2(displaceA, displaceB);\r\n}",bonfireUniforms:{cSpeed:{value:.5},cIntensity:{value:1.5},cStrength:{value:1},cDensity:{value:1},cSize:{value:3},cColor:{value:1}},booleanNoiseFrag:"vec2 p = pin.uv - time*0.1;\r\nfloat s = resolution.x * cNoiseFrequency;\r\nfloat lum = float(iqhash2(floor(p*s)/s) > 0.5);\r\npout.color = vec3(lum);\r\n\r\nfloat graph = float(iqhash2(floor(p.xx*s)/s) > 0.5);",booleanNoiseFragPars:"// dummy",brushStrokeFrag:"// vec3 color = vec3(1.0, 1.0, 0.86);\r\nvec3 color = vec3(0.0);\r\nvec2 uv = pin.position;\r\nfloat dist;\r\n\r\n// 0.8, 0.1, 0.0\r\nvec3 brushColor = mix(vec3(1.0), vec3(0.8, 0.1, 0.0), cColor);\r\ncolor = colorBrushStroke(uv, color, vec4(brushColor, 0.9),\r\n  vec2(cBrushStrokeX1, cBrushStrokeY1), vec2(cBrushStrokeX2, cBrushStrokeY2), cWidth);\r\n  // vec2(-0.4, 0.0), vec2(1.1, 0.8), 0.3);\r\n\r\n// rec-orangeish signature\r\n// dist = sdAxisAlignedRect(uv, vec2(-0.68), vec2(-0.55));\r\n// float amt = 90.0 + (brushRand(uv.y) * 100.0) + (brushRand(uv.x / 4.0) * 90.0);\r\n// float vary = sin(uv.x * uv.y * 50.0) * 0.0047;\r\n// dist = opS(dist - 0.028 + vary, dist - 0.019 - vary); // round edges, and hollow it out\r\n// color = mix(color, vec3(0.99, 0.4, 0.0), dtoa(dist, amt) * 0.7);\r\n// color = mix(color, vec3(0.85, 0.0, 0.0), dtoa(dist, 700.0));\r\n\r\n// grain\r\ncolor.rgb += (brushRand(uv) - 0.5) * 0.08;\r\ncolor.rgb = clamp(color.rgb, vec3(0.0), vec3(1.0));\r\n\r\n// uv -= 1.0;\r\n// float vigentteAmt = 1.0 - dot(uv * 0.5, uv * 0.12);\r\n// color *= vigentteAmt;\r\n\r\npout.color = color;",brushStrokeFragPars:"uniform float cWidth;\r\nuniform float cStrength;\r\nuniform float cAlpha;\r\nuniform float cAmplitude;\r\nuniform float cAngle;\r\nuniform float cBrushStrokeX1;\r\nuniform float cBrushStrokeY1;\r\nuniform float cBrushStrokeX2;\r\nuniform float cBrushStrokeY2;\r\nuniform float cColor;\r\n//-------------------------------------------------------------------------\r\n// https://www.shadertoy.com/view/lt23D3\r\nfloat nsin(float a) { return 0.5+0.5*sin(a); }\r\nfloat ncos(float a) { return 0.5+0.5*cos(a); }\r\nfloat opS(float d2, float d1) { return max(-d1,d2); }\r\nfloat brushRand(vec2 co) { return rand(co); }\r\nfloat brushRand(float n) { return rand3(n); }\r\nfloat dtoa(float d, float amount) { return clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.0, 1.0); }\r\nfloat sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br) {\r\n  vec2 d = max(tl-uv, uv-br);\r\n  return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\r\n}\r\n// 0-1 1-0\r\nfloat smoothstep4(float e1, float e2, float e3, float e4, float val) {\r\n  return min(smoothstep(e1,e2,val), 1.0 - smoothstep(e3,e4,val));\r\n}\r\nvec2 brushHash(vec2 p) { return iqhash2vec(p); }\r\n// returns -0.5 to 1.5\r\nfloat brushNoise(vec2 p) {\r\n  const float K1 = 0.366025404; // (sqrt(3)-1)/2\r\n  const float K2 = 0.211324865; // (3-sqrt(3))/6 \r\n  vec2 i = floor(p + (p.x + p.y) * K1);\r\n  vec2 a = p - i + (i.x + i.y) * K2;\r\n  vec2 o = (a.x > a.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0); // vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\r\n  vec2 b = a - o + K2;\r\n  vec2 c = a - 1.0 + 2.0 * K2;\r\n  vec3 h = max(0.5 - vec3(dot(a,a), dot(b,b), dot(c,c)), 0.0);\r\n  vec3 n = h*h*h*h*vec3(dot(a, brushHash(i+0.0)), dot(b, brushHash(i+o)), dot(c, brushHash(i+1.0)));\r\n  return dot(n, vec3(70.0));\r\n}\r\nfloat brushNoise01(vec2 p) {\r\n  return clamp((brushNoise(p) + 0.5) * 0.5, 0.0, 1.0);\r\n}\r\n//-------------------------------------------------------------------------\r\nvec3 colorAxisAlignedBrushStroke(vec2 uv, vec2 uvPaper, vec3 inpColor, vec4 brushColor, vec2 p1, vec2 p2) {\r\n  // how far along is this point in the line. will come in handy.\r\n  vec2 posInLine = smoothstep(p1, p2, uv); // (uv-p1)/(p2-p1);\r\n  \r\n  // wobble it around, humanize\r\n  float wobbleAmplitude = cAmplitude;\r\n  uv.x += sin(posInLine.y * PI2 * cAngle) * wobbleAmplitude;\r\n  \r\n  // distance to geometry\r\n  float d = sdAxisAlignedRect(uv, p1, vec2(p1.x, p2.y));\r\n  d -= abs(p1.x - p2.x) * 0.5; // rounds out the end.\r\n  \r\n  // warp the position-in-line, to control the curve of the brush falloff.\r\n  posInLine = pow(posInLine, vec2((nsin(time*0.5) * 2.0) + 0.3));\r\n  \r\n  // brush stroke fibers effect\r\n  float strokeStrength = dtoa(d, 100.0);\r\n  float strokeAlpha = 0.0\r\n    + brushNoise01((p2-uv) * vec2(min(resolution.y,resolution.x)*0.25, 1.0)) // high freq fibers\r\n    + brushNoise01((p2-uv) * vec2(79.0, 1.0)) // smooth brush texture. lots of room for variation here, also layering.\r\n    + brushNoise01((p2-uv) * vec2(14.0, 1.0)) // low freq noise, gives more variation\r\n    ;\r\n  strokeAlpha *= cAlpha;\r\n  strokeAlpha = strokeAlpha * strokeStrength;\r\n  strokeAlpha = strokeAlpha - (1.0 - posInLine.y);\r\n  strokeAlpha = (1.0 - posInLine.y) - (strokeAlpha * (1.0 - posInLine.y));\r\n  \r\n  // fill texture.\r\n  float inkOpacity = 0.85 * cStrength;\r\n  float fillAlpha = (dtoa(abs(d), 90.0) * (1.0 - inkOpacity)) + inkOpacity;\r\n  \r\n  // paper bleed effect\r\n  // float amt = 140.0 + (brushRand(uvPaper.y) * 30.0) + (brushRand(uvPaper.x) * 30.0);\r\n  float amt = 140.0 + (brushRand(uvPaper.y) * 1.0) + (brushRand(uvPaper.x) * 1.0);\r\n  \r\n  float alpha = fillAlpha * strokeAlpha * brushColor.a * dtoa(d, amt);\r\n  alpha = clamp(alpha, 0.0, 1.0);\r\n  return mix(inpColor, brushColor.rgb, alpha);\r\n}\r\n//-------------------------------------------------------------------------\r\nvec3 colorBrushStroke(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 p1, vec2 p2, float lineWidth) {\r\n  // flatten the line to be axis-aligned\r\n  vec2 rectDimensions = p2 - p1;\r\n  float angle = atan(rectDimensions.x, rectDimensions.y);\r\n  mat2 rotMat = rotate2d(-angle);\r\n  p1 *= rotMat;\r\n  p2 *= rotMat;\r\n  float halfLineWidth = lineWidth / 2.0;\r\n  p1 -= halfLineWidth;\r\n  p2 += halfLineWidth;\r\n  vec3 ret = colorAxisAlignedBrushStroke(uv * rotMat, uv, inpColor, brushColor, p1, p2);\r\n  return ret;\r\n}\r\n",brushStrokeUniforms:{cWidth:{value:.3},cStrength:{value:.6},cAlpha:{value:.58},cAmplitude:{value:.24},cAngle:{value:0},cBrushStrokeX1:{value:-.4},cBrushStrokeY1:{value:.38},cBrushStrokeX2:{value:-.09},cBrushStrokeY2:{value:-.61},cColor:{value:1}},bubblesFrag:"if (cBubblesVariation >= 2.0) {\r\n  float delta = colDelta*2.0;\r\n  float l = length(pin.position);\r\n  float a = mod(atan(pin.position.x, pin.position.y), delta) - delta/4.0;\r\n  float c= clr2(l,a);\r\n  pout.color = c * mix(vec3(1.0), CLR, cColor);\r\n}\r\nelse {\r\n  float c = clr1(pin.position);\r\n  pout.color = c * mix(vec3(1.0), CLR, cColor);\r\n}",bubblesFragPars:"// https://www.shadertoy.com/view/Xl2Bz3\r\nuniform float cRadius;\r\nuniform float cWidth;\r\nuniform float cThickness;\r\nuniform float cColor;\r\nuniform float cBubblesVariation;\r\n#define TAU 6.28318530718\r\n#define CLR vec3(0.388, 0.843, 0.976)\r\n#define ROWS 9\r\n\r\n#define COLS1 20\r\n#define initialRad1 0.125\r\n#define waveCenter1 0.41\r\n#define waveWidth1 0.2\r\n#define es1 0.01\r\n#define dotRad1(x) TAU*x/float(COLS1)*0.4\r\n\r\n#define COLS2 12\r\n#define es2 4.0/resolution.y\r\n#define initialRad2 0.175\r\n#define waveCenter2 0.4325\r\n#define waveWidth2 0.205\r\n#define dotRad2(x) TAU*x/float(COLS2)*0.25\r\n#define colDelta PI/float(COLS2)\r\n\r\nfloat remap(float value, float minValue, float maxValue) {\r\n  return clamp((value - minValue) / (maxValue - minValue), 0.0, 1.0);\r\n}\r\n\r\nfloat calcRowRad1(int rowNum) {\r\n  float rad = initialRad1;\r\n  rad += max(0.0, sin(time*3.0)) * step(0.0, cos(time*3.0)) * 0.0705;\r\n  for (int i=0; i<ROWS; i++) {\r\n    if (i >= rowNum) break;\r\n    rad += dotRad1(rad) * 2.0;\r\n  }\r\n  return rad;\r\n}\r\n\r\nfloat calcRowRad2(int rowNum) {\r\n  float rad = initialRad2;\r\n  rad += max(0.0, sin(time*4.0)) * step(0.0, cos(time*4.0)) * 0.066;\r\n  for (int i=0; i<ROWS; i++) {\r\n    if (i >= rowNum) break;\r\n    rad += dotRad2(rad) * 1.33;\r\n  }\r\n  return rad;\r\n}\r\n\r\nfloat clr1(vec2 st) {\r\n  float clr = 0.0;\r\n  float colStep = TAU/float(COLS1);\r\n  for (int j=0; j<ROWS; j++) {\r\n    float rowRad = calcRowRad1(j);\r\n    for (int i=0; i<COLS1; i++) {\r\n      vec2 dotCenter = vec2(rowRad, 0.0) * rotate2d(float(i) * colStep + (colStep * 0.5 * mod(float(j), 2.0)));\r\n      float dotRad = dotRad1(rowRad);\r\n      float dotClr = 1.0 - smoothstep(dotRad - es1, dotRad, length(st - dotCenter));\r\n      float thickness = pow(remap(abs(length(dotCenter) - waveCenter1 * cRadius), 0.0, waveWidth1 * cWidth), 1.25*cThickness);\r\n      dotClr *= smoothstep(dotRad * thickness - es1, dotRad * thickness, length(st - dotCenter));\r\n      dotClr *= step(es1, 1.0 - thickness);\r\n      clr += dotClr;\r\n    }\r\n  }\r\n  return clr;\r\n}\r\n\r\nfloat clr2(float r, float a) {\r\n  vec2 st = vec2(r*cos(a), r*sin(a));\r\n  float clr = 0.0;\r\n  for (int j=0; j<ROWS; j++) {\r\n    float rowRad = calcRowRad2(j);\r\n    vec2 dotCenter = vec2(rowRad, 0.0) * rotate2d(colDelta * mod(float(j), 2.0));\r\n    float dotRad = dotRad2(rowRad);\r\n    float dotClr = smoothstep(dotRad, dotRad - es2, length(st - dotCenter));\r\n    float thickness = pow(remap(abs(length(dotCenter) - waveCenter2*cRadius), 0.0, waveWidth2*cWidth), 1.25*cThickness);\r\n    dotClr *= smoothstep(dotRad * thickness - es2, dotRad * thickness, length(st - dotCenter));\r\n    dotClr *= step(es2, 1.0 - thickness);\r\n    clr += dotClr;\r\n  }\r\n  return clr;\r\n}",bubblesUniforms:{cRadius:{value:1},cWidth:{value:1},cThickness:{value:1},cColor:{value:1},cBubblesVariation:{value:1}},causticsFrag:"mat3 m = mat3(-2,-1,2,3,-2,1,1,2,2);\r\nvec3 a = vec3(pin.coord/vec2(100.0*cScale), time/(max(4.5-cSpeed,0.001)))*m;\r\nvec3 b = a * m * .4;\r\nvec3 c = b * m * .3;\r\npout.color = vec3(pow(min(\r\n    min(length(.5-fract(a)), length(.5-fract(b))),\r\n    length(.5-fract(c))),7.0) * 25.0);\r\npout.color += mix(vec3(.0), vec3(.0,.35,.5), cColor);\r\n",causticsFragPars:"// https://www.shadertoy.com/view/MdKXDm\r\nuniform float cScale;\r\nuniform float cSpeed;\r\nuniform float cColor;",causticsUniforms:{cScale:{value:4},cSpeed:{value:2},cColor:{value:1}},cellFrag:'// http://glslsandbox.com/e#37373.0\r\nfloat t = fworley(pin.uv * resolution.xy / 1500.0) * cIntensity;\r\nt = pow(t, cPowerExponent);\r\n// t *= exp(-lengthSqr(abs(0.7 * pin.uv - 1.0)));\r\n// "pout.color = t * vec3(0.1, 1.5*t, 1.2*t + pow(t, 0.5-t));"\r\npout.color = vec3(t);',cellFragPars:"// http://glslsandbox.com/e#37373.0\r\nuniform float cIntensity;\r\nuniform float cPowerExponent;\r\nuniform float cSize;\r\n\r\nfloat lengthSqr(vec2 p) { return dot(p,p); }\r\n\r\nfloat cellNoise(vec2 p) {\r\n  return fract(sin(fract(sin(p.x) * 43.13311) + p.y) * 31.0011);\r\n}\r\n\r\nfloat worley(vec2 p) {\r\n  float d = 1e30;\r\n  for (int xo=-1; xo <= 1; ++xo) {\r\n    for (int yo=-1; yo <= 1; ++yo) {\r\n      vec2 tp = floor(p) + vec2(xo, yo);\r\n      d = min(d, lengthSqr(p - tp - vec2(cellNoise(tp))));\r\n    }\r\n  }\r\n  return 5.0 * exp(-4.0 * abs(2.0*d - 1.0));\r\n}\r\n\r\nfloat fworley(vec2 p) {\r\n  return sqrt(sqrt(sqrt(\r\n    1.0 * // light\r\n//     worley(p*5.0 + 0.3 + time * 0.525) * \r\n    sqrt(worley(p * 50.0 / cSize + 0.3 + time * -0.15)) * \r\n//     sqrt(sqrt(worley(p * -10.0 + 9.3))) )));\r\n    1.0 )));\r\n}",cellNoiseFrag:"vec2 p = pin.uv - time*0.1;\r\nfloat lum = iqnoise(p * 48.0 * cNoiseFrequency + 0.5, 0.0, 0.0);\r\npout.color = vec3(lum);\r\n\r\nfloat graph = iqnoise(p.xx * 48.0 * cNoiseFrequency + 0.5, 0.0, 0.0);",cellNoiseFragPars:"// dummy",cellUniforms:{cIntensity:{value:1},cPowerExponent:{value:1},cSize:{value:1}},checkerFrag:"float scale = min(resolution.x, resolution.y);\r\nfloat width = resolution.x / scale;\r\nfloat height = resolution.y / scale;\r\nvec2 xy = pin.coord / scale - vec2(width/2.0, height/2.0);\r\nxy = vec2(xy) * rotate2d(radians(time*5.0));\r\n\r\nfloat tile = floor(sin(xy.x*cWidth) * sin(xy.y*cHeight) + 1.0);\r\npout.color = vec3(tile);\r\n",checkerFragPars:"uniform float cWidth;\r\nuniform float cHeight;",checkerUniforms:{cWidth:{value:50},cHeight:{value:50}},circleFrag:"// float t = 1.1 - length(pin.mouse - pin.position);\r\nfloat t = cRadius - length(pin.position);\r\nt = pow(t, cPowerExponent);\r\npout.color = vec3(t);",circleFragPars:"uniform float cRadius;\r\nuniform float cPowerExponent;",circleUniforms:{cRadius:{value:1.1},cPowerExponent:{value:1}},cloud2Frag:"vec2 ndc = 2.0 * pin.coord.xy / resolution.xy - 1.0;\r\nvec3 col = render(ndc, resolution.y / resolution.x);\r\npout.color = sqrt(col);",cloud2FragPars:"uniform float cIntensity;\r\nuniform float cDensity;\r\nuniform float cThickness;\r\nuniform float cColor;\r\nconst vec3 sunDir = normalize(vec3(-0.6, 0.4, 0.6));\r\n\r\nfloat cloudsHash(float n) { return fract(sin(n)*43578.5453123); }\r\nfloat cloudsNoise(in vec3 x) {\r\n  vec3 p = floor(x);\r\n  vec3 f = fract(x);\r\n  f = f*f*(3.0-2.0*f);\r\n  float n = p.x + p.y*157.0 + 113.0*p.z;\r\n  return 2.0 * mix(mix(mix(cloudsHash(n+0.0), cloudsHash(n+1.0), f.x),\r\n                       mix(cloudsHash(n+157.0), cloudsHash(n+158.0), f.x), f.y),\r\n                   mix(mix(cloudsHash(n+113.0), cloudsHash(n+114.0), f.x),\r\n                       mix(cloudsHash(n+270.0), cloudsHash(n+271.0), f.x), f.y), f.z)-1.0;\r\n}\r\nfloat cloudsFbm(in vec3 pos, int layers, float AM, float FM) {\r\n  float sum = 0.0;\r\n  float amplitude = 1.0;\r\n  for (int i=0; i<16; ++i) {\r\n    if (i >= layers) break;\r\n    sum += amplitude * cloudsNoise(pos);\r\n    amplitude *= AM;\r\n    pos *= FM;\r\n  }\r\n  return sum;\r\n}\r\nfloat clouds(in vec3 p) {\r\n  return 0.01 * cloudsFbm(0.9*vec3(0.2,0.2,0.3)*(p+vec3(0.0,0.0,3.0*time)), 7, 0.5, 4.0);\r\n}\r\nvec2 renderNoise(in vec3 ro, in vec3 rd) {\r\n  float tmin = 10.0;\r\n  float tmax = 10.0 + 10.0*cDensity;\r\n  float delta = 0.1;\r\n  float sum = 0.0;\r\n  float t = tmin;\r\n  for (int i=0; i<100; ++i) {\r\n    if (t >= tmax) break;\r\n    vec3 pos = ro + t*rd;\r\n    float d = max(0.0, clouds(pos));\r\n    sum = sum*(1.0-d)+d;\r\n    if (sum > 0.99) break;\r\n    t += delta;\r\n  }\r\n  return vec2(sum, t);\r\n}\r\nfloat shadeClouds(in vec3 ro, in vec3 rd) {\r\n  float sum = 0.0;\r\n  float t = 0.0;\r\n  float delta = 0.1;\r\n  for (int i=0; i<5; ++i) {\r\n    vec3 pos = ro + rd*t;\r\n    float d = max(0.0, clouds(pos));\r\n    sum = sum*(1.0-d)+d;\r\n    if (sum > 0.99) break;\r\n    t += delta;\r\n  }\r\n  return sum;\r\n}\r\nvec3 render(in vec3 ro, in vec3 rd) {\r\n  //const vec3 sky = vec3(0.4, 0.6, 1.0);\r\n  const vec3 sky = vec3(0.0, 0.0, 0.0);\r\n  //vec3 att = vec3(0.2, 0.5, 0.9);\r\n  //vec3 att = vec3(0.0, 0.0, 0.0);\r\n  vec3 att = mix(vec3(0.0), vec3(0.2, 0.5, 0.9), cColor);\r\n  vec2 ns = renderNoise(ro, rd);\r\n  vec3 pos = ro + rd*ns.y;\r\n  float shad = 1.0; // 0.9 * (1.0 - shadeClouds(pos + sunDir*0.1, sunDir));\r\n  float density = ns.x;\r\n  float inv = 1.0 - density;\r\n  float w = 1.8 * (0.5 * rd.y + 0.5) * cIntensity;\r\n  vec3 cl = shad * w * 1.0 * mix(vec3(1.0), inv*att, sqrt(density));\r\n  if (density < 0.1) return mix(sky, cl, max(0.0, density)*10.0*cThickness);\r\n  return cl;\r\n}\r\nvec3 render(vec2 ndc, float aspectRatio) {\r\n  vec3 o = vec3(0.0, 0.0, 0.0);\r\n  const float fov = 2.0 * PI / 3.0;\r\n  const float scaleX = tan(fov / 2.0);\r\n  vec3 right = vec3(1.0, 0.0, 0.0) * scaleX;\r\n  vec3 forward = vec3(0.0, 0.0, 1.0);\r\n  vec3 up = vec3(0.0, 1.0, 0.0) * scaleX * aspectRatio;\r\n  vec3 rd = normalize(forward + ndc.x*right + ndc.y*up);\r\n  return render(o, rd);\r\n}",cloud2Uniforms:{cDensity:{value:1},cThickness:{value:1},cIntensity:{value:1},cColor:{value:1}},cloudFrag:"// https://www.shadertoy.com/view/XsfXW8 by FabriceNeyret2\r\n\r\nvec2 uv = pin.position;\r\n// float z = -PI/2.0*cCameraTilt;\r\nfloat z = -3.14/2.0*cCameraTilt;\r\n// ks = 1.0; ps = 3.0; ki=0.9; pi=3.0;\r\nfloat t = -PI/2.0*cCameraPan;\r\n// t = -PI/2.0 * mouse.x;\r\n// z = -PI/2.0 * mouse.y;\r\n\r\nvec3 O = vec3(-15.0*cos(t)*cos(z), 15.0*sin(t)*cos(z), 15.0*sin(z)); // camera\r\nfloat compas = t-0.2 * uv.x;\r\nvec2 dir = vec2(cos(compas), sin(compas));\r\n\r\nmat3 M = lookat(O, vec3(0.0), 5.0);\r\n// vec2 dx = vec2(1.0, 0.0);\r\ndrawObj(O, M, uv, 2, pout.color);\r\n// drawObj(O, M, 1.5*(uv+dx), 0, pout.color);\r\n// drawObj(O, M, 1.5*(uv-dx), 1, pout.color);\r\n// pout.color = vec3(1.0, 0.0, 0.0);",cloudFragPars:"// https://www.shadertoy.com/view/XsfXW8 by FabriceNeyret2\r\n\r\nuniform float cCameraTilt;\r\nuniform float cCameraPan;\r\nuniform float cWidth;\r\nuniform float cHeight;\r\nuniform float cDepth;\r\nuniform float cIntensity;\r\nuniform float cLightX;\r\nuniform float cLightY;\r\nuniform float cLightZ;\r\nuniform float cAmbient;\r\nuniform float cSmoothness;\r\nuniform float cSmoothnessPower;\r\nuniform float cThickness;\r\nuniform float cThicknessPower;\r\n// vec3 R = vec3(2.0, 3.0, 2.0);\r\n// vec3 L = normalize(vec3(-0.4, 0.0, 1.0));\r\n// #define AMBIENT 0.1\r\n// float t = time;\r\n\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n ) {    // in [0,1]\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x ) { // in [0,1]\r\n  vec3 p = floor(x);\r\n  vec3 f = fract(x);\r\n\r\n  f = f*f*(3.0-2.0*f);\r\n\r\n  float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n  float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                      mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                  mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                      mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n  return res;\r\n}\r\n\r\nfloat fbm( vec3 p ) {    // in [0,1]\r\n  p += time;\r\n  float f;\r\n  f  = 0.5000*noise( p ); p = m*p*2.02;\r\n  f += 0.2500*noise( p ); p = m*p*2.03;\r\n  f += 0.1250*noise( p ); p = m*p*2.01;\r\n  f += 0.0625*noise( p );\r\n  return f;\r\n}\r\n\r\nfloat snoise2(in vec3 x) { // in [-1,1]\r\n  return 2.0 * noise(x) - 1.0;\r\n}\r\n\r\nfloat sfbm( vec3 p ) {    // in [0,1]\r\n  p += time;\r\n  float f;\r\n  f  = 0.5000*snoise2( p ); p = m*p*2.02;\r\n  f += 0.2500*snoise2( p ); p = m*p*2.03;\r\n  f += 0.1250*snoise2( p ); p = m*p*2.01;\r\n  f += 0.0625*snoise2( p );\r\n  return f;\r\n}\r\n\r\n// --- view matrix when looking T from O with [-1,1]x[-1,1] screen at dist d\r\nmat3 lookat(vec3 O, vec3 T, float d) {\r\n  mat3 M;\r\n  vec3 OT = normalize(T-O);\r\n  M[0] = OT;\r\n  M[2] = normalize(vec3(0.0, 0.0, 1.0)-OT.z*OT)/d;\r\n  M[1] = cross(M[2], OT);\r\n  return M;\r\n}\r\n\r\n// --- ray -  ellipsoid intersection\r\n// if true, return P,N and thickness l\r\nbool intersectEllipsoid(vec3 R, vec3 O, vec3 D, out vec3 P, out vec3 N, out float l) {\r\n  vec3 OR = O/R, DR = D/R; // to space where ellipsoid is a sphere\r\n// P=O+tD & |P|=1 -> solve t in O^2 + 2(O.D)t + D^2.t^2 = 1\r\n  float OD = dot(OR,DR), OO = dot(OR,OR), DD = dot(DR,DR);\r\n  float d = OD*OD - (OO-1.0)*DD;\r\n\r\n  if (!((d >= 0.0) && (OD < 0.0) && (OO > 1.0))) return false;\r\n// ray intersects the ellipsoid (and not in our back)\r\n// note that t>0 <=> -OD>0 &  OD^2 > OD^-(OO-1.0)*DD -> |O|>1\r\n\r\n  float t = (-OD-sqrt(d))/DD;\r\n// return intersection point, normal and distance\r\n  P = O + t*D;\r\n  N = normalize(P/(R*R));\r\n  l = 2.0 * sqrt(d)/DD;\r\n\r\n  return true;\r\n}\r\n\r\n// --- Gardner textured ellipsoids (sort of)\r\n// 's' index corresponds to Garner faked silhouette\r\n// 't' index corresponds to interior term faked by mid-surface\r\n\r\n// float ks, ps, ki, pi; // smoothness/thickness parameters\r\n// float l;\r\n\r\nvoid drawObj(vec3 O, mat3 M, vec2 pos, int mode, inout vec3 color) {\r\n  vec3 R = vec3(3.0*cDepth, 3.0*cWidth, 3.0*cHeight);\r\n  vec3 D = normalize(M*vec3(1.0,pos)); // ray\r\n  vec3 L = normalize(vec3(cLightX, cLightY, cLightZ));\r\n\r\n  vec3 P, N; float l;\r\n  if (!intersectEllipsoid(R, O, D, P, N, l)) return;\r\n\r\n  vec3 Pm = P + 0.5 * l * D; // 0.5: deepest point inside cloud.\r\n  vec3 Nm = normalize(Pm/(R*R)); // it's normal\r\n  vec3 Nn = normalize(P/R);\r\n  float nl = clamp(dot(N,L), 0.0, 1.0) * cIntensity; // ratio of light-facing (for lighting)\r\n  float nd = clamp(-dot(Nn,D), 0.0, 1.0); // ratio of camera-facing (for silhouette)\r\n  float ns = fbm(P), ni = fbm(Pm+10.0);\r\n  float A, l0 = 3.0;\r\n//   l += l*(l/l0-1.0)/(1.0+l*l/(l0*l0)); // optical depth modified at silhouette\r\n  l = clamp(l-6.0*ni, 0.0, 1e10);\r\n  float As = pow(cSmoothness*nd, cSmoothnessPower); // silhouette\r\n  float Ai = 1.0 - pow(cThickness, cThicknessPower*l); // interior\r\n\r\n  As = clamp(As-ns, 0.0, 1.0)*2.0; // As = 2.0*pow(As, 0.6)\r\n  if (mode == 2) {\r\n    A = 1.0 - (1.0 - As)*(1.0 - Ai); // mul Ti and Ts\r\n  } else {\r\n    A = (mode == 0) ? Ai : As;\r\n  }\r\n\r\n  A = clamp(A, 0.0, 1.0);\r\n  nl = 0.8 * (nl + ((mode == 0) ? fbm(Pm-10.0) : fbm(P+10.0)));\r\n\r\n#if 0 // noise bump\r\n  N = normalize(N - 0.1*(dFdx(A)*M[1] + dFdy(A)*M[2])*resolution.y);\r\n  nl = clamp(dot(N,L), 0.0, 1.0);\r\n#endif\r\n\r\n  vec3 col = vec3(mix(nl, 1.0, cAmbient));\r\n  color = mix(color, col, A);\r\n}",cloudsFrag:"// https://www.shadertoy.com/view/XslGRr\r\n\r\nvec2 p = (-resolution + 2.0*pin.coord) / resolution.y;\r\nvec2 m = mouse.xy / resolution.xy;\r\nvec3 ro = 4.0*normalize(vec3(sin(3.0*m.x), 0.4*m.y, cos(3.0*m.x)));\r\nvec3 ta = vec3(0.0,-1.0,0.0);\r\nmat3 ca = setCamera(ro, ta, 0.0);\r\nvec3 rd = ca*normalize(vec3(p.xy,1.5));\r\npout.color = render(ro, rd).xyz;",cloudsFragPars:"// https://www.shadertoy.com/view/XslGRr\r\n\r\nuniform sampler2D tNoise;\r\n\r\nfloat noise(in vec3 x) {\r\n  vec3 p = floor(x);\r\n  vec3 f = fract(x);\r\n  f = f*f*(3.0-2.0*f);\r\n  vec2 uv = (p.xy + vec2(37.0, 17.0)*p.z) + f.xy;\r\n  uv = (uv+0.5)/256.0;\r\n  uv = vec2(uv.x, -uv.y);\r\n  vec2 rg = texture2D(tNoise, uv).yx;\r\n  return -1.0 + 2.0*mix(rg.x, rg.y, f.z);\r\n}\r\n\r\nfloat map5(in vec3 p) {\r\n  vec3 q = p - vec3(0.0, 0.1, 1.0) * time;\r\n  float f;\r\n  f  = 0.50000*noise(q); q = q*2.02;\r\n  f += 0.25000*noise(q); q = q*2.03;\r\n  f += 0.12500*noise(q); q = q*2.01;\r\n  f += 0.06250*noise(q); q = q*2.02;\r\n  f += 0.03125*noise(q);\r\n  return clamp(1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0);\r\n}\r\n\r\nfloat map4(in vec3 p) {\r\n  vec3 q = p - vec3(0.0, 0.1, 1.0) * time;\r\n  float f;\r\n  f  = 0.50000*noise(q); q = q*2.02;\r\n  f += 0.25000*noise(q); q = q*2.03;\r\n  f += 0.12500*noise(q); q = q*2.01;\r\n  f += 0.06250*noise(q);\r\n  return clamp(1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0);\r\n}\r\n\r\nfloat map3(in vec3 p) {\r\n  vec3 q = p - vec3(0.0, 0.1, 1.0) * time;\r\n  float f;\r\n  f  = 0.50000*noise(q); q = q*2.02;\r\n  f += 0.25000*noise(q); q = q*2.03;\r\n  f += 0.12500*noise(q);\r\n  return clamp(1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0);\r\n}\r\n\r\nfloat map2(in vec3 p) {\r\n  vec3 q = p - vec3(0.0, 0.1, 1.0) * time;\r\n  float f;\r\n  f  = 0.50000*noise(q); q = q*2.02;\r\n  f += 0.25000*noise(q);\r\n  return clamp(1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0);\r\n}\r\n\r\nvec3 sundir = normalize(vec3(-1.0, 0.0, -1.0));\r\n\r\nvec4 integrate(in vec4 sum, in float dif, in float den, in vec3 bgcol, in float t) {\r\n// lighting\r\n  vec3 lin = vec3(0.65,0.7,0.75)*1.4 + vec3(1.0,0.6,0.3)*dif;\r\n  vec4 col = vec4(mix(vec3(1.0,0.95,0.8), vec3(0.25,0.3,0.35), den), den);\r\n  col.xyz *= lin;\r\n  col.xyz = mix(col.xyz, bgcol, 1.0-exp(-0.003*t*t));\r\n// front to back blending\r\n  col.a *= 0.4;\r\n  col.rgb *= col.a;\r\n  return sum + col*(1.0-sum.a);\r\n}\r\n\r\n#define MARCH(STEPS,MAPLOD) for(int i=0; i<STEPS; i++) { vec3 pos = ro + t*rd; if (pos.y<-3.0 || pos.y>2.0 || sum.a > 0.99) break; float den = MAPLOD(pos); if (den>0.01) { float dif = clamp((den - MAPLOD(pos+0.3*sundir))/0.6, 0.0, 1.0); sum = integrate(sum, dif, den, bgcol, t); } t += max(0.05, 0.02*t); }\r\n// for (int i=0; i<STEPS; i++) {\r\n//   vec3 pos = ro + t*rd;\r\n//   if (pos.y<-3.0 || pos.y>2.0 || sum.a > 0.99) break;\r\n//   float den = MAPLOD(pos);\r\n//   if (den>0.01) {\r\n//     float dif = clamp((den - MAPLOD(pos+0.3*sundir))/0.6, 0.0, 1.0);\r\n//     sum = integrate(sum, dif, den, bgcol, t);\r\n//   }\r\n//   t += max(0.05, 0.02*t);\r\n// }\r\n\r\nvec4 raymarch(in vec3 ro, in vec3 rd, in vec3 bgcol) {\r\n  vec4 sum = vec4(0.0);\r\n  float t = 0.0;\r\n  MARCH(30,map5);\r\n  MARCH(30,map4);\r\n  MARCH(30,map3);\r\n  MARCH(30,map2);\r\n  return clamp(sum, 0.0, 1.0);\r\n}\r\n\r\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\r\n  vec3 cw = normalize(ta-ro);\r\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\r\n  vec3 cu = normalize(cross(cw,cp));\r\n  vec3 cv = normalize(cross(cu,cw));\r\n  return mat3(cu, cv, cw);\r\n}\r\n\r\nvec4 render(in vec3 ro, in vec3 rd) {\r\n// background sky\r\n  float sun = clamp(dot(sundir,rd), 0.0, 1.0);\r\n  vec3 col = vec3(0.6,0.71,0.75) - rd.y*0.2*vec3(1.0,0.5,1.0) + 0.15*0.5;\r\n  col += 0.2*vec3(1.0,0.6,0.1)*pow(sun,8.0);\r\n// clouds\r\n  vec4 res = raymarch(ro, rd, col);\r\n  col = col * (1.0-res.w) + res.xyz;\r\n// sun glare\r\n  col += 0.2*vec3(1.0,0.4,0.2)*pow(sun,3.0);\r\n  return vec4(col, 1.0);\r\n}",cloudsUniforms:{tNoise:{value:null}},cloudUniforms:{cCameraTilt:{value:.2},cCameraPan:{value:0},cWidth:{value:1},cHeight:{value:.65},cDepth:{value:.65},cLightX:{value:-.4},cLightY:{value:0},cLightZ:{value:1},cIntensity:{value:1},cAmbient:{value:.1},cSmoothness:{value:1},cSmoothnessPower:{value:3},cThickness:{value:.7},cThicknessPower:{value:3}},color:"float rgb2gray(vec3 c) {\r\n  return dot(c, vec3(0.3, 0.59, 0.11));\r\n}\r\n\r\n\r\nfloat rgb2l(vec3 c) {\r\n  float fmin = min(min(c.r, c.g), c.b);\r\n  float fmax = max(max(c.r, c.g), c.b);\r\n  return (fmax + fmin) * 0.5; // Luminance\r\n}\r\n\r\n\r\n// https://github.com/liovch/GPUImage/blob/master/framework/Source/GPUImageColorBalanceFilter.m\r\nvec3 rgb2hsl(vec3 c) {\r\n  vec3 hsl;\r\n  float fmin = min(min(c.r, c.g), c.b);\r\n  float fmax = max(max(c.r, c.g), c.b);\r\n  float delta = fmax - fmin;\r\n\r\n  hsl.z = (fmax + fmin) * 0.5; // Luminance\r\n\r\n  if (delta == 0.0) {  // This is a gray, no chroma...\r\n    hsl.x = 0.0; // Hue\r\n    hsl.y = 0.0; // Saturation\r\n  } else { // Chromatic data...\r\n    if (hsl.z < 0.5) {\r\n      hsl.y = delta / (fmax + fmin); // Saturation\r\n    } else {\r\n      hsl.y = delta / (2.0 - fmax - fmin); // Saturation\r\n    }\r\n\r\n    float deltaR = (((fmax - c.r) / 6.0) + (delta / 2.0)) / delta;\r\n    float deltaG = (((fmax - c.g) / 6.0) + (delta / 2.0)) / delta;\r\n    float deltaB = (((fmax - c.b) / 6.0) + (delta / 2.0)) / delta;\r\n\r\n    if (c.r == fmax) {\r\n      hsl.x = deltaB - deltaG; // Hue\r\n    } else if (c.g == fmax) {\r\n      hsl.x = (1.0 / 3.0) + deltaR - deltaB; // Hue\r\n    } else if (c.b == fmax) {\r\n      hsl.x = (2.0 / 3.0) + deltaG - deltaR; // Hue\r\n    }\r\n\r\n    if (hsl.x < 0.0) {\r\n      hsl.x += 1.0; // Hue\r\n    } else if (hsl.x > 1.0) {\r\n      hsl.x -= 1.0; // Hue\r\n    }\r\n  }\r\n  return hsl;\r\n}\r\n\r\n\r\nfloat hue2rgb(float f1, float f2, float hue) {\r\n  if (hue < 0.0) {\r\n    hue += 1.0;\r\n  } else if (hue > 1.0) {\r\n    hue -= 1.0;\r\n  }\r\n  float res;\r\n  if ((6.0*hue) < 1.0) {\r\n    res = f1 + (f2-f1) * 6.0 * hue;\r\n  } else if ((2.0 * hue) < 1.0) {\r\n    res = f2;\r\n  } else if ((3.0 * hue) < 2.0) {\r\n    res = f1 + (f2-f1) * ((2.0/3.0) - hue) * 6.0;\r\n  } else {\r\n    res = f1;\r\n  }\r\n  return res;\r\n}\r\n\r\n\r\nvec3 hsl2rgb(vec3 hsl) {\r\n  vec3 rgb;\r\n  if (hsl.y == 0.0) {\r\n    rgb = vec3(hsl.z); // Luminace\r\n  } else {\r\n    float f2;\r\n    if (hsl.z < 0.5) {\r\n      f2 = hsl.z * (1.0 + hsl.y);\r\n    } else {\r\n      f2 = (hsl.z + hsl.y) - (hsl.y * hsl.z);\r\n    }\r\n    float f1 = 2.0 * hsl.z - f2;\r\n    rgb.r = hue2rgb(f1, f2, hsl.x + (1.0/3.0));\r\n    rgb.g = hue2rgb(f1, f2, hsl.x);\r\n    rgb.b = hue2rgb(f1, f2, hsl.x - (1.0/3.0));\r\n  }\r\n  return rgb;\r\n}\r\n\r\n\r\nvec3 hsv2rgb(vec3 c) {\r\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\r\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\r\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\r\n}",colorBalanceFrag:"// http://stackoverflow.com/questions/23213925/interpreting-color-function-and-adjusting-pixels-values\r\n// https://gist.github.com/liovch/3168961\r\n// https://github.com/liovch/GPUImage/blob/master/framework/Source/GPUImageColorBalanceFilter.m\r\nvec4 texel = texture2D(tDiffuse, pin.uv);\r\n\r\nfloat lightness = rgb2l(texel.rgb);\r\n\r\nconst float a = 0.25;\r\nconst float b = 0.333;\r\nconst float scale = 0.7;\r\n\r\nfloat c1 = clamp((lightness - b) / -a + 0.5, 0.0, 1.0);\r\nfloat c2 = clamp((lightness - b) / a + 0.5, 0.0, 1.0);\r\nfloat c3 = clamp((lightness + b - 1.0) / -a + 0.5, 0.0, 1.0);\r\nfloat c4 = clamp((lightness + b - 1.0) / a + 0.5, 0.0, 1.0);\r\nvec3 shadows = cColorBalanceShadows * (c1 * scale);\r\nvec3 midtones = cColorBalanceMidtones * (c2 * c3 * scale);\r\nvec3 highlights = cColorBalanceHighlights * (c4 * scale);\r\n\r\nvec3 newColor = texel.rgb + shadows + midtones + highlights;\r\nnewColor = clamp(newColor, 0.0, 1.0);\r\n\r\nif (cColorBalancePreserveLuminosity) {\r\n  vec3 newHSL = rgb2hsl(newColor);\r\n  pout.color = hsl2rgb(vec3(newHSL.x, newHSL.y, lightness));\r\n} else {\r\n  pout.color = newColor.xyz;\r\n}\r\npout.opacity = texel.w;",colorBalanceFragPars:"uniform vec3 cColorBalanceShadows;\r\nuniform vec3 cColorBalanceMidtones;\r\nuniform vec3 cColorBalanceHighlights;\r\nuniform bool cColorBalancePreserveLuminosity;",colorBalanceUniforms:{cColorBalanceShadows:{value:new r.Vector3(0,0,0)},cColorBalanceMidtones:{value:new r.Vector3(0,0,0)},cColorBalanceHighlights:{value:new r.Vector3(0,0,0)},cColorBalancePreserveLuminosity:{value:!1}},common:"precision highp float;\r\nprecision highp int;\r\n#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define INV_PI 0.31830988618\r\n#define INV_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n\r\n// handy value clamping to 0 - 1 range\r\n// #define saturate(a) clamp(a, 0.0, 1.0)\r\n#ifndef saturate\r\n#define saturate( a ) clamp( a, 0.0, 1.0 )\r\n#endif\r\n#define whiteCompliment(a) (1.0 - saturate(a))\r\n\r\n\r\nfloat pow2(const in float x) { return x*x; }\r\nfloat pow3(const in float x) { return x*x*x; }\r\nfloat pow4(const in float x) { float x2 = x*x; return x2*x2; }\r\nfloat pow5(const in float x) { float x2 = x*x; return x2*x2*x; }\r\nfloat averate(const in vec3 color) { return dot(color, vec3(0.3333)); }\r\n\r\nmat2 rotate2d(float angle) {\r\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\r\n}\r\n\r\nstruct PSInput {\r\n  vec2 position;\r\n  vec2 mouse;\r\n  vec2 coord;\r\n  vec2 uv;\r\n};\r\n\r\nstruct PSOutput {\r\n  vec3 color;\r\n  float opacity;\r\n};\r\n",coneFrag:"vec2 n = normalize(cDirection);\r\nfloat len = length(cDirection);\r\nvec2 pos = pin.position - (-cDirection);\r\nfloat t = (dot(pos, n) * 0.5) / len;\r\n// t /= (length(pin.position) * len * 0.5);\r\nt /= (length(pos) * len * 0.5);\r\nt = pow(abs(t), cPowerExponent);\r\npout.color = vec3(t);",coneFragPars:"uniform vec2 cDirection;\r\nuniform float cPowerExponent;",coneUniforms:{cDirection:{value:new r.Vector2(0,1)},cPowerExponent:{value:1}},copyFrag:"vec4 texel = texture2D(tDiffuse, pin.uv);\r\npout.color = texel.rgb;\r\npout.opacity = texel.a;",coronaFrag:"// https://www.shadertoy.com/view/XdV3DW by vamoss\r\n\r\nif (length(pin.position) < cRadius) {\r\n  pout.color = vec3(0.0);\r\n} else {\r\n  pout.color = burn(pin.position, cSize);\r\n}",coronaFragPars:"// https://www.shadertoy.com/view/XdV3DW by vamoss\r\n\r\nuniform float cIntensity;\r\nuniform float cRadius;\r\nuniform float cSize;\r\n\r\nfloat noise(vec3 uv, float res) {\r\n\tconst vec3 s = vec3(1e0, 1e2, 1e3);\r\n\tuv *= res;\r\n\tvec3 uv0 = floor(mod(uv, res))*s;\r\n\tvec3 uv1 = floor(mod(uv+1., res))*s;\r\n\tvec3 f = fract(uv); \r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\r\n\t              uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\r\n\tvec4 r = fract(sin(v*1e-1)*1e3);\r\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\r\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-1)*1e3);\r\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\r\n\treturn mix(r0, r1, f.z)*2.-1.;\r\n}\r\n\r\nvec3 burn(vec2 p, float size) {\r\n  float c1 = size * 4.0 - 3.0 * length(2.5 * p);\r\n  vec3 coord = vec3(atan(p.x, p.y) / PI2 + 0.5, length(p) * 0.4, 0.5);\r\n  for (int i=0; i<=3; i++) {\r\n    float power = exp2(float(i));\r\n    c1 += 0.2 * (1.5 / power) * noise(coord + vec3(0.0, -time*0.05, -time*0.01), power*16.0);\r\n  }\r\n  c1 *= cIntensity;\r\n  return vec3(c1);\r\n}",coronaUniforms:{cIntensity:{value:1},cRadius:{value:.3},cSize:{value:1}},crossFrag:"// https://www.shadertoy.com/view/ls3GRS\r\nfloat minBright = 0.01;\r\nfloat maxBright = 0.04;\r\nfloat magnitude = (minBright + abs(sin(time) * (maxBright - minBright)));\r\n\r\nvec2 dist = abs(pin.position);\r\nfloat longDist = max(dist.x, dist.y);\r\ndist += longDist / 40.0 * (1.0 - cIntensity) * 10.0;\r\nvec2 uv = magnitude / dist;\r\n\r\nfloat t = (uv.x + uv.y) / 2.0;\r\nt = pow(t, cPowerExponent);\r\npout.color = vec3(t);",crossFragPars:"uniform float cIntensity;\r\nuniform float cPowerExponent;",crossUniforms:{cIntensity:{value:.4},cPowerExponent:{value:1}},derivatives:"#extension GL_OES_standard_derivatives : enable\r\n",diamondGearFrag:"float g0 = gear(pin.position * mix(8.0, 1.0, cScale), cDiamondGearTeeth, time*0.1);\r\n// float g1 = gear(pin.position*4.0-vec2(2.85,0.0), 9.0, -time*0.2);\r\n// float g3 = gear(pin.position*3.0+vec2(2.35,0.0), 12.0, -time*0.15+0.125);\r\n// float sd = min(min(g0,g1),g3);\r\n// float val = smoothstep(0.0, 0.01, sd);\r\nfloat val = smoothstep(0.0, 0.01, g0);\r\npout.color = vec3(clamp(1.0 - 1.0*val, 0.0, 1.0));",diamondGearFragPars:"uniform float cScale;\r\nuniform float cWidth;\r\nuniform float cRadius;\r\nuniform float cDiamondGearTeeth;\r\nuniform float cDiamondGearMid;\r\n\r\nvec2 sd_line(vec2 pos, vec2 a, vec2 b) {\r\n  pos -= a;\r\n  vec2 d = b-a;\r\n  float l = length(d);\r\n  d /= l;\r\n  \r\n  float t = dot(d,pos);\r\n  vec2 p = d * clamp(t, 0.0, l);\r\n  vec2 perp = vec2(d.y, -d.x);\r\n  \r\n  return vec2(length(pos-p), dot(pos,perp));\r\n}\r\n\r\nfloat abs_min(float a, float b) {\r\n  return abs(a) < abs(b) ? a : b;\r\n}\r\n\r\nvec2 lmin(vec2 a, vec2 b) {\r\n  if (abs(a.x-b.x) < 0.0001) {\r\n    return a.y > b.y ? a : b;\r\n  }\r\n  return a.x < b.x ? a : b;\r\n}\r\n\r\nfloat to_sd(vec2 x) {\r\n  return x.x * sign(x.y);\r\n}\r\n\r\nfloat sd_diamond(vec2 pos, vec2 tail, vec2 tip, float width, float mid) {\r\n  vec2 d = tip-tail;\r\n  vec2 p = vec2(d.y,-d.x) * width * 0.5;\r\n  vec2 m = d*mid + tail;\r\n  vec2 la = sd_line(pos, tail, m+p);\r\n  vec2 lb = sd_line(pos, m+p, tip);\r\n  vec2 lc = sd_line(pos, tip, m-p);\r\n  vec2 ld = sd_line(pos, m-p, tail);\r\n  return to_sd(lmin(lmin(la,lb), lmin(lc,ld)));\r\n}\r\n\r\nvec2 to_polar(vec2 x) {\r\n  return vec2(length(x), atan(-x.y,-x.x) + 3.14159);\r\n}\r\n\r\nvec2 from_polar(vec2 x) {\r\n  return vec2(cos(x.y), sin(x.y)) * x.x;\r\n}\r\n\r\nvec2 radial_repeat(vec2 pos, float count) {\r\n  float offset = 0.5/count;\r\n  pos = to_polar(pos);\r\n  pos.y /= 2.0*3.14159;\r\n  pos.y += offset;\r\n  pos.y *= count;\r\n  pos.y = fract(pos.y);\r\n  pos.y /= count;\r\n  pos.y -= offset;\r\n  pos.y *= 2.0*3.14159;\r\n  pos = from_polar(pos);\r\n  return pos;\r\n}\r\n\r\nvec2 rotate(vec2 pos, float turns) {\r\n  pos = to_polar(pos);\r\n  pos.y += turns * 2.0 * 3.14159;\r\n  return from_polar(pos);\r\n}\r\n\r\nfloat gear(vec2 uv, float teeth, float turns) {\r\n  uv = rotate(uv, turns);\r\n  uv = radial_repeat(uv, teeth);\r\n  return sd_diamond(uv, vec2(0.0+cRadius,0.0), vec2(1.0,0.0), cWidth/teeth, cDiamondGearMid);\r\n}\r\n",diamondGearUniforms:{cScale:{value:1},cWidth:{value:4},cRadius:{value:.05},cDiamondGearMid:{value:.8},cDiamondGearTeeth:{value:18}},displacementFrag:"pout.color = vec3(displacement);",displacementFragPars:"varying float displacement;",displacementUniforms:{tDisplacement:{value:null}},displacementVert:"// attribute vec3 position;\r\n// attribute vec3 normal;\r\n// attribute vec3 uv;\r\nvarying float displacement;\r\nuniform sampler2D tDisplacement;\r\nvoid main() {\r\n  displacement = texture2D(tDisplacement, uv).x;\r\n  vec3 transformed = position + normal * displacement * 0.1;\r\n//   vec3 transformed = position;\r\n  vec4 hpos = projectionMatrix * modelViewMatrix * vec4(transformed, 1.0);\r\n  gl_Position = hpos;\r\n}",electricFrag:"float pauseFreq = cFrequency;\r\nfloat pauseScale = 1.0;\r\nfloat scaledTime = time * 0.5;\r\nscaledTime += 0.05 * pin.uv.x;\r\nfloat sinTime = sin(pauseFreq*scaledTime);\r\nfloat sinTimeOffset = sin(pauseFreq*scaledTime - 0.5*3.141);\r\nfloat timeStep = scaledTime + pauseScale * (sinTime/pauseFreq);\r\n\r\nvec2 p = pin.uv;\r\nvec4 c;\r\n\r\np *= 4.0;\r\np.x = 0.5 - timeStep*3.0;\r\np.y = 0.5 - timeStep*3.0;\r\nc = voronoi(p);\r\n\r\nfloat cellPos = (p.y+c.z) + timeStep * 3.0;\r\nvec2 uv = pin.uv;\r\nuv.x += 1.5*(2.0*c.x-0.33) * (uv.y-0.5);\r\nuv.x *= cScale;\r\n\r\np = uv;\r\np.y = max(p.y, 0.5);\r\np *= 12.0; // higher values zoom out further - don't go too high or the sine waves will become quite obvious...\r\np.x += timeStep*16.0;\r\np.y += timeStep*32.0;\r\nc = voronoi(p);\r\n\r\n// pout.color = 0.5*vec4(c.x);\r\n\r\nfloat d= 0.0;\r\nfloat edgeScale = 1.0-2.0*abs(pin.uv.x-0.5);\r\nfloat scaleMulti = pow(0.5*sinTime + 0.5, 2.0);\r\nfloat dScale = 2.0*edgeScale*(0.25+0.75*pow(0.5*sinTimeOffset+0.5,2.0));\r\n\r\np.y = 0.5*12.0 - timeStep*6.0;\r\nc = dScale * voronoi(p);\r\nd = (uv.y + c.x-0.75);\r\n\r\np.x = uv.x*12.0 - timeStep*6.0;\r\np.y = 4.5*12.0 - timeStep*3.0;\r\nc = dScale*voronoi(p);\r\nd = mix(d, (uv.y-c.x-0.25), 0.5);\r\nd = 1.0-abs(d);\r\n\r\n// pout.color = vec3(d);\r\n\r\nfloat lineWidth = d+0.025*scaleMulti*edgeScale;\r\nvec4 outcolor = mix(vec4(0,1,1.5,1), vec4(1,2,2.0,1), scaleMulti)*smoothstep(1.0, 1.005, lineWidth);\r\noutcolor += edgeScale*pow(scaleMulti*smoothstep(0.75, 1.005, lineWidth), 16.0) * 0.5*vec4(.8,1,2.0,1);\r\noutcolor += 0.5*vec4(.1, 0.05, 0.2, 1);\r\n\r\npout.color = outcolor.xyz;",electricFragPars:"uniform float cFrequency;\r\nuniform float cScale;\r\n\r\nvec2 hash2(vec2 p) {\r\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\r\n}\r\n\r\nvec4 voronoi(in vec2 x) {\r\n    vec2 n = floor(x);\r\n    vec2 f = fract(x);\r\n    vec2 o;\r\n    // first pass: regular voronoi\r\n    vec2 mg, mr;\r\n    float oldDist;\r\n\r\n    float md = 8.0;\r\n    for (int j=-1;j<=1; j++) {\r\n        for (int i=-1; i<=1; i++) {\r\n            vec2 g = vec2(float(i), float(j));\r\n            o = hash2(n+g);\r\n            vec2 r = g + o - f;\r\n            float d = dot(r,r);\r\n            if (d<md) {\r\n                md = d;\r\n                mr = r;\r\n                mg = g;\r\n            }\r\n        }\r\n    }\r\n\r\n    oldDist = md;\r\n\r\n    // second pass: distance to borders\r\n    md = 8.0;\r\n    for (int j=-2;j<=2; j++) {\r\n        for (int i=-2; i<=2; i++) {\r\n            vec2 g = vec2(float(i), float(j));\r\n            o = hash2(n+g);\r\n            vec2 r = g + o - f;\r\n            if (dot(mr-r,mr-r)>0.0001) {\r\n                md = min(md, dot(0.5*(mr+r), normalize(r-mr)));\r\n            }\r\n        }\r\n    }\r\n\r\n    return vec4(md, mr, oldDist);\r\n}",electricUniforms:{cFrequency:{value:20},cScale:{value:.25}},energyFrag:"vec2 uv = pin.position;\r\nvec3 ro = vec3(uv, sin(time)*2.0-mix(100.0, 20.0, cScale));\r\nvec3 rd = vec3(uv, 1.0);\r\nvec3 mp = ro;\r\nfloat shade = 0.0;\r\nconst vec4 shadow = vec4(0.3);\r\nfloat t = time;\r\nfloat cnt = 0.0;\r\nfor (int i=0; i<50; ++i) {\r\n  float md = map(mp);\r\n  if (md < 0.0001) {\r\n    break;\r\n  }\r\n  mp += rd*md*mix(2.0, 0.25, cDensity);\r\n  cnt += 1.0;\r\n}\r\n\r\nif (length(mp) > mix(10.0, 20.0, cThickness)) {\r\n  pout.color = vec3(0.0);\r\n} else {\r\n  float r = cnt/50.0;\r\n  vec3 col = vec3(hsv(vec3(st(length(mp)*0.01-time*0.2,6.0), 0.8, 1.0)));\r\n  col *= 1.0 - r*(1.0-r)*-1.0;\r\n  col *= length(mp-ro)*0.02;\r\n  col = 1.0 - col;\r\n  float gray = rgb2gray(col);\r\n  pout.color = mix(vec3(gray), col, cColor);\r\n}",energyFragPars:"// https://www.shadertoy.com/view/XdjcWc\r\nuniform float cPower;\r\nuniform float cDensity;\r\nuniform float cThickness;\r\nuniform float cScale;\r\nuniform float cFrequency;\r\nuniform float cColor;\r\n\r\n#define TAU 6.2831853\r\n\r\nfloat hlx(vec3 p) {\r\n  float m = TAU/mix(1.0, 5.0, cPower);\r\n  float t = time;\r\n  float a = mod(atan(p.y, p.x) - p.z*mix(0.5,1.5,cFrequency)+t, m) - 0.5*m;\r\n  float l = length(p.xy);\r\n  float r = 0.1 + 0.2 * (sin(abs(p.z*4.0) + t*4.0) * 0.5 + 0.5);\r\n  return length(vec2(a*l,length(p.xy) - (0.5+abs(p.z)*2.0)*(1.0 + sin(abs(p.z)-t*10.0)*0.5+0.5)*0.2))-r;\r\n}\r\n\r\nvec3 hsv(vec3 c) {\r\n  vec4 k = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\r\n  vec3 p = abs(fract(c.xxx+k.xyz)*6.0-k.www);\r\n  return c.z * mix(k.xxx, clamp(p-k.xxx, 0.0, 1.0), c.y);\r\n}\r\n\r\nfloat map(vec3 p) {\r\n  p.xy *= rotate2d(time*0.3 + length(p)*0.05);\r\n  p.yz *= rotate2d(time*0.5);\r\n  p.xz *= rotate2d(time*0.7);\r\n  float d = min(min(hlx(p.xyz), hlx(p.yzx)), hlx(p.zxy))*(1.0 + sin(length(p*1.0)-time*4.0)*0.8);\r\n  vec3 n = normalize(sign(p));\r\n  float d2 = max(length(max(abs(p)-vec3(1.0), 0.0)), dot(p,n)-2.3);\r\n  return d;//min(d,d2);\r\n}\r\n\r\nfloat st(float x, float m) { return floor(x*m)/m; }\r\n",energyUniforms:{cPower:{value:1},cDensity:{value:1},cThickness:{value:1},cScale:{value:1},cFrequency:{value:0},cColor:{value:1}},explosion2Frag:'// port from https://www.shadertoy.com/view/lsySzd\r\n// "Volumetric explosion" by Duke\r\n//-------------------------------------------------------------------------------------\r\n// Based on "Supernova remnant" (https://www.shadertoy.com/view/MdKXzc) \r\n// and other previous shaders \r\n// otaviogood\'s "Alien Beacon" (https://www.shadertoy.com/view/ld2SzK)\r\n// and Shane\'s "Cheap Cloud Flythrough" (https://www.shadertoy.com/view/Xsc3R4) shaders\r\n// Some ideas came from other shaders from this wonderful site\r\n// Press 1-2-3 to zoom in and zoom out.\r\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\r\n//-------------------------------------------------------------------------------------\r\n  \r\n// ro: ray origin\r\n// rd: direction of the ray\r\nvec3 rd = normalize(vec3((pin.coord.xy - 0.5*resolution.xy) / resolution.y, 1.0));\r\nvec3 ro = vec3(0.0, 0.0, -6.0);\r\n\r\n#ifdef DITHERING\r\nvec2 seed = pin.uv + fract(time);\r\n#endif\r\n\r\n// ld, td: local, total density\r\n// w: weighting factor\r\nfloat ld = 0.0, td = 0.0, w = 0.0;\r\n\r\n// t: length of the ray\r\n// d: distance function\r\nfloat d = 1.0, t = 0.0;\r\n\r\nconst float h = 0.1;\r\nvec4 sum = vec4(0.0);\r\nfloat min_dist = 0.0, max_dist = 0.0;\r\n\r\nif (raySphereIntersect(ro, rd, min_dist, max_dist)) {\r\n  t = min_dist * step(t, min_dist);\r\n  for (int i=0; i<86; i++) {\r\n\r\n    vec3 pos = ro + t*rd;\r\n\r\n    if (td > 0.9 || d < 0.12*t || t > 10.0 || sum.a > 0.99 || t > max_dist) break;\r\n\r\n    float d = map(pos);\r\n    d = abs(d) + 0.07;\r\n     // change this starting to control density\r\n    d = max(d, 0.03);\r\n\r\n     // point light calculations\r\n    vec3 ldst = vec3(0.0) - pos;\r\n    float lDist = max(length(ldst), 0.001);\r\n\r\n     // the color of light\r\n    vec3 lightColor = vec3(1.0, 0.5, 0.25);\r\n//     sum.rgb += (lightColor / exp(lDist*lDist*lDist*0.08)/30.0);// bloom\r\n    sum.rgb += (lightColor / exp(lDist*lDist*lDist*0.15)/(30.0 - 20.0 * cBloom));// bloom\r\n\r\n    if (d < h) {\r\n       // compute local density\r\n      ld = h - d;\r\n       // compute weighting factor\r\n      w = (1.0 - td) * ld;\r\n       // accumulate density\r\n      td += w + 1.0 / 200.0;\r\n\r\n      vec4 col = vec4(computeColor(td, lDist), td);\r\n       // emission\r\n      sum += sum.a * vec4(sum.rgb, 0.0) * cEmission / lDist;\r\n       // uniform scale density\r\n      col.a *= 0.2;\r\n       // colour by alpha\r\n      col.rgb *= col.a;\r\n       // alpha blend in contribution\r\n      sum = sum + col*(1.0 - sum.a);\r\n    }\r\n\r\n    td += 1.0 / 70.0;\r\n\r\n    #ifdef DITHERING\r\n    d = abs(d) * (0.8 + 0.2*rand2(seed*vec2(i)*0.123));\r\n    #endif\r\n     // trying to optimize step size\r\n//     t += max(d*0.25, 0.01);\r\n    t += max(d * 0.08 * max(min(length(ldst), d), 2.0), 0.01);\r\n  }\r\n// simple scattering\r\n//   sum *= 1.0 / exp(ld * 0.2) * 0.9;\r\n  sum *= 1.0 / exp(ld * 0.2) * 0.8;\r\n  sum = clamp(sum, 0.0, 1.0);\r\n  sum.xyz = sum.xyz * sum.xyz * (3.0 - 2.0 * sum.xyz);\r\n}\r\n\r\nvec3 gray = vec3(rgb2gray(sum.xyz));\r\nsum.xyz = mix(gray, sum.xyz, cColor);\r\n\r\n#ifdef TOENMAPPING\r\npout.color = toneMapFilmicALU(sum.xyz*2.02);\r\n#else\r\npout.color = sum.xyz;\r\n#endif',explosion2FragPars:'// port from https://www.shadertoy.com/view/lsySzd\r\n// "Volumetric explosion" by Duke\r\n//-------------------------------------------------------------------------------------\r\n// Based on "Supernova remnant" (https://www.shadertoy.com/view/MdKXzc) \r\n// and other previous shaders \r\n// otaviogood\'s "Alien Beacon" (https://www.shadertoy.com/view/ld2SzK)\r\n// and Shane\'s "Cheap Cloud Flythrough" (https://www.shadertoy.com/view/Xsc3R4) shaders\r\n// Some ideas came from other shaders from this wonderful site\r\n// Press 1-2-3 to zoom in and zoom out.\r\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\r\n//-------------------------------------------------------------------------------------\r\n\r\nuniform float cCameraPan;\r\nuniform float cExplosionSpeed;\r\nuniform float cExplosionDensity;\r\nuniform float cEmission;\r\nuniform float cBloom;\r\nuniform float cColor;\r\n\r\n// #define DITHERING\r\n// #define TOENMAPPING\r\n\r\n#define R(p, a) p=cos(a)*p + sin(a)*vec2(p.y,-p.x)\r\n\r\nvec3 hash(vec3 p) {\r\n  p = vec3(dot(p, vec3(127.1, 311.7, 74.7)),\r\n           dot(p, vec3(269.5, 183.3, 246.1)),\r\n           dot(p, vec3(113.5, 271.9, 124.6)));\r\n  return -1.0 + 2.0 * fract(sin(p)*43758.5453123);\r\n}\r\n\r\nfloat noise(in vec3 p) {\r\n  vec3 i = floor(p);\r\n  vec3 f = fract(p);\r\n  vec3 u = f*f*(3.0-2.0*f);\r\n  return mix(mix(mix(dot(hash(i + vec3(0.0,0.0,0.0)), f-vec3(0.0,0.0,0.0)),\r\n                     dot(hash(i + vec3(1.0,0.0,0.0)), f-vec3(1.0,0.0,0.0)), u.x),\r\n                 mix(dot(hash(i + vec3(0.0,1.0,0.0)), f-vec3(0.0,1.0,0.0)),\r\n                     dot(hash(i + vec3(1.0,1.0,0.0)), f-vec3(1.0,1.0,0.0)), u.x), u.y),\r\n             mix(mix(dot(hash(i + vec3(0.0,0.0,1.0)), f-vec3(0.0,0.0,1.0)),\r\n                     dot(hash(i + vec3(1.0,0.0,1.0)), f-vec3(1.0,0.0,1.0)), u.x),\r\n                 mix(dot(hash(i + vec3(0.0,1.0,1.0)), f-vec3(0.0,1.0,1.0)),\r\n                     dot(hash(i + vec3(1.0,1.0,1.0)), f-vec3(1.0,1.0,1.0)), u.x), u.y), u.z);\r\n}\r\n\r\nfloat fbm(vec3 p) {\r\n  return noise(p*0.6125)*0.5 + noise(p*0.125)*0.25 + noise(p*0.25)*0.125 + noise(p*0.4)*0.2;\r\n}\r\n\r\nfloat sphere(vec3 p, float r) {\r\n  return length(p)-r;\r\n}\r\n\r\n//==============================================================\r\n// otaviogood\'s noise from https://www.shadertoy.com/view/ld2SzK\r\n//--------------------------------------------------------------\r\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\r\n// It should work the same on all computers since it\'s not based on a hash function like some other noises.\r\n// It can be much faster than other noise functions if you\'re ok with some repetition.\r\nconst float nudge = 4.0; // size of perpendicular vector\r\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge); // pythagorean theorem on that perpendicular to maintain scale\r\nfloat spiralNoiseC(vec3 p) {\r\n  float n = -mod(time * 0.8 * cExplosionSpeed, -2.1); // noise amount\r\n  float iter = 2.0;\r\n  for (int i=0; i<8; i++) {\r\n     // add sin and cos scaled inverse with the frequency\r\n    n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter; // abs for a ridged look\r\n     // rotate by adding perpendicular and scaling down\r\n    p.xy += vec2(p.y, -p.x) * nudge;\r\n    p.xy *= normalizer;\r\n     // rotate on other axis\r\n    p.xz += vec2(p.z, -p.x) * nudge;\r\n    p.xz *= normalizer;\r\n     // increase the frequency\r\n    iter *= 1.733733;\r\n  }\r\n  return n;\r\n}\r\n\r\nfloat volumetricExplosion(vec3 p) {\r\n  float final = sphere(p, 4.0);\r\n//   final += expNoise(p*12.5)*0.2;\r\n  final += fbm(p*50.0 * cExplosionDensity);\r\n  final += spiralNoiseC(p.zxy*0.4132+333.0)*3.0; // 1.25\r\n  return final;\r\n}\r\n\r\nfloat map(vec3 p) {\r\n//   R(p.xz, mouse.x * 0.008 * PI * time*0.1);\r\n  R(p.xz, cCameraPan * PI2);\r\n  return volumetricExplosion(p/0.6)*0.6; // scale\r\n}\r\n\r\n// assing color to the media\r\nvec3 computeColor(float density, float radius) {\r\n// color based on density alone, gives impresion of occlusion within the media\r\n  vec3 result = mix(vec3(1.0, 0.9, 0.8), vec3(0.4, 0.15, 0.1), density);\r\n\r\n// color added to the media\r\n  vec3 colCenter = 7.0 * vec3(0.8, 1.0, 1.0);\r\n  vec3 colEdge = 1.5 * vec3(0.48, 0.53, 0.5);\r\n  result *= mix(colCenter, colEdge, min((radius + 0.05)/0.9, 1.15));\r\n  return result;\r\n}\r\n\r\nbool raySphereIntersect(vec3 org, vec3 dir, out float near, out float far) {\r\n  float b = dot(dir, org);\r\n  float c = dot(org, org) - 8.0;\r\n  float delta = b*b - c;\r\n  if (delta < 0.0) return false;\r\n  float deltasqrt = sqrt(delta);\r\n  near = -b - deltasqrt;\r\n  far = -b + deltasqrt;\r\n  return far > 0.0;\r\n}\r\n\r\n// Applies the filmic curve from John Hable\'s presentation\r\n// More details at : http://filmicgames.com/archives/75\r\nvec3 toneMapFilmicALU(vec3 c) {\r\n  c = max(vec3(0), c - vec3(0.004));\r\n  c = (c * (6.2*c + vec3(0.5))) / (c * (6.2 * c + vec3(1.7)) + vec3(0.06));\r\n  return c;\r\n}',explosion2Uniforms:{cCameraPan:{value:0},cExplosionSpeed:{value:1},cExplosionDensity:{value:1},cEmission:{value:.2},cBloom:{value:0},cColor:{value:1}},explosionFrag:"// https://www.shadertoy.com/view/Xd3GWn\r\n\r\n// downscale = 1.75;\r\n// grain = 2.7;\r\n// rolling_init_damp = 0.2;\r\n// ball_spread = 0.4;\r\n\r\n#ifdef LOW_Q\r\n  grain *= 1.0 + 0.1 * float(LOW_Q);\r\n  growth *= 1.0 - 0.1 * float(LOW_Q);\r\n  ballness *= 0.85;\r\n#endif\r\n\r\n  float t = getTime();\r\n\r\n// some global initialization.\r\n  setup();\r\n\r\n// get aspect corrected normalized pixel coordinate\r\n//   vec2 q = fragCoord.xy / resolution.xy;\r\n//   vec2 p = -1.0 + 2.0*q;\r\n//   p.x *= resolution.x / resolution.y;\r\n    \r\n  vec3 rayDir, cameraPos;\r\n  rayDir = computePixelRay( pin.position, cameraPos );\r\n\t\r\n  vec4 col = vec4(0.);\r\n  float d = 4000.0;\r\n    \r\n// does pixel ray intersect with exp bounding sphere?\r\n  vec2 boundingSphereInter = iSphere( cameraPos, rayDir, cExplosionRadius );\r\n  if ( boundingSphereInter.x > 0. ) {\r\n\t\t// yes, cast ray\r\n    col = raymarch( cameraPos, rayDir, boundingSphereInter, t, d );\r\n  }\r\n\t\r\n// smoothstep final color to add contrast\r\n//col.xyz = col.xyz*col.xyz*(3.0-2.0*col.xyz);\r\n//col.xyz = col.xyz*col.xyz*(2.0-col.xyz);\t// darker contrast\r\n  col.xyz = col.xyz*col.xyz*(1.0+cExplosionContrast*(1.0-col.xyz));\r\n\r\n// gamma\r\n//col.xyz = pow( col.xyz, vec3(1.25) );\r\n//col.a = pow( col.a, 1.5 );\r\n\r\n// from https://www.shadertoy.com/view/XdSXDc\r\n//col.rgb = clamp(pow(col.rgb, vec3(0.416667))*1.055 - 0.055,0.,1.); //cheap sRGB approx\r\n  \r\n// vec3 cloudcolor = vec3(.8,.8,.8);\r\n    \r\n//  #ifdef WITH_FUN\r\n//     // day-night cycling\r\n//     float dnt = fract(iGlobalTime / DAY_NIGHT_CYCLE_TIME);\r\n//     float day = 1.-smoothstep(.3, .5, dnt);\r\n//     float night = smoothstep(.8, 1., dnt);\r\n//     day += night;\r\n//     night = 1.-day;\r\n// \r\n//     // night setting\r\n//     float gray = back.r+back.g+back.b;\r\n//     vec3 corridorlight = night < .9 ? vec3(0.) :\r\n//         smoothstep( 1., 0., gray ) * (CORRIDOR_LIGHT);\t// this is so cute looking\r\n//     //vec3 nightcolor = pow(back.b, 5. * clamp(rayDir.y+.7, 1. - (ENLIGHTEN_PASSAGE), 1.)) * (NIGHT_COLORING);\r\n//     vec3 nightcolor = pow(back.b, 4.) * (NIGHT_COLORING);\r\n//     nightcolor *= smoothstep( -1., 1., -(gray-1.7) ) + .1;\r\n//     \r\n//  #ifdef STARS\r\n//     if ( gray > 2.999 )\t// luck, practically just the sky in the cubemap is pure white\r\n//     \tnightcolor += stars( rayDir );\r\n//  #endif\r\n// \r\n//     // faking some light on the floor from the explosion\r\n//     vec3 floorlight = (smoothstep( .3, .99, -rayDir.y ) * (FLOOR_LIGHT_STRENGTH) * smoothstep(.6, .0, t)) * colBottom.rgb;\r\n// \r\n//     cloudcolor *= smoothstep( -.5, 1., day );\r\n//     \r\n//     back.rgb = back.rgb * day + nightcolor * night + corridorlight + floorlight;\r\n//  #endif\r\n// \r\n// #ifdef WITH_FUN\r\n// #ifdef FOG\r\n//     back.rgb = clouds(back.rgb,cameraPos+vec3(0.,40.,0.), rayDir, 4000.0, iGlobalTime*3., cloudcolor);\r\n// #endif\r\n// #endif\r\n    \r\n// fragColor.xyz = mix( back.xyz, col.xyz, col.a );\r\n  pout.color = vec3(rgb2gray(mix( vec3(0.0), col.xyz, col.a )));\r\n//  fragColor.xyz = rayDir;\r\n//  fragColor.xyz = cameraPos;\r\n\r\n//fragColor.rgb = clouds(fragColor.rgb,cameraPos, rayDir, d, iGlobalTime*3., cloudcolor);\r\n\r\n// vignette\r\n// fragColor.rgb *= pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);",explosionFragPars:"// https://www.shadertoy.com/view/Xd3GWn\r\n\r\nuniform float cCameraTilt;\r\nuniform float cCameraPan;\r\nuniform float cExplosionRadius;\r\nuniform float cExplosionDownScale;\r\nuniform float cExplosionGrain;\r\nuniform float cExplosionSpeed;\r\nuniform float cExplosionBallness;\r\nuniform float cExplosionGrowth;\r\nuniform float cExplosionFade;\r\n// uniform float cExplosionThinoutSmooth;\r\nuniform float cExplosionDensity;\r\nuniform float cExplosionContrast;\r\nuniform float cExplosionRollingInitDamp;\r\nuniform float cExplosionRollingSpeed;\r\nuniform float cExplosionDelayRange;\r\nuniform float cExplosionBallSpread;\r\n\r\n// #define NOISE_LUT\r\n\r\n// In calcDens(), description mentions a bug which appeared with the old coloring.\r\n// #define OLD_COLORING\r\n\r\n// if not defined, mouse y will move camera\r\n// if defined, mouse y will override animation time stamp\r\n// #define ALTERNATE_MOUSE\r\n\r\n// for (slight) speed improvement, use low quality fbm and noise and compensate with some settings adjustments\r\n// if not defined, high quality\r\n// if 1, medium quality. acceptable.\r\n// if 2, low quality. not acceptable anymore.\r\n// Notice, 1 and 2 have approximately the same speed when putting also the compensation adjustments. But compared to high quality, they are indeed faster.\r\n// #define LOW_Q 1\r\n\r\n// some approximation to show the inner and outer bounds of the volumes. the y center plane is removed (transparent)\r\n// to give a better look and feel on the inside.\r\n// #define SHOW_BOUNDS\r\n    \r\n#define CAM_ROTATION_SPEED 11.7\r\n#define CAM_TILT .15\t\t\t\t// put 0. if you do not want to animate camera vertically\r\n#define CAM_DIST 3.8\r\n\r\n#define MAX_MULT_EXPLOSIONS 5\r\n\r\n// the bounding sphere of the explosion. this is less general but means that\r\n// ray cast is only performed for nearby pixels, and raycast can begin from the sphere\r\n// (instead of walking out from the camera)\r\n// float expRadius = 1.75;\r\nfloat explosion_seed = 0.0;\t\t\t// keep this constant for a whole explosion, but when differing from explosion to the next one, you get non-identical looking ones\r\n// float downscale = 1.25;\t\t\t\t// how much smaller (than expRadius) one explosion ball should be. bigger value = smaller. 1.0 = no scale down.\r\nconst int steps = 64;\t\t\t\t// iterations when marching through cloud noise. default = 64. 40 might still suffice. When putting higher, explosion becomes too dense, so make colBottom and colTop more transparent.\r\n// float grain = 2.0;\t\t\t\t\t// increase for more detailed explosions, but then you should also increase iterations (and decrease step, which is done automatically)\r\n// float speed = 0.3;\t\t\t\t\t// total animation speed (time stretch). nice = 0.5, default = 0.4\r\n// float ballness = 2.0;\t\t\t\t// lower values makes explosion look more like a cloud. higher values more like a ball.\r\n// float growth = 2.2;\t\t\t\t\t// initial growth to explosion ball. lower values makes explosion grow faster\r\n// float fade = 1.6;\t\t\t\t\t// greater values make fade go faster but later. Thus greater values leave more smoke at the end.\r\nfloat thinout_smooth = 0.7;\t\t\t// smoothed thinning out of the outer bounding sphere. 1.0 = no smoothening, 0.0 = heavy thinning, nice = 0.65 to 0.75\r\n// float density = 1.35;\t\t\t\t// higher values make sharper difference between dark and bright colors. low values make more blurry, less color spread and more transparent. default = 1.25 or 1.35\r\nvec2 brightness = vec2(3.0, 2.2);\t// x = constant offset, y = time-dependent factor\r\nvec2 brightrad = vec2(1.3, 1.0);\t// adds some variation to the radius of the brightness falloff. x = constant offset, y = density-dependent factor\r\nvec4 colBottom = vec4(1.2,0.94,0.42,0.7);\r\nvec4 colTop = vec4(0.15,0.15,0.15,0.1);\r\nfloat color_low = 0.25;\t\t\t\t// the lower the value, the more black spots appear in the explosion. the higher, the more even the explosion looks like.\r\n// float contrast = 1.0;\t\t\t\t// final color contrast. higher values make ligher contrast. default = 1.0\r\n// float rolling_init_damp = 0.3;\t\t// rolling animation initial damping. 0.0 = no damping. nice = 0.2, default = 0.15\r\n// float rolling_speed = 2.0;\t\t\t// rolling animation speed (static over time). default = 1.0\r\nconst int mult_explosions = MAX_MULT_EXPLOSIONS;\t// how many explosion balls to draw\r\nfloat variation_seed = 0.0;\t\t\t// influences position variation of the different explosion balls\r\nfloat delay_seed = 0.0;\t\t\t\t// influences the start delay variation of the different explosion balls\r\n// float delay_range = 0.25;\t\t\t// describes the maximum delay for explosion balls to start up. Notice, this delay is relative to one explosion ball duration, so actually before speed is applied.\r\n// float ball_spread = 1.0;\t\t\t// how much to spread ball starting positions from the up vector. 0.0 = all on up vector, 1.0 = any direction between up and down vector.\r\n\r\n\r\n\r\n\r\n\r\n// Now come some fun effects which have nothing to do with the explosion effect.\r\n// You can switch them all off completely by commenting WITH_FUN.\r\n// #define WITH_FUN\r\n// \t// The fog is just for fun and has nothing to do with the explosion.\r\n\t#define FOG\r\n// \t// Same with the stars. Just for fun.\r\n\t#define STARS\r\n    \t#define STARDISTANCE 250.2\r\n    \t#define STARBRIGHTNESS 0.3\r\n    \t#define STARDENCITY 0.05\r\n\t// Night scenery settings, again just for fun.\r\n\t#define DAY_NIGHT_CYCLE_TIME 20.\r\n\t#define NIGHT_COLORING vec3(.92,.95,1.)\r\n\t#define CORRIDOR_LIGHT vec3(1.,1.,.9)\r\n\t#define ENLIGHTEN_PASSAGE .75\r\n\t// explosion enlightening the floor (faked)\r\n\t#define FLOOR_LIGHT_STRENGTH 1.\r\n\r\nstruct Ball\r\n{\r\n  vec3 offset;\r\n  vec3 dir;\r\n  float delay;\r\n};\r\n\r\nBall balls[MAX_MULT_EXPLOSIONS];\r\n\r\n// float tmax = 1.0 + delay_range;\r\nfloat getTime() {\r\n  float tmax = 1.0 + cExplosionDelayRange;\r\n#if defined (ALTERNATE_MOUSE) && !defined (SHADERTOY_APP)\r\n  if( iMouse.z > 0.0 ) return mouse.y/resolution.y*tmax;\r\n#endif\r\n  return fract(time * cExplosionSpeed / tmax) * tmax;\r\n}\r\n\r\nfloat hash( float n ) {\r\n  return fract(cos(n)*41415.92653);\t//https://www.shadertoy.com/view/4sXGRM\r\n    //return fract(sin(n)*753.5453123);\t//https://www.shadertoy.com/view/4sfGzS\r\n}\r\n\r\nvec2 hash2( float n ) {\r\n    //return fract(cos(n)*vec2(10003.579, 37049.7));\t//https://www.shadertoy.com/view/XtsSWs\r\n    return fract(sin(vec2(n,n+1.0))*vec2(13.5453123,31.1459123));\r\n}\r\n\r\nvec3 hash3( float n ) {\r\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(13.5453123,31.1459123,37.3490423));\r\n}\r\n\r\nfloat hash13(vec3 p3) {\r\n  p3 = fract(p3 * vec3(.1031,.11369,.13787));\r\n  p3 += dot(p3, p3.yzx + 19.19);\r\n  return fract((p3.x + p3.y) * p3.z);\r\n}\r\n\r\n#ifdef NOISE_LUT\r\n//iq's LUT 3D noise\r\nfloat noise( in vec3 x ) {\r\n  vec3 f = fract(x);\r\n  vec3 p = x - f; // this avoids the floor() but doesnt affect performance for me.\r\n#ifndef LOW_Q\t\t// in low quality setting, for speed, we try to live without that. we compensate with growth and fade.\r\n  f = f*f*(3.0-2.0*f);\r\n#endif\r\n  vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n  vec2 rg = texture2D( iChannel0, (uv+ 0.5)/256.0, -100.0 ).yx;\r\n  return mix( rg.x, rg.y, f.z );\r\n}\r\n#else\r\n\r\nfloat noise( in vec3 x ) {\r\n  vec3 f = fract(x);\r\n  vec3 p = x - f; // this avoids the floor() but doesnt affect performance for me.\r\n#ifndef LOW_Q\t\t// in low quality setting, for speed, we try to live without that. we compensate with growth and fade.\r\n  f = f*f*(3.0-2.0*f);\r\n#endif\r\n\t\r\n  float n = p.x + p.y*157.0 + 113.0*p.z;\r\n  return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                 mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\r\n             mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                 mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\r\n}\r\n#endif\r\n\r\nfloat fbm( vec3 p, vec3 dir ) {\r\n  float f;\r\n#ifndef LOW_Q\r\n  vec3 q = p - dir; f  = 0.50000*noise( q );\r\n  q = q*2.02 - dir; f += 0.25000*noise( q );\r\n  q = q*2.03 - dir; f += 0.12500*noise( q );\r\n  q = q*2.01 - dir; f += 0.06250*noise( q );\r\n  q = q*2.02 - dir; f += 0.03125*noise( q );\r\n#elif LOW_Q == 1\r\n    // in low quality setting, for speed, we try to live with a lower-quality fbm. we compensate with higher grain.\r\n  vec3 q = p - dir; f  = 0.50000*noise( q );\r\n  q = q*2.02 - dir; f += 0.25000*noise( q );\r\n  q = q*2.03 - dir; f += 0.12500*noise( q );\r\n  q = q*2.04 - dir; f += 0.08250*noise( q );\r\n#elif LOW_Q == 2\r\n  vec3 q = p - dir; f  = 0.50000*noise( q );\r\n  q = q*2.14 - dir; f += 0.29000*noise( q );\r\n  q = q*2.25 - dir; f += 0.16500*noise( q );\r\n#endif\r\n  return f;\r\n}\r\n\r\nfloat tri(in float x) {\r\n  return abs(fract(x)-.5);\r\n}\r\n\r\nvec3 tri3(in vec3 p) {\r\n  return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));\r\n}\r\n\r\nfloat triNoise3d(in vec3 p, in float spd, float ti) {\r\n  float z=1.1;\r\n  float rz = 0.;\r\n  vec3 bp = p*1.5;\r\n  for (float i=0.; i<=3.; i++ ) {\r\n    vec3 dg = tri3(bp);\r\n    p += (dg+spd);\r\n    bp *= 1.9;\r\n    z *= 1.5;\r\n    p *= 1.3;\r\n\r\n    rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\r\n    bp += 0.14;\r\n  }\r\n  return rz;\r\n}\r\n\r\nfloat fogmap(in vec3 p, in float d, float ti) {\r\n  p.x *= .4;\r\n  p.x += ti*1.5;\r\n  p.z += sin(p.x*.5);\r\n  p.z *= .4;\r\n  return max(triNoise3d(p*.3/(d+20.),0.2, ti)-.4, 0.)*(smoothstep(0.,25.,p.y));\r\n    //return triNoise3d(p*1.2/(d+20.),0.2, ti)*(1.25-smoothstep(0.,25.,p.y));\r\n}\r\n// Thanks to nimitz for the fast fog/clouds idea...\r\n// https://www.shadertoy.com/view/4ts3z2\r\nvec3 clouds(in vec3 col, in vec3 ro, in vec3 rd, in float mt, float ti, in vec3 cloudcolor) {\r\n  float d = 1.5;\t//.5\r\n  for(int i=0; i<7; i++) {\r\n    if (d>mt) break;\r\n    vec3  pos = ro + rd*d;\r\n    float rz = fogmap(pos, d, ti);\r\n//float grd =  clamp((rz - fogmap(pos+.8-float(i)*0.1,d, ti))*3., 0.1, 1. );\r\n//vec3 cloudcolor = (vec3(.1,0.8,.5)*.5 + .5*vec3(.5, .8, 1.)*(1.7-grd))*0.55;\r\n//vec3 cloudcolor = (2.*vec3(.4,0.4,.4) + .5*vec3(.5)*(1.7-grd))*0.55;\r\n//vec3 cloudcolor = 2.*(vec3(.4,0.4,.4));\r\n    col = mix(col,cloudcolor,clamp(rz*smoothstep(d-0.4,2.+d*1.75,mt),0.,1.) );\r\n//col = mix(col,cloudcolor,clamp(rz*smoothstep(d,d*1.86,mt),0.,1.) );\r\n    d *= 1.5+0.3;\r\n  }\r\n  return col;\r\n}\r\n\r\n// Thanks to bjarkeck for the fast star field implementation...\r\n// https://www.shadertoy.com/view/lsc3z4\r\nfloat stars(vec3 ray) {\r\n  vec3 p = ray * STARDISTANCE;\r\n  float brigtness = smoothstep(1.0 - STARDENCITY, 1.0, hash13(floor(p)));\r\n  return smoothstep(STARBRIGHTNESS, 0., length(fract(p) - 0.5)) * brigtness;\r\n}\r\n\r\n// assign colour to the media\r\nvec4 computeColour( float density, float radius, float bright ) {\r\n\t// colour based on density alone. gives impression of occlusion within\r\n\t// the media\r\n\t//vec4 result = vec4( mix( vec3(1.0,0.9,0.8), vec3(.7,0.3,0.2), density ), density );\r\n\t//vec4 result = vec4( mix( vec3(1.0,0.9,0.8), vec3(0.4,0.15,0.1), density ), density );\r\n  vec4 result = vec4( vec3(mix( 1.0, color_low, density )), density );\r\n    //vec4 result = vec4( mix( 1.1*vec3(1.0,0.9,0.8), 0.9*vec3(0.4,0.15,0.1), density ), density );\r\n    //vec4 result = vec4(1.,1.,1.,density);\r\n\r\n\t// colour added for explosion\r\n    //result *= mix( colBottom * bright, colTop * bright, min( (radius+0.5)*0.588, 1.0 ) );\r\n  result *= mix( colBottom, colTop, min( (radius+0.5)*0.588, 1.0 ) ) * bright;\r\n    //result *= mix( colBottom, colTop, radius ) * bright;\r\n\t//result.rgb *= mix( colBottom * bright, colTop, smoothstep( 0., 1., (radius-0.5)*0.6+0.5 ) );\r\n\t//result *= mix( colBottom * bright, colTop, clamp( radius * 1.7-.2, 0.0, 1.0 ) );\r\n    //result.a*=density*1.5;\r\n\t//result.a *= mix( 1.0, 0.0, min( (radius / expRadius + 0.2)*0.5, 1.0 ) );\r\n    //result.a *= mix( 1.0, 0.2, min( (radius+0.5)/1.7, 1.0 ) );\r\n\t//result.a *= mix( 0.0, 1.0, 1.0-radius*0.25 );\r\n\t//if(radius<1.0-mouseY) result.a=0.0;\r\n\t// make central hole\r\n\t//result.a *= clamp((radius/expRadius-0.5*mouseIn)*15.0, 0.0, 1.0);\r\n\t//result.xyz *= mix( 3.1*vec3(1.0,0.5,0.05), vec3(0.48,0.53,0.5), min( radius*.76, 1.0 ) );\r\n\t\r\n    //result = mix( colBottom * bright * vec4(1.0,0.9,0.8,1.0), colTop*vec4(0.4,0.15,0.1,1.0), min( (radius+0.5)/1.7, 1.0 ) );\r\n    //result.a *= density;\r\n    \r\n  return result;\r\n}\r\n\r\n// maps 3d position to density\r\nfloat densityFn( in vec3 p, in float r, float t, in vec3 dir, float seed ) {\r\n  //const float pi = 3.1415926;\r\n  float den = cExplosionBallness + (cExplosionGrowth+cExplosionBallness)*log(t)*r;\r\n  den -= (2.5+cExplosionBallness)*pow(t,cExplosionFade)/r;\r\n    //den = -1.7 - p.y;\r\n\t//den *= 1.+smoothstep(0.75,1.,r);\r\n    \r\n    //if ( den <= -4. || den > -1. ) return -1.;\r\n    //if ( den <= -2.8 ) return -1.;\r\n  if ( den <= -3. ) return -1.;\r\n    //if ( den > -1. ) return -1.;\r\n    \r\n#ifdef SHOW_BOUNDS\r\n  p = 0.5 * normalize(p);\r\n  return abs(p.y);\r\n    //return 0.8;\r\n#endif\r\n    \r\n\t// offset noise based on seed\r\n\t// plus a time based offset for the rolling effect (together with the space inversion below)\r\n    //float s = seed-(rolling_speed/(t+rolling_init_damp));\r\n  float s = seed-(cExplosionRollingSpeed/(sin(min(t*3.,1.57))+cExplosionRollingInitDamp));\r\n\t//if( iMouse.z > 0.0 ) t += iMouse.y * 0.02;\r\n    //vec3 dir = vec3(0.,1.,0.);\r\n\t//vec3 dir = -0.5*(p - expCenter);\r\n    //vec3 dir = normalize( vec3( noise(p.xyz), noise(p.yxz), noise(p.zyx) ) );\r\n  dir *= s;\r\n\r\n    // invert space\r\n  p = -cExplosionGrain*p/(dot(p,p)*cExplosionDownScale);\r\n\r\n    // participating media\r\n  float f = fbm( p, dir );\r\n    //f=clamp(f,.1,.7);\r\n\t\r\n\t// add in noise with scale factor\r\n  den += 4.0*f;\r\n    //den -= r*r;\r\n\t\r\n\t//den *= density;\t// we do that outside\r\n\t//den *= 1.25;\r\n    //den *= .8;\r\n\r\n  return den;\r\n}\r\n\r\n// rad = radius of complete mult explosion (range 0 to 1)\r\n// r = radius of the explosion ball that contributes the highest density\r\n// rawDens = non-clamped density at the current maching location on the current ray\r\n// foffset = factor for offset how much the offsetting should be applied. best to pass a time-based value.\r\nvoid calcDens( in vec3 pos, out float rad, out float r, out float rawDens, in float t, in float foffset, out vec4 col, in float bright ) {\r\n  float radiusFromExpCenter = length(pos);\r\n  rad = radiusFromExpCenter / cExplosionRadius;\r\n\r\n  r = 0.0;\r\n  rawDens = 0.0;\r\n  col = vec4(0.0);\r\n\r\n  for ( int k = 0; k < mult_explosions; ++k )\r\n  {\r\n    float t0 = t - balls[k].delay;\r\n    if ( t0 < 0.0 || t0 > 1.0 ) continue;\r\n\r\n    vec3 p = pos - balls[k].offset * foffset;\r\n    float radiusFromExpCenter0 = length(p);\r\n\r\n    float r0 = cExplosionDownScale * radiusFromExpCenter0 / cExplosionRadius;\r\n    if( r0 > 1.0 ) continue;\r\n// BUG: Skipping for r0 > 1.0 gives some artefacts on later smoke where the inside of sphere\r\n    // is more transparent than the outside (for the parts where other expl balls contribute density in).\r\n    // I can't figure yet what the problem is. Inside the sphere near border, densities should be\r\n    // practically 0.0 which also does not contribute (almost) anything to sum in contributeDens.\r\n    // So what's the problem then?\r\n    // Notice, the same bug happens with skipping for t0 > 1.0, just there slight jumps can be seen near\r\n    // end of animation for certain angle views.\r\n    // Reason for the bug: Below, we pass r0 as r. If a density is not skipped but becomes in final color\r\n    // actually transparent, r0 is still passed as r. Outside the r0, the r gains a value from another\r\n    // explosion ball and thus gains also its rawDens0. Inside our r0, the other's ball's density gets\r\n    // skipped, which is producing the jump.\r\n// Fix would be to intermengle all densities altogether without\r\n    // skipping any. But how? Especially how to intermengle all the r0's?\r\n// Actually the problem comes from color calculation which makes the final color near transparent the\r\n// higher the density value.\r\n// So maybe the fix would be to put the transparency information into the density somehow before\r\n// selecting one radius. Actually we could add up all the densities, but the one which was the\r\n// highest could be that one who's r0 we will use as r. Maybe.\r\n    // FIX: The bug is only with OLD_COLORING. New coloring should not have this bug anymore.\r\n    \r\n    float rawDens0 = densityFn( p, r0, t0, balls[k].dir, explosion_seed + 33.7*float(k) ) * cExplosionDensity;\r\n\r\n#ifndef SHOW_BOUNDS\r\n\t// thin out the volume at the far extends of the bounding sphere to avoid\r\n\t// clipping with the bounding sphere\r\n    rawDens0 *= 1.-smoothstep(thinout_smooth,1.,r0);\r\n#endif\r\n\r\n#ifndef OLD_COLORING\r\n    float dens = clamp( rawDens0, 0.0, 1.0 );\r\n\r\n    //vec4 col0 = computeColour(dens, r0*(.9+.5*dens)/1.75, bright);\t// also adds some variation to the radius\r\n    //vec4 col0 = computeColour(dens, r0*(1.4+rawDens0), bright);\t\t// also adds some variation to the radius\r\n    vec4 col0 = computeColour(dens, r0*(brightrad.x+brightrad.y*rawDens0), bright);\t// also adds some variation to the radius\r\n\r\n#ifndef SHOW_BOUNDS\r\n    // uniform scale density\r\n    //col0.a *= 0.8;\r\n    //col0.a *= col0.a + .4;\r\n    col0.a *= (col0.a + .4) * (1. - r0*r0);\r\n\r\n    // colour by alpha\r\n    col0.rgb *= col0.a;\r\n#else\r\n    col0.a *= 5.;\r\n#endif\r\n\r\n    col += col0;\r\n\r\n    rawDens = max(rawDens, rawDens0);\r\n    //rawDens+=max(rawDens0,0.);\r\n\r\n\r\n#else\r\n    if ( rawDens0 > rawDens ) {\r\n      rawDens = rawDens0;\r\n      r = r0;\r\n    }\r\n#endif\r\n  }\r\n\r\n#ifdef SHOW_BOUNDS\r\n  col /= float(mult_explosions);\r\n#endif\r\n    \r\n\t//rawDens *= density;\r\n}\r\n\r\n#ifdef OLD_COLORING\r\n// rad = radius of complete mult explosion (range 0 to 1)\r\n// r = radius of the explosion ball that contributes the highest density\r\n// rawDens = non-clamped density at the current maching location on the current ray\r\nvoid contributeDens( in float rad, in float r, in float rawDens, in float bright, out vec4 col, inout vec4 sum ) {\r\n  //float dens = clamp( rawDens, 0.0, 1.0 );\r\n  float dens = min( rawDens, 1.0 );\t// we expect already rawDens to be positive\r\n\r\n//col = computeColour(dens, r*(.9+.5*dens)/1.75, bright);\t// also adds some variation to the radius\r\n//col = computeColour(dens, r*(1.4+rawDens), bright);\t// also adds some variation to the radius\r\n  col = computeColour(dens, r*(brightrad.x+brightrad.y*rawDens), bright);\t// also adds some variation to the radius\r\n\r\n#ifndef SHOW_BOUNDS\r\n// uniform scale density\r\n//col.a *= 0.8;\r\n//col.a *= col.a + .4;\r\n  col.a *= (col.a + .4) * (1. - r*r);\r\n\r\n// colour by alpha\r\n  col.rgb *= col.a;\r\n\r\n// alpha blend in contribution\r\n  sum = sum + col*(1.0 - sum.a);\r\n  sum.a+=0.15*col.a;\r\n#else\r\n  col.a *= 5.;\r\n\t  sum = max(sum, col);\r\n#endif\r\n}\r\n#endif\r\n\r\n#ifndef OLD_COLORING\r\nvoid contributeColor( in vec4 col, inout vec4 sum ) {\r\n#ifndef SHOW_BOUNDS\r\n// alpha blend in contribution\r\n  sum = sum + col*(1.0 - sum.a);\r\n  sum.a+=0.15*col.a;\r\n#else\r\n\t  sum = max(sum, col);\r\n#endif\r\n}\r\n#endif\r\n\r\nvec4 raymarch( in vec3 rayo, in vec3 rayd, in vec2 expInter, in float t, out float d ) {\r\n  vec4 sum = vec4( 0.0 );\r\n\r\n  float step = 1.5 / float(steps);\r\n \r\n// start iterating on the ray at the intersection point with the near half of the bounding sphere\r\n//vec3 pos = rayo + rayd * (expInter.x + step*texture2D( iChannel2, gl_FragCoord.xy/iChannelResolution[0].x ).x);\t\t// dither start pos to break up aliasing\r\n//vec3 pos = rayo + rayd * (expInter.x + 1.0*step*fract(0.5*(gl_FragCoord.x+gl_FragCoord.y)));\t// regular dither\r\n  vec3 pos = rayo + rayd * (expInter.x);\t// no dither\r\n\r\n  float march_pos = expInter.x;\r\n  d = 4000.0;\r\n\r\n// t goes from 0 to 1 + mult delay. that is 0 to 1 is for one explosion ball. the delay for time distribution of the multiple explosion balls.\r\n// t_norm is 0 to 1 for the whole animation (incl mult delay).\r\n  float tmax = 1.0 + cExplosionDelayRange;\r\n  float t_norm = t / tmax;\r\n  float smooth_t = sin(t_norm*2.1);\t//sin(t*2.);\r\n\r\n//float bright = 6.1;\r\n  float t1 = 1.0 - t_norm;\t// we use t_norm instead of t so that final color is reached at end of whole animation and not already at end of first explosion ball.\r\n  //float bright = 3.1 + 18.0 * t1*t1;\r\n//float bright = 3.1 + 1.4 * t1*t1;\r\n//float bright = 3.1 + 4.4 * t1*t1;\r\n  float bright = brightness.x + brightness.y * t1*t1;\r\n//float bright = smoothstep(0.0, 30.1, 1.0);\r\n//float bright = smoothstep(20.0, 3.1, 1.0);\r\n//float bright = 10.;\r\n\r\n  for( int i=0; i<steps; i++ ) {\r\n    if ( sum.a >= 0.98 ) { d = march_pos; break; }\r\n    if ( march_pos >= expInter.y ) break;\r\n\r\n    float rad, r, rawDens;\r\n    vec4 col;\r\n    calcDens( pos, rad, r, rawDens, t, smooth_t, col, bright );\r\n\r\n    if ( rawDens <= 0.0 ) {\r\n      float s = step * 2.0;\r\n      pos += rayd * s;\r\n      march_pos += s;\r\n      continue;\r\n    }\r\n        \r\n#ifdef OLD_COLORING\r\n    contributeDens( rad, r, rawDens, bright, col, sum );\r\n#else\r\n    contributeColor( col, sum );\r\n#endif\r\n  \r\n// take larger steps through low densities.\r\n// something like using the density function as a SDF.\r\n    float stepMult = 1.0 + (1.-clamp(rawDens+col.a,0.,1.));\r\n// step along ray\r\n    pos += rayd * step * stepMult;\r\n    march_pos += step * stepMult;\r\n\r\n//pos += rayd * step;\r\n  }\r\n\r\n#ifdef SHOW_BOUNDS\r\n  if ( sum.a < 0.1 ) {\r\n    sum = vec4(0.,0.,.5,0.1);\r\n  }\r\n#endif\r\n\t\r\n  return clamp( sum, 0.0, 1.0 );\r\n}\r\n\r\n// iq's sphere intersection, but here fixed for a sphere at (0,0,0)\r\nvec2 iSphere(in vec3 ro, in vec3 rd, in float rad) {\r\n\t//sphere at origin has equation |xyz| = r\r\n\t//sp |xyz|^2 = r^2.\r\n\t//Since |xyz| = ro + t*rd (where t is the parameter to move along the ray),\r\n\t//we have ro^2 + 2*ro*rd*t + t^2 - r2. This is a quadratic equation, so:\r\n\t//vec3 oc = ro - sph.xyz; //distance ray origin - sphere center\r\n\t\r\n  float b = dot(ro, rd);\t\t\t\t\t//=dot(oc, rd);\r\n  float c = dot(ro, ro) - rad * rad;\t\t//=dot(oc, oc) - sph.w * sph.w; //sph.w is radius\r\n  float h = b*b - c; // delta\r\n  if(h < 0.0) { \r\n    return vec2(-1.0);\r\n  }\r\n  //h = sqrt(h);\r\n  h *= 0.5;\t\t// just some rough approximation to prevent sqrt.\r\n  return vec2(-b-h, -b+h);\r\n}\r\n\r\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos ) {\r\n    // camera orbits around explosion\r\n  float camRadius = CAM_DIST;\r\n\t// use mouse x coord\r\n  float a = time*CAM_ROTATION_SPEED;\r\n  float b = CAM_TILT * sin(a * .014);\r\n\r\n  a = cCameraPan;\r\n  b = cCameraTilt - 0.5;\r\n\r\n  float phi = b * 3.14;\r\n  float camRadiusProjectedDown = camRadius * cos(phi);\r\n  float theta = a * PI2;\r\n  float xoff = camRadiusProjectedDown * cos(theta);\r\n  float zoff = camRadiusProjectedDown * sin(theta);\r\n  float yoff = camRadius * sin(phi);\r\n  cameraPos = vec3(xoff,yoff,zoff);\r\n     \r\n// camera target\r\n  vec3 target = vec3(0.);\r\n     \r\n// camera frame\r\n  vec3 fo = normalize(target-cameraPos);\r\n  vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\r\n  vec3 up = normalize(cross(fo,ri));\r\n     \r\n// multiplier to emulate a fov control\r\n  float fov = .5;\r\n\t\r\n// ray direction\r\n  vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\r\n\t\r\n  return rayDir;\r\n}\r\n\r\nvoid setup() {\r\n// first expl ball always centered looking up\r\n  balls[0] = Ball(\r\n    vec3(0.),\r\n    vec3(0.,.7,0.),\t\t// not normalized so that expl ball 0 rolls somewhat slower\r\n    0.0\r\n  );\r\n\r\n  float pseed = variation_seed;\r\n  float tseed = delay_seed;\r\n  float maxdelay = 0.0;\r\n  for ( int k = 1; k < mult_explosions; ++k ) {\r\n    float pseed = variation_seed + 3. * float(k-1);\r\n    float tseed = delay_seed + 3. * float(k-1);\r\n    vec2 phi = hash2(pseed) * vec2(2.*PI, PI*cExplosionBallSpread);\r\n    vec2 tilted = vec2( sin(phi.y), cos(phi.y) );\r\n    vec3 rotated = vec3( tilted.x * cos(phi.x), tilted.y, tilted.x * sin(phi.x) );\r\n    balls[k].offset = 0.7 * rotated; //hash3(pseed) - 0.5;\r\n    balls[k].dir = normalize( balls[k].offset );\r\n    balls[k].delay = cExplosionDelayRange * hash(tseed);\r\n    pseed += 3.;\r\n    tseed += 3.;\r\n    maxdelay = max(maxdelay, balls[k].delay);\r\n  }\r\n\r\n  if ( maxdelay > 0.0 ) {\r\n// Now stretch the ball explosion delays to the maximum allowed range.\r\n// So that the last ball starts with a delay of exactly delay_range and thus we do not waste any final time with just empty space.\r\n\t    for ( int k = 0; k < mult_explosions; ++k ) {\r\n      balls[k].delay *= cExplosionDelayRange / maxdelay;\r\n    }\r\n  }\r\n}",explosionUniforms:{cCameraTilt:{value:0},cCameraPan:{value:0},cExplosionRadius:{value:1.75},cExplosionDownScale:{value:1.25},cExplosionGrain:{value:2},cExplosionSpeed:{value:.3},cExplosionBallness:{value:2},cExplosionGrowth:{value:2.2},cExplosionFade:{value:1.6},cExplosionDensity:{value:1.35},cExplosionContrast:{value:1},cExplosionRollingInitDamp:{value:.3},cExplosionRollingSpeed:{value:2},cExplosionDelayRange:{value:.25},cExplosionBallSpread:{value:1}},fbmNoise2Frag:"vec2 speed = vec2(2.0, 1.0);\r\nvec2 p = pin.uv * cScale * 50.0 - time*0.2;\r\nfloat q = fbm2(p);\r\nvec2 r = vec2(fbm2(p + q + time * speed.x - p.x - p.y), fbm2(p + q - time * speed.y));\r\npout.color = vec3(fbm2(r));\r\n\r\nfloat graph = q;",fbmNoise2FragPars:"uniform float cScale;\nfloat fbm2Rand(vec2 n) {\n  return fract(cos(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat fbm2Noise(vec2 n) {\n  const vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n);\n  vec2 f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n  return mix(mix(fbm2Rand(b), fbm2Rand(b + d.yx), f.x), mix(fbm2Rand(b + d.xy), fbm2Rand(b + d.yy), f.x), f.y);\n}\nfloat fbm2(vec2 n) {\n  float total = 0.0;\n  float amplitude = 1.0;\n  for (int i=0; i<8; i++) {\n    if (i >= cNoiseOctave) break;\n    total += fbm2Noise(n) * amplitude;\n    n += n * cNoiseFrequency;\n    amplitude *= cNoiseAmplitude;\n  }\n  return total;\n}",fbmNoise2Uniforms:{cScale:{value:.2}},fbmNoise3Frag:"vec2 position = pin.uv + cOffset;\r\nposition *= cNoiseScale * 10.0;\r\nfloat color = intersectcloudscovonly(vec3(position.x, time * 0.03, position.y));\r\npout.color = vec3(color);\r\n\r\nfloat graph = color;",fbmNoise3FragPars:"uniform float cNoiseScale;\r\nuniform float cOffset;\r\n\r\nfloat hash(float n) {\r\n  return fract(sin(n)*758.5453);\r\n}\r\nfloat noise3d(in vec3 x) {\r\n  vec3 p = floor(x);\r\n  vec3 f = fract(x);\r\n  f = f*f*(3.0-2.0*f);\r\n  float n = p.x + p.y * 157.0 + 113.0 * p.z;\r\n  return mix(mix(mix(hash(n+0.0), hash(n+1.0), f.x),\r\n                 mix(hash(n+157.0), hash(n+158.0), f.x), f.y),\r\n             mix(mix(hash(n+113.0), hash(n+114.0), f.x),\r\n                 mix(hash(n+270.0), hash(n+271.0), f.x), f.y), f.z);\r\n}\r\nfloat noise2d(in vec2 x) {\r\n  vec2 p = floor(x);\r\n  vec2 f = smoothstep(0.0, 1.0, fract(x));\r\n  float n = p.x + p.y * 57.0;\r\n  return mix(mix(hash(n+0.0), hash(n+1.0), f.x), mix(hash(n+57.0), hash(n+58.0), f.x), f.y);\r\n}\r\n\r\nfloat configurablenoise(vec3 x, float c1, float c2) {\r\n  vec3 p = floor(x);\r\n  vec3 f = fract(x);\r\n  f = f*f*(3.0-2.0*f);\r\n  float h2 = c1;\r\n  float h1 = c2;\r\n  float n = p.x + p.y*h1+h2*p.z;\r\n  return mix(mix(mix(hash(n+0.0), hash(n+1.0), f.x),\r\n                 mix(hash(n+h1), hash(n+h1+1.0), f.x), f.y),\r\n             mix(mix(hash(n+h2), hash(n+h2+1.0), f.x),\r\n                 mix(hash(n+h1+h2), hash(n+h1+h2+1.0), f.x), f.y), f.z);\r\n}\r\n\r\nfloat supernoise3d(vec3 p) {\r\n  float a = configurablenoise(p, 883.0, 971.0);\r\n  float b = configurablenoise(p+0.5, 113.0, 157.0);\r\n  return (a+b)*0.5;\r\n}\r\n\r\nfloat supernoise3dX(vec3 p) {\r\n  float a = configurablenoise(p, 883.0, 971.0);\r\n  float b = configurablenoise(p+0.5, 113.0, 157.0);\r\n  return (a*b);\r\n}\r\n\r\nfloat fbmHI(vec3 p, float dx) {\r\n  p *= 1.2;\r\n  float a = 0.0;\r\n  float w = 1.0;\r\n  float wc = 0.0;\r\n  for (int i=0; i<8; i++) {\r\n    if (i >= cNoiseOctave) break;\r\n    a += clamp(2.0 * abs(0.5 - supernoise3dX(p)) * w, 0.0, 1.0);\r\n    wc += w;\r\n    w *= cNoiseFrequency;\r\n    p = p * dx;\r\n    a *= cNoiseAmplitude;\r\n  }\r\n  return a / wc;\r\n  // return a / wc + noise(p*100.0)*11.0;\r\n}\r\n\r\n#define clouds pow(smoothstep(0.36 - supernoise3d(mx * 0.3 + time * 0.1) * 1.0, 0.46, supernoise3d(mx * 2.0) * fbmHI(mx * 6.0 + 5.0*fbmHI(mx.yxz * 1.0 + time * 0.001, 2.0) * 0.5 - time * 0.01, 2.8)), 3.0);\r\nfloat intersectcloudscovonly(vec3 start) {\r\n  vec3 mx = start;\r\n  // float h = (length(mx) - planetsize);\r\n  // h = smoothstep(0.0, 0.2, h) * (1.0 - smoothstep(0.2, 0.4, h));\r\n  return clouds\r\n}\r\n",fbmNoise3Uniforms:{cNoiseScale:{value:.5},cOffset:{value:0}},fbmNoiseFrag:"vec2 p = pin.uv - time*0.1;\r\nfloat lum = fbm(pin.uv);\r\npout.color = vec3(lum);\r\n\r\nfloat graph = fbm(pin.uv.xx);",fbmNoiseFragPars:"// fractal brownian motion (noise harmonic)\r\n// float fbm4(vec2 uv) {\r\n//   float n = 0.5;\r\n//   float f = 1.0;\r\n//   float l = 0.2;\r\n//   for (int i=0; i<4; i++) {\r\n//     n += snoise(vec3(uv*f, 1.0))*l;\r\n//     f *= 2.0;\r\n//     l *= 0.65;\r\n//   }\r\n//   return n;\r\n// }\r\n\r\n// fractal brownian motion (noise harmonic - fewer octaves = smoother)\r\n// float fbm8(vec2 uv) {\r\n//   float n = 0.5;\r\n//   float f = 4.0;\r\n//   float l = 0.2;\r\n//   for (int i=0; i<8; i++) {\r\n//     n += snoise(vec3(uv*f, 1.0))*l;\r\n//     f *= 2.0;\r\n//     l *= 0.65;\r\n//   }\r\n//   return n;\r\n// }\r\nfloat fbm(vec2 uv) {\r\n  float n = 0.5;\r\n  float f = 1.0;\r\n  float l = 0.2;\r\n  for (int i=0; i<8; i++) {\r\n    if (i >= cNoiseOctave) break;\r\n    n += snoise(vec3(uv*f, time))*l;\r\n//     f *= 2.0;\r\n//     l *= 0.65;\r\n    f *= cNoiseFrequency * 8.0;\r\n    l *= cNoiseAmplitude;\r\n  }\r\n  return n;\r\n}",fireFrag:"// https://www.shadertoy.com/view/XsXSWS by xbe\r\n\r\nvec2 q = pin.uv;\r\nq.y *= 2.0 - 1.0 * cPower;\r\nfloat T3 = max(3.0, 1.25 * cStrength) * time;\r\nq.x = mod(q.x, 1.0) - 0.5;\r\nq.y -= 0.25;\r\nfloat n = fbm(cStrength * q - vec2(0, T3));\r\nfloat c = 2.0 * cIntensity - 16.0 * pow(max(0.0, length(q * vec2(3.0 - cWidth*3.0 + q.y*1.5, 0.75)) - n * max(0.0, q.y + 0.25)), 1.2);\r\nfloat c1 = n * c * (1.5 - pow((2.50 / cRange)*pin.uv.y, 4.0));\r\nc1 = clamp(c1, 0.0, 1.0);\r\nvec3 col = vec3(1.5*c1, 1.5*c1*c1*c1, c1*c1*c1*c1*c1);\r\n\r\nfloat a = c * (1.0 - pow(pin.uv.y, 3.0));\r\nvec3 finalColor = mix(vec3(0.0), col, a);\r\nfloat gray = rgb2gray(finalColor);\r\npout.color = mix(vec3(gray), finalColor, cColor);",fireFragPars:"// https://www.shadertoy.com/view/XsXSWS by xbe\r\n\r\nuniform float cIntensity;\r\nuniform float cStrength;\r\nuniform float cPower;\r\nuniform float cRange;\r\nuniform float cWidth;\r\nuniform float cColor;\r\n\r\n// procedural noise from IQ\r\nvec2 hash( vec2 p ) {\r\n\tp = vec2( dot(p,vec2(127.1,311.7)),\r\n\t\t\t dot(p,vec2(269.5,183.3)) );\r\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\r\n}\r\n\r\nfloat noise( in vec2 p ) {\r\n\tconst float K1 = 0.366025404; // (sqrt(3)-1)/2;\r\n\tconst float K2 = 0.211324865; // (3-sqrt(3))/6;\r\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\r\n\tvec2 a = p - i + (i.x+i.y)*K2;\r\n\tvec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\r\n\tvec2 b = a - o + K2;\r\n\tvec2 c = a - 1.0 + 2.0*K2;\r\n\tvec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\r\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\r\n\treturn dot( n, vec3(70.0) );\r\n}\r\n\r\nfloat fbm(vec2 uv) {\r\n\tfloat f;\r\n\tmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\r\n\tf  = 0.5000*noise( uv ); uv = m*uv;\r\n\tf += 0.2500*noise( uv ); uv = m*uv;\r\n\tf += 0.1250*noise( uv ); uv = m*uv;\r\n\tf += 0.0625*noise( uv ); uv = m*uv;\r\n\tf = 0.5 + 0.5*f;\r\n\treturn f;\r\n}",fireUniforms:{cIntensity:{value:.5},cStrength:{value:1},cPower:{value:.1},cRange:{value:2},cWidth:{value:.1},cColor:{value:1}},flameEyeFrag:"vec2 uv = pin.position;\r\nfloat f = 0.0;\r\nfloat f2 = 0.0;\r\nfloat t = time * cSpeed;\r\nfloat alpha = light(uv, cSize, cRadius, cFlameEyeInnerFade, cFlameEyeOuterFade);\r\nfloat angle = atan(uv.x, uv.y);\r\nfloat n = flameEyeNoise(vec2(uv.x*20.0+time, uv.y*20.0+time));\r\nfloat l = length(uv);\r\nif (l < cFlameEyeBorder) {\r\n  t *= 0.8;\r\n  alpha = (1.0 - pow(((cFlameEyeBorder-l)/cFlameEyeBorder),0.22)*0.7);\r\n  alpha = clamp(alpha-light(uv, 0.2, 0.0, 1.3, 0.7)*0.55, 0.0, 1.0);\r\n  f = flare(angle*1.0, alpha,-t*0.5+alpha);\r\n  f2 = flare(angle*1.0, alpha,((-t+alpha*0.5+5.38134)));\r\n}\r\nelse if (alpha < 0.001) {\r\n  f = alpha;\r\n}\r\nelse {\r\n  f = flare(angle, alpha, t)*1.3;\r\n}\r\nvec3 col = vec3(f*(1.0 + sin(angle-t*4.0)*0.3) + f2*f2*f2, \r\n  f*alpha + f2*f2*2.0, \r\n  f*alpha*0.5 + f2*(1.0 + sin(angle + t*4.0)*0.3));\r\nfloat gray = rgb2gray(col);\r\npout.color = mix(vec3(gray), col, cColor);",flameEyeFragPars:"// https://www.shadertoy.com/view/ltBfDt\r\nconst float cSize = 2.3;\r\nconst float cRadius = 0.099;\r\n// uniform float cSize;\r\n// uniform float cRadius;\r\nuniform float cSpeed;\r\nuniform float cColor;\r\nuniform float cFlameEyeInnerFade;\r\nuniform float cFlameEyeOuterFade;\r\nuniform float cFlameEyeBorder;\r\n\r\nfloat flameEyeNoise(in vec2 st) {\r\n  vec2 i = floor(st);\r\n  vec2 f = fract(st);\r\n  float a = rand(i);\r\n  float b = rand(i + vec2(1.0, 0.0));\r\n  float c = rand(i + vec2(0.0, 1.0));\r\n  float d = rand(i + vec2(1.0, 1.0));\r\n  \r\n  vec2 u = f*f*(3.0-2.0*f);\r\n  return mix(a,b,u.x) + (c-a)*u.y*(1.0-u.x) + (d-b)*u.x*u.y;\r\n}\r\n\r\nfloat light(in vec2 pos, float size, float radius, float inner_fade, float outer_fade) {\r\n  float len = length(pos/size);\r\n  return pow(clamp((1.0 - pow(clamp(len-radius, 0.0, 1.0), 1.0/inner_fade)), 0.0, 1.0), 1.0/outer_fade);\r\n}\r\n\r\nfloat flare(float angle, float alpha, float t) {\r\n  float n = flameEyeNoise(vec2(t+0.5+abs(angle)+pow(alpha,0.6), t-abs(angle)+pow(alpha+0.1,0.6))*7.0);\r\n  float split = (15.0 + sin(t*2.0+n*4.0+angle*20.0+alpha*1.0*n)*(0.3+0.5+alpha*0.6*n));\r\n  float rotate = sin(angle*20.0 + sin(angle*15.0+alpha*4.0+t*30.0+n*5.0+alpha*4.0))*(0.5 + alpha*1.5);\r\n  float g = pow((2.0 + sin(split + n*1.5*alpha+rotate)*1.4)*n*4.0, n*(1.5-0.8*alpha));\r\n  g *= alpha * alpha * alpha * 0.4;\r\n  g += alpha * 0.7 + g*g*g;\r\n  return g;\r\n}",flameEyeUniforms:{cSpeed:{value:.2},cColor:{value:1},cFlameEyeInnerFade:{value:.8},cFlameEyeOuterFade:{value:.02},cFlameEyeBorder:{value:.23}},flameFrag:"// https://www.shadertoy.com/view/MdX3zr\r\nvec2 v = -1.0 + 2.0 * gl_FragCoord.xy / resolution.xy;\r\nv.x *= resolution.x / resolution.y;\r\n\r\nvec3 org = vec3(0.0, -2.0, 4.0);\r\nvec3 dir = normalize(vec3(v.x*1.6 / cWidth, -v.y, -1.5 * cScale));\r\n\r\nvec4 p = raymarch(org, dir);\r\nfloat glow = p.w;\r\n\r\n// vec4 col = mix(vec4(1.0, 0.5, 0.1, 1.0), vec4(0.1, 0.5, 1.0, 1.0), p.y*0.02 + 0.4);\r\n// col = mix(vec4(0.0), col, pow(glow*2.0, 4.0));\r\nvec4 col = mix(vec4(0.0), vec4(1.0), pow(glow*2.0*cIntensity, 4.0));\r\npout.color = col.xyz;\r\npout.opacity = col.w;",flameFragPars:"// https://www.shadertoy.com/view/MdX3zr\r\nuniform float cIntensity;\r\nuniform float cWidth;\r\nuniform float cScale;\r\n\r\nfloat flameNoise(vec3 p) {\r\n  vec3 i = floor(p);\r\n  vec4 a = dot(i, vec3(1.0, 57.0, 21.0)) + vec4(0.0, 57.0, 21.0, 78.0);\r\n  vec3 f = cos((p-i)*acos(-1.0)) * (-0.5) + 0.5;\r\n  a = mix(sin(cos(a)*a), sin(cos(1.0+a)*(1.0+a)), f.x);\r\n  a.xy = mix(a.xz, a.yw, f.y);\r\n  return mix(a.x, a.y, f.z);\r\n}\r\n\r\nfloat sphere(vec3 p, vec4 spr) {\r\n  return length(spr.xyz-p) - spr.w;\r\n}\r\n\r\nfloat flame(vec3 p) {\r\n  float d = sphere(p * vec3(1.0, 0.5, 1.0), vec4(0.0, -1.0, 0.0, 1.0));\r\n  return d + (flameNoise(p + vec3(0.0, time*2.0, 0.0)) + flameNoise(p*3.0)*0.5)*0.25*p.y;\r\n}\r\n\r\nfloat scene(vec3 p) {\r\n  return min(100.0 - length(p), abs(flame(p)));\r\n}\r\n\r\nvec4 raymarch(vec3 org, vec3 dir) {\r\n  float d = 0.0, glow = 0.0, eps = 0.02;\r\n  vec3 p = org;\r\n  bool glowed = false;\r\n  for (int i=0; i<64; i++) {\r\n    d = scene(p) + eps;\r\n    p += d * dir;\r\n    if (d > eps) {\r\n      if (flame(p) < 0.0) {\r\n        glowed = true;\r\n      } else if (glowed) {\r\n        glow = float(i)/64.0;\r\n      }\r\n    }\r\n  }\r\n  return vec4(p, glow);\r\n}",flamelanceFrag:"// compute flame area\r\nvec2 position = vec2((cAngle+1.)/2., 0.) * resolution.xy;\r\nfloat xinc = clamp(mod(time, 6.0)-3.0, -3.0, 3.0);\r\nfloat yinc = clamp(mod(-time, 6.0)+3.0, -3.0, 3.0);\r\n// float inc = xinc/yinc;\r\nfloat inc = -cAngle;\r\nfloat xslope = (pin.coord.x - position.x);\r\nfloat yslope = (pin.coord.y - position.y);\r\nfloat slope = xslope/yslope;\r\nfloat xdif = xinc/xslope;\r\nfloat ydif = yinc/yslope;\r\nfloat dist = distance(position, pin.coord.xy);\r\ndist = abs(slope - inc) * .1 + dist/(10000.*cPower);\r\nif ((inc > 0.0 && inc > 2.0) || (inc < 0.0 && inc < -2.0)) dist *= dist;\r\nif ((xdif < 0.0 && ydif < 0.0) || (ydif < 0.0 && xdif > 0.0)) dist = 10.0;\r\n\r\n// compute flame noise\r\nvec2 noisePosition = cNoiseSize * (pin.coord - position) / resolution.y - vec2(xinc*cSpeed*time, yinc*cSpeed*time);\r\nfloat noise = 0.0;\r\nfor (int i=0; i<10; i++) {\r\n  if (i > cNoiseDepth) break;\r\n  noise += cnoise(noisePosition * pow(2.0, float(i)));\r\n}\r\nvec4 d = mix(-(101.0-cSize) * dist, noise, cNoiseStrength) + color;\r\nvec3 gray = vec3(rgb2gray(d.xyz));\r\npout.color = mix(gray, d.xyz, cColor);",flamelanceFragPars:"uniform float cSize;\r\nuniform float cSpeed;\r\nuniform float cPower;\r\nuniform float cAngle;\r\nuniform float cColor;\r\nuniform float cNoiseSize;\r\nuniform float cNoiseStrength;\r\nuniform int cNoiseDepth;\r\nconst vec4 color = vec4(2.0, 1.5, .5, 1.0);\r\n\r\nvec2 fade(vec2 t) {\r\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\r\n}\r\n\r\nfloat cnoise(vec2 P) {\r\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\r\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\r\n  Pi = mod289(Pi);\r\n  vec4 ix = Pi.xzxz;\r\n  vec4 iy = Pi.yyww;\r\n  vec4 fx = Pf.xzxz;\r\n  vec4 fy = Pf.yyww;\r\n  vec4 i = permute(permute(ix)+iy);\r\n  vec4 gx = fract(i*(1.0/41.0))*2.0-1.0;\r\n  vec4 gy = abs(gx) - 0.5;\r\n  vec4 tx = floor(gx + 0.5);\r\n  gx = gx - tx;\r\n  vec2 g00 = vec2(gx.x, gy.x);\r\n  vec2 g10 = vec2(gx.y, gy.y);\r\n  vec2 g01 = vec2(gx.z, gy.z);\r\n  vec2 g11 = vec2(gx.w, gy.w);\r\n  vec4 norm = taylorInvSqrt(vec4(dot(g00,g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\r\n  g00 *= norm.x;\r\n  g01 *= norm.y;\r\n  g10 *= norm.z;\r\n  g11 *= norm.w;\r\n  float n00 = dot(g00, vec2(fx.x, fy.x));\r\n  float n10 = dot(g10, vec2(fx.y, fy.y));\r\n  float n01 = dot(g01, vec2(fx.z, fy.z));\r\n  float n11 = dot(g11, vec2(fx.w, fy.w));\r\n  vec2 fade_xy = fade(Pf.xy);\r\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\r\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\r\n  return 2.3 * n_xy;\r\n}",flamelanceUniforms:{cSize:{value:32},cSpeed:{value:4},cPower:{value:1},cAngle:{value:0},cColor:{value:1},cNoiseSize:{value:8},cNoiseStrength:{value:.25},cNoiseDepth:{value:3}},flameUniforms:{cIntensity:{value:1},cWidth:{value:1},cScale:{value:1}},flare2Frag:'// https://www.shadertoy.com/view/Xs33R2\r\n// Particle star constants\r\nconst float part_int_div = 40000.;                            // Divisor of the particle intensity. Tweak this value to make the particles more or less bright\r\nconst float part_int_factor_min = 0.1;                        // Minimum initial intensity of a particle\r\nconst float part_int_factor_max = 100.2;                        // Maximum initial intensity of a particle\r\nconst float mp_int = 12.0;\r\nconst float ppow = 2.3;\r\n\r\nconst vec2 part_starhv_dfac = vec2(9., 0.32);                 // x-y transformation vector of the distance to get the horizontal and vertical star branches\r\nconst float part_starhv_ifac = 0.25;                          // Intensity factor of the horizontal and vertical star branches\r\nconst vec2 part_stardiag_dfac = vec2(13., 0.61);              // x-y transformation vector of the distance to get the diagonal star branches\r\nconst float part_stardiag_ifac = 0.19;                        // Intensity factor of the diagonal star branches\r\nconst float dist_factor = 3.0;\r\n\r\nvec2 p = vec2(0.5);\r\nfloat dist = distance(pin.uv, p);\r\nvec2 uvp = pin.uv - p;\r\n\r\n// rotate\r\nvec2 A = sin(vec2(0.0, 1.57) + time);\r\nuvp = uvp * mat2(A, -A.y, A.x);\r\n\r\nfloat distv = distance(uvp * part_starhv_dfac + p, p);\r\nfloat disth = distance(uvp * part_starhv_dfac.yx + p, p);\r\nvec2 uvd = 0.7071 * vec2(dot(uvp, vec2(1.0, 1.0)), dot(uvp, vec2(1.0, -1.0)));\r\nfloat distd1 = distance(uvd * part_stardiag_dfac + p, p);\r\nfloat distd2 = distance(uvd * part_stardiag_dfac.yx + p, p);\r\nfloat pint1 = 1.0 / (dist * dist_factor + 0.015);\r\npint1 += part_starhv_ifac / (disth * dist_factor + 0.01);\r\npint1 += part_starhv_ifac / (distv * dist_factor + 0.01);\r\npint1 += part_stardiag_ifac / (distd1 * dist_factor + 0.01);\r\npint1 += part_stardiag_ifac / (distd2 * dist_factor + 0.01);\r\n// if (part_int_factor_max * pint1 > 6.0) {\r\n  float pint = part_int_factor_max * (pow(pint1, ppow) / part_int_div) * mp_int * cIntensity;\r\n  pint = pow(pint, cPowerExponent);\r\n  pout.color = vec3(pint);\r\n// "} else { pout.color = vec3(0.0); }"',flare2FragPars:"// https://www.shadertoy.com/view/Xs33R2\r\nuniform float cIntensity;\r\nuniform float cPowerExponent;",flare2Uniforms:{cIntensity:{value:1},cPowerExponent:{value:1}},flare3Frag:"// https://www.shadertoy.com/view/4sX3Rs#\r\nvec2 pos = vec2(0.5);\r\nvec2 uv = pin.uv - 0.5;\r\nvec2 uvd = uv * length(uv);\r\nvec2 p = vec2(0.0) - uv;\r\nfloat ang = atan(p.x, p.y);\r\nfloat dist = length(p); dist = pow(dist, 0.1);\r\nfloat f0 = cIntensity / (length(uv-p)*16.0+1.0);\r\nf0 = f0+f0*(sin(noise(time + (pos.x+pos.y)*2.2 + ang*4.0+5.954)*16.0)*0.1+dist*0.1+0.8);\r\n\r\n// float f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\r\n// float f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\r\n// float f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\r\n// float f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\r\n// \r\n// vec2 uvx = mix(uv,uvd,-0.5);\r\n// float f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\r\n// float f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\r\n// float f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\r\n// \r\n// uvx = mix(uv,uvd,-.4);\r\n// float f5 = max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;\r\n// float f52 = max(0.01-pow(length(uvx+0.4*pos),5.5),.0)*2.0;\r\n// float f53 = max(0.01-pow(length(uvx+0.6*pos),5.5),.0)*2.0;\r\n// \r\n// uvx = mix(uv,uvd,-0.5);\r\n// float f6 = max(0.01-pow(length(uvx-0.3*pos),1.6),.0)*6.0;\r\n// float f62 = max(0.01-pow(length(uvx-0.325*pos),1.6),.0)*3.0;\r\n// float f63 = max(0.01-pow(length(uvx-0.35*pos),1.6),.0)*5.0;\r\n\r\nvec3 c = vec3(.0);\r\n// c.r+=f2+f4+f5+f6; c.g+=f22+f42+f52+f62; c.b+=f23+f43+f53+f63;\r\n// c = c*1.3 - vec3(length(uvd)*.05);\r\nc+=vec3(f0);\r\n\r\nc *= vec3(1.4, 1.2, 1.0);\r\nc -= noise(pin.uv) * 0.015;\r\nc = cc(c, 0.5, 0.1);\r\n\r\nfloat t = c.x;\r\nt = pow(t, cPowerExponent);\r\n\r\npout.color = vec3(t);\r\n// pout.color = vec3(f0);\r\n// pout.color = vec3(iqnoise(pin.uv*64.0, 0.0, 0.0));",flare3FragPars:"// https://www.shadertoy.com/view/4sX3Rs#\r\nuniform float cIntensity;\r\nuniform float cPowerExponent;\r\n\r\nfloat noise(float x) {\r\n//   return iqnoise(vec2(x,0.0), 0.0, 0.0);\r\n//   return pnoise(vec2(x*16.0,0.0));\r\n  return pnoise(vec2(x,0.0), 1, 2.0, 0.5);\r\n  // float map = min(resolution.x, resolution.y);\r\n  // vec2 t = mod(vec2(x,0.0), map);\r\n  // return snoise(t, t / map, vec2(map));\r\n}\r\n\r\nfloat noise(vec2 x) {\r\n  return iqnoise(x*512.0, 0.0, 0.0);\r\n//   return noise(x*0.1);\r\n}\r\n\r\nvec3 cc(vec3 color, float factor, float factor2) {\r\n  float w = color.x + color.y + color.z;\r\n  return mix(color, vec3(w)*factor, w*factor2);\r\n}",flare3Uniforms:{cIntensity:{value:1},cPowerExponent:{value:1}},flareFrag:"// https://www.shadertoy.com/view/4scXWB\r\n// rotation hexagon\r\nvec2 A = sin(vec2(0.0, 1.57) + time);\r\nvec2 U = abs(pin.position * mat2(A, -A.y, A.x)) * mat2(2.0, 0.0, 1.0, 1.7);\r\nfloat t = cIntensity * 0.5 / max(U.x, U.y); // glowing-spiky approx of step(max, 0.2)\r\nt = pow(t, cPowerExponent);\r\npout.color = vec3(t);",flareFragPars:"// https://www.shadertoy.com/view/4scXWB\r\nuniform float cIntensity;\r\nuniform float cPowerExponent;",flareUniforms:{cIntensity:{value:1},cPowerExponent:{value:1}},flashFrag:"float t = atan(pin.position.y, pin.position.x) + time;\r\nt = sin(t * cFrequency);\r\nt = pow(t, cPowerExponent);\r\npout.color = vec3(t);",flashFragPars:"uniform float cFrequency;\r\nuniform float cPowerExponent;",flashUniforms:{cFrequency:{value:10},cPowerExponent:{value:1}},flowerFrag:"float u = sin((atan(pin.position.y, pin.position.x) + time * 0.5) * floor(cPetals)) * cRadius;\r\nfloat t = cIntensity / abs(u - length(pin.position));\r\nt = pow(abs(t), cPowerExponent);\r\npout.color = vec3(t);",flowerFragPars:"uniform float cPetals;\r\nuniform float cRadius;\r\nuniform float cIntensity;\r\nuniform float cPowerExponent;",flowerFunFrag:"float u = abs(sin((atan(pin.position.y, pin.position.x) - length(pin.position) + time) * floor(cPetals)) * cRadius) + cOffset;\r\nfloat t = cIntensity / abs(u - length(pin.position));\r\nt = pow(abs(t), cPowerExponent);\r\npout.color = vec3(t);",flowerFunFragPars:"uniform float cPetals;\r\nuniform float cRadius;\r\nuniform float cOffset;\r\nuniform float cIntensity;\r\nuniform float cPowerExponent;",flowerFunUniforms:{cPetals:{value:6},cRadius:{value:.5},cOffset:{value:.2},cIntensity:{value:.1},cPowerExponent:{value:1}},flowerUniforms:{cPetals:{value:6},cRadius:{value:.5},cIntensity:{value:.1},cPowerExponent:{value:1}},frag:"  PSInput pin;\r\n  // [-1,1]\r\n  pin.position = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);\r\n  pin.mouse = vec2(mouse.x * 2.0 - 1.0, -mouse.y * 2.0 + 1.0);\r\n  // [0,scrx]\r\n  pin.coord = gl_FragCoord.xy;\r\n  // [0,1]\r\n  pin.uv = gl_FragCoord.xy / resolution;\r\n  // [-0.5,0.5]\r\n  // = (gl_FragCoord.xy - 0.5*resolution.xy) / min(resolution.x, resolution.y)\r\n  // = pin.position*0.5\r\n\r\n  PSOutput pout;\r\n  pout.color = vec3(0.0);\r\n  pout.opacity = 1.0;",fragEnd:"gl_FragColor = vec4(pout.color, pout.opacity);",fragPars:"uniform vec2 resolution;\r\nuniform vec2 mouse;\r\nuniform float time;\r\nuniform vec3 cameraPos;\r\nuniform vec3 cameraDir;\r\nuniform sampler2D tDiffuse;",glsl3Frag:"precision mediump sampler2DArray;\r\n#define varying in\r\nlayout(location = 0) out highp vec4 outFragColor;\r\n#define gl_FragColor outFragColor\r\n#define gl_FragDepthEXT gl_FragDepth\r\n#define texture2D texture\r\n#define textureCube texture\r\n#define texture2DProj textureProj\r\n#define texture2DLodEXT textureLod\r\n#define texture2DProjLodEXT textureProjLod\r\n#define textureCubeLodEXT textureLod\r\n#define texture2DGradEXT textureGrad\r\n#define texture2DProjGradEXT textureProjGrad\r\n#define textureCubeGradEXT textureGrad\r\nprecision highp float;\r\nprecision highp int;\r\n#define HIGH_PRECISION",glsl3Vert:"precision mediump sampler2DArray;\r\n#define attribute in\r\n#define varying out\r\n#define texture2D texture\r\nprecision highp float;\r\nprecision highp int;\r\n#define HIGH_PRECISION",gradationFrag:"float len = length(cDirection);\r\nif (len == 0.0) {\r\n  pout.color = vec3(1.0);\r\n} else {\r\n  vec2 n = normalize(cDirection);\r\n  vec2 pos = pin.position - (-cDirection);\r\n  float t = (dot(pos, n) * 0.5) / len;\r\n  t = pow(t, cPowerExponent);\r\n  pout.color = vec3(t);\r\n}",gradationFragPars:"uniform vec2 cDirection;\r\nuniform float cPowerExponent;",gradationLineFrag:"float len = length(cDirection);\r\nif (len == 0.0) {\r\n  pout.color = vec3(1.0);\r\n} else {\r\n  vec2 n = normalize(cDirection);\r\n  vec2 pos = pin.position - (-cDirection);\r\n  float t = (dot(pos, n) * 0.5 + cOffset) / len;\r\n  float r = rand(vec2(pin.uv.x, 0.0)) + 1e-6;\r\n  float a = 1.0 / (1.0 - r);\r\n  t = a*t - a*r;\r\n  t = pow(t, cPowerExponent);\r\n  pout.color = vec3(t);\r\n}",gradationLineFragPars:"uniform vec2 cDirection;\r\nuniform float cPowerExponent;\r\nuniform float cOffset;",gradationLineUniforms:{cDirection:{value:new r.Vector2(0,1)},cPowerExponent:{value:1},cOffset:{value:0}},gradationUniforms:{cDirection:{value:new r.Vector2(0,1)},cPowerExponent:{value:1}},gradient:"// http://g3d.cs.williams.edu/websvn/filedetails.php?repname=g3d&path=%2FG3D10%2Fdata-files%2Fshader%2Fgradient.glsl\r\nvec3 hueGradient(float t) {\r\n  vec3 p = abs(fract(t+vec3(1.0,2.0/3.0,1.0/3.0))*6.0 - 3.0);\r\n  return clamp(p-1.0, 0.0, 1.0);\r\n}\r\n\r\nvec3 techGradient(float t) {\r\n  return pow(vec3(t+0.01), vec3(120.0, 10.0, 180.0));\r\n}\r\n\r\nvec3 fireGradient(float t) {\r\n  return max(pow(vec3(min(t*1.02,1.0)), vec3(1.7,25.0,100.0)),\r\n             vec3(0.06 * pow(max(1.0 - abs(t-0.35), 0.0), 5.0)));\r\n}\r\n\r\nvec3 desertGradient(float t) {\r\n  float s = sqrt(clamp(1.0 - (t - 0.4) / 0.6, 0.0, 1.0));\r\n  vec3 sky = sqrt(mix(vec3(1, 1, 1), vec3(0, 0.8, 1.0), smoothstep(0.4, 0.9, t)) * vec3(s, s, 1.0));\r\n  vec3 land = mix(vec3(0.7, 0.3, 0.0), vec3(0.85, 0.75 + max(0.8 - t * 20.0, 0.0), 0.5), pow2(t / 0.4));\r\n  return clamp((t > 0.4) ? sky : land, 0.0, 1.0) * clamp(1.5 * (1.0 - abs(t - 0.4)), 0.0, 1.0);\r\n}\r\n\r\nvec3 electricGradient(float t) {\r\n  return clamp( vec3(t * 8.0 - 6.3, pow2(smoothstep(0.6, 0.9, t)), pow(t, 3.0) * 1.7), 0.0, 1.0);\r\n}\r\n\r\nvec3 neonGradient(float t) {\r\n  return clamp(vec3(t * 1.3 + 0.1, pow2(abs(0.43 - t) * 1.7), (1.0 - t) * 1.7), 0.0, 1.0);\r\n}\r\n\r\nvec3 heatmapGradient(float t) {\r\n  return clamp((pow(t, 1.5) * 0.8 + 0.2) * vec3(smoothstep(0.0, 0.35, t) + t * 0.5, smoothstep(0.5, 1.0, t), max(1.0 - t * 1.7, t * 7.0 - 6.0)), 0.0, 1.0);\r\n}\r\n\r\nvec3 rainbowGradient(float t) {\r\n  vec3 c = 1.0 - pow(abs(vec3(t) - vec3(0.65, 0.5, 0.2)) * vec3(3.0, 3.0, 5.0), vec3(1.5, 1.3, 1.7));\r\n  c.r = max((0.15 - pow2(abs(t - 0.04) * 5.0)), c.r);\r\n  c.g = (t < 0.5) ? smoothstep(0.04, 0.45, t) : c.g;\r\n  return clamp(c, 0.0, 1.0);\r\n}\r\n\r\nvec3 brightnessGradient(float t) {\r\n  return vec3(t * t);\r\n}\r\n\r\nvec3 grayscaleGradient(float t) {\r\n  return vec3(t);\r\n}\r\n\r\nvec3 stripeGradient(float t) {\r\n  return vec3(mod(floor(t * 32.0), 2.0) * 0.2 + 0.8);\r\n}\r\n\r\nvec3 ansiGradient(float t) {\r\n  return mod(floor(t * vec3(8.0, 4.0, 2.0)), 2.0);\r\n}",gradientNoiseFrag:"vec2 uv = pin.uv * cNoiseScale * 10.0;\r\nvec3 p = normal(vec3(uv, time), 0.01);\r\np = (p + vec3(1.0)) * 0.5;\r\nvec3 gray = vec3(rgb2gray(p));\r\npout.color = mix(gray, p, cColor);\r\n\r\nfloat graph = gray.x;",gradientNoiseFragPars:"uniform float cNoiseScale;\r\nuniform float cColor;\r\nvec3 normal(vec3 v, float delta) {\r\n  vec2 coefficient = vec2(\r\n    snoise(v + vec3(delta, 0.0, 0.0)) - snoise(v - vec3(delta, 0.0, 0.0)),\r\n    snoise(v + vec3(0.0, delta, 0.0)) - snoise(v - vec3(0.0, delta, 0.0))) / delta;\r\n  coefficient *= 0.3;\r\n  vec3 req = vec3(-coefficient.x, -coefficient.y, 1.0);\r\n  return req / length(req);\r\n}",gradientNoiseUniforms:{cNoiseScale:{value:1},cColor:{value:1}},grungeFrag:"vec2 p = pin.uv;\r\nfloat pixelSize = 1.0;\r\nfloat dx = mod(p.x, pixelSize) - pixelSize*0.5;\r\nfloat dy = mod(p.y, pixelSize) - pixelSize*0.5;\r\np.x -= dx;\r\np.y -= dy;\r\nvec3 col = texture2D(tGrunge, mix(3.0, 0.1, cScale) * pin.uv + vec2(time*0.1)).rgb;\r\nfloat bright = 0.3333*(col.r + col.g + col.b);\r\nfloat dist = sqrt(dx*dx + dy*dy);\r\nfloat rad = bright * pixelSize * 0.8 * cRadius;\r\nfloat m = step(dist, rad);\r\npout.color = mix(vec3(0.0), vec3(1.0), m);",grungeFragPars:"uniform sampler2D tGrunge;\r\nuniform float cRadius;\r\nuniform float cScale;",grungeUniforms:{tGrunge:{value:null},cRadius:{value:1},cScale:{value:1}},height2NormalFrag:"//   // Determine the offsets\r\n//   vec3 vPixelSize = vec3(1.0 / resolution.x, 0.0, -1.0 / resolution.x);\r\n//   \r\n//   // Take three samples to determine two vectors that can be\r\n//   // use to generate the normal at this pixel\r\n//   float h0 = texture2D(tDiffuse, pin.uv).r;\r\n//   float h1 = texture2D(tDiffuse, pin.uv + vPixelSize.xy).r;\r\n//   float h2 = texture2D(tDiffuse, pin.uv + vPixelSize.yx).r;\r\n//   \r\n//   vec3 v01 = vec3(vPixelSize.xy, h1-h0);\r\n//   vec3 v02 = vec3(vPixelSize.yx, h2-h0);\r\n//   vec3 n = cross(v01, v02);\r\n//   \r\n//   // Can be useful to scale the Z component to tweak the\r\n//   // amount bumps show up, less than 1.0 will make them\r\n//   // more apparent, greater than 1.0 will smooth them out\r\n//   n.z *= 0.5;\r\n//   \r\n//   pout.color = n;\r\n\r\nconst vec2 size = vec2(2.0, 0.0);\r\nvec3 vPixelSize = vec3(1.0 / resolution.x, 0.0, -1.0 / resolution.x);\r\nfloat s01 = texture2D(tDiffuse, pin.uv + vPixelSize.xy).x;\r\nfloat s21 = texture2D(tDiffuse, pin.uv + vPixelSize.zy).x;\r\nfloat s10 = texture2D(tDiffuse, pin.uv + vPixelSize.yx).x;\r\nfloat s12 = texture2D(tDiffuse, pin.uv + vPixelSize.yz).x;\r\nvec3 va = normalize(vec3(size.xy,(s21-s01)*cHeightScale));\r\nvec3 vb = normalize(vec3(size.yx,(s10-s12)*cHeightScale));\r\nvec3 n = cross(va,vb);\r\npout.color = n*0.5 + 0.5;\r\n\r\n// THREE.JS (NormalMapShader.js)\r\n// vec3 vPixelSize = vec3(1.0 / resolution.x, 0.0, -1.0 / resolution.x);\r\n// float s11 = texture2D(tDiffuse, pin.uv).x;\r\n// float s01 = texture2D(tDiffuse, pin.uv + vPixelSize.xy).x;\r\n// float s10 = texture2D(tDiffuse, pin.uv + vPixelSize.yx).x;\r\n// vec3 n = normalize(vec3((s11-s10) * heightScale, (s11-s01)*heightScale, 2.0));\r\n// pout.color = n*0.5 + 0.5;\r\n\r\n// vec3 vPixelSize = vec3(1.0 / resolution.x, 0.0, -1.0 / resolution.x);\r\n// float s01 = texture2D(tDiffuse, pin.uv + vPixelSize.xy).x;\r\n// float s21 = texture2D(tDiffuse, pin.uv + vPixelSize.zy).x;\r\n// float s10 = texture2D(tDiffuse, pin.uv + vPixelSize.yx).x;\r\n// float s12 = texture2D(tDiffuse, pin.uv + vPixelSize.yz).x;\r\n// vec3 n = normalize(vec3((s11-s10) * heightScale, (s11-s01)*heightScale, 2.0));\r\n// pout.color = n*0.5 + 0.5;",height2NormalFragPars:"uniform float cHeightScale;",height2NormalSobelFrag:"vec3 vPixelSize = vec3(1.0 / resolution.x, 0.0, -1.0 / resolution.x);\r\n\r\n\r\n\r\n// Use of the sobel filter requires the eight samples\r\n// surrounding the current pixel:\r\nfloat h00 = texture2D( tDiffuse, pin.uv + vPixelSize.zz ).r;\r\nfloat h10 = texture2D( tDiffuse, pin.uv + vPixelSize.yz ).r;\r\nfloat h20 = texture2D( tDiffuse, pin.uv + vPixelSize.xz ).r;\r\n\r\nfloat h01 = texture2D( tDiffuse, pin.uv + vPixelSize.zy ).r;\r\nfloat h21 = texture2D( tDiffuse, pin.uv + vPixelSize.xy ).r;\r\n\r\nfloat h02 = texture2D( tDiffuse, pin.uv + vPixelSize.zx ).r;\r\nfloat h12 = texture2D( tDiffuse, pin.uv + vPixelSize.yx ).r;\r\nfloat h22 = texture2D( tDiffuse, pin.uv + vPixelSize.xx ).r;\r\n\r\n// The Sobel X kernel is:\r\n//\r\n// [ 1.0  0.0  -1.0 ]\r\n// [ 2.0  0.0  -2.0 ]\r\n// [ 1.0  0.0  -1.0 ]\r\n\r\nfloat Gx = h00 - h20 + 2.0 * h01 - 2.0 * h21 + h02 - h22;\r\n\t\t\t\r\n// The Sobel Y kernel is:\r\n//\r\n// [  1.0    2.0    1.0 ]\r\n// [  0.0    0.0    0.0 ]\r\n// [ -1.0   -2.0   -1.0 ]\r\n\r\nfloat Gy = h00 + 2.0 * h10 + h20 - h02 - 2.0 * h12 - h22;\r\n\r\n// Generate the missing Z component - tangent\r\n// space normals are +Z which makes things easier\r\n// The 0.5f leading coefficient can be used to control\r\n// how pronounced the bumps are - less than 1.0 enhances\r\n// and greater than 1.0 smoothes.\r\nfloat Gz = 0.5 * sqrt( 1.0 - Gx * Gx - Gy * Gy );\r\n\r\n// Make sure the returned normal is of unit length\r\nvec3 n = normalize( vec3( cHeightScale * Gx, cHeightScale * Gy, Gz ) );\r\n\r\n// Encode\r\npout.color = n*0.5 + 0.5;",height2NormalUniforms:{cHeightScale:{value:10}},inksplatFrag:"// vec2 uv = 12.0 * (pin.coord - 0.5*resolution.xy) / resolution.x;\r\n// float v = length(uv);\r\n// vec2 h = vec2(ceil(3.0*time));\r\n// float a, w;\r\n// \r\n// // lines\r\n// for (int i=0; i<21; i++) {\r\n//   h = splatHash(h);\r\n//   w = 0.03;\r\n//   a = (atan(uv.x, uv.y)+3.14)/6.28*(1.0+w);\r\n//   v -= sin(smoothstep(h.x, h.x+w, a)*3.14);\r\n// }\r\n// \r\n// // spots\r\n// for (float s = 3.0; s>0.5; s -= 0.04) {\r\n//   h = (splatHash(h)*2.0-1.0)*s;\r\n//   v -= (1.01-smoothstep(0.0,0.5*(3.0-s), length(uv-h)));\r\n// }\r\n\r\nvec3 xyz = fwidth(vec3(0,0,0));\r\nvec2 uv = 6.0*pin.position;\r\nfloat v = splat(splat_uv(pin.coord));\r\n// float w = 0.75 * splat_fwidth(pin.coord, v);\r\nfloat w = 0.75*fwidth(v);\r\nv = 1.0 - smoothstep(-w,w,v);\r\npout.color = vec3(v,v,v);\r\n",inksplatFragPars:"uniform int cSplatLines;\r\nuniform float cSplatSpotStep;\r\n\r\nvec2 splatHash(in vec2 p) {\r\n  return fract(sin(p*mat2(63.31,127.63,395.467,213.799))*43141.59265);\r\n}\r\n\r\nfloat splat(in vec2 p) {\r\n  float v = length(p);\r\n  vec2 h = vec2(ceil(3.0*time));\r\n  float a, w;\r\n\r\n  // lines\r\n  for (int i=0; i<100; i++) {\r\n    if (i>=cSplatLines) break;\r\n    h = splatHash(h);\r\n    w = 0.03;\r\n    a = (atan(p.x, p.y)+3.14)/6.28*(1.0+w);\r\n    v -= sin(smoothstep(h.x, h.x+w, a)*3.14);\r\n  }\r\n\r\n  // spots\r\n  // for (float s = 3.0; s>0.5; s -= cSplatSpotStep) {\r\n  float s = 3.0;\r\n  for (int i=0; i<100; i++) {\r\n    h = (splatHash(h)*2.0-1.0)*s;\r\n    v -= (1.01-smoothstep(0.0,0.5*(3.0-s), length(p-h)));\r\n    s -= cSplatSpotStep;\r\n    if (s <= 0.5) break;\r\n  }\r\n  \r\n  return v;\r\n}\r\n\r\nvec2 splat_uv(in vec2 coord) {\r\n  return 8.0 * (coord - 0.5*resolution.xy) / min(resolution.x, resolution.y);\r\n}\r\n\r\nfloat splat_fwidth(in vec2 coord, in float v11) {\r\n  float v10 = splat(splat_uv(coord + vec2(0.0,1.0)));\r\n  float v01 = splat(splat_uv(coord + vec2(-1.0,0.0)));\r\n  return abs(v11-v01) + abs(v10-v11);\r\n}\r\n",inksplatUniforms:{cSplatLines:{value:20},cSplatSpotStep:{value:.04}},julia:"int j=0;\r\nvec2 x = vec2(-0.345, 0.654);\r\nvec2 y = vec2(time * 0.005, 0.0);\r\nvec2 z = pin.position;\r\n\r\nfor (int i=0; i<360; i++) {\r\n  j++;\r\n  if (length(z) > 2.0) break;\r\n  z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + x + y;\r\n}\r\n\r\nfloat h = abs(mod(time * 15.0 - float(j), 360.0) / 360.0);\r\nvec3 color = hsv2rgb(vec3(h, 1.0, 1.0));\r\n\r\nfloat t = float(j) / 360.0;\r\npout.color = color * t;",kochCurveFrag:"// https://www.shadertoy.com/view/XdcGzH\r\nAngle = 90.0 * 0.5 * (1.0 + sin(time + 0.1 * PI));\r\nfloat ang = A2B * Angle;\r\nca = cos(ang);\r\nsa = sin(ang);\r\ncsa = vec2(ca, -sa);\r\nlambda = 0.5 / (ca*ca);\r\nlscl = 2.0 / lambda;\r\n\r\nconst float scaleFactor = 1.4;\r\nvec2 uv = scaleFactor * (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;\r\nuv.y += 0.5;\r\npout.color = color(uv);",kochCurveFragPars:"// https://www.shadertoy.com/view/XdcGzH\r\n#define A2B PI/360.0\r\n#define MaxIter 14\r\n\r\nconst float DRadius = 0.7;\r\nconst float Width = 1.4;\r\nconst float Gamma = 2.2;\r\nconst vec3 BackgroundColor = vec3(1.0);\r\nconst vec3 CurveColor = vec3(0.0);\r\n\r\nfloat lambda, ca, sa, lscl;\r\nfloat aaScale;\r\nfloat Angle = 60.0;\r\nvec2 csa;\r\n\r\nfloat d2hline(vec2 p) {\r\n  float t = max(-1.0, min(1.0, p.x));\r\n  p.x -= t;\r\n  return length(p);\r\n}\r\n\r\nfloat DE(vec2 p) {\r\n  float d = 1.0;\r\n  float r = dot(p,p);\r\n  for (int i=0; i<MaxIter; i++) {\r\n    p.x = abs(p.x);\r\n    p.x -= 1.0 - lambda;\r\n    float t = 2.0 * min(0.0, dot(p, csa));\r\n    p -= csa * t;\r\n    p.x -= lambda;\r\n    p *= lscl;\r\n    d *= lscl;\r\n    p.x += 1.0;\r\n    r = dot(p,p);\r\n  }\r\n  return d2hline(p) / d; // length(p)-1.0;\r\n}\r\n\r\nfloat coverageFunction(float t) {\r\n// this function returns the area of the part of the unit disc that is at the right of the vertical line x=t.\r\n// the exact coverage function is:\r\n// t = clamp(t, -1.0, 1.0); return (acos(t) - t*sqrt(1.0 - t*t)) / PI;\r\n// this is a good approximation\r\n  return 1.0 - smoothstep(-1.0, 1.0, t);\r\n// a better approximiation\r\n// t = clamp(t, -1.0, 1.0); return (t*t*t*t-5.0)*t*1.0/8.0+0.5; // but there is no virtual difference\r\n}\r\n\r\nfloat coverageLine(float d, float lineWidth, float pixsize) {\r\n  d = d * 1.0 / pixsize;\r\n  float v1 = (d-0.5*lineWidth)/DRadius;\r\n  float v2 = (d+0.5*lineWidth)/DRadius;\r\n  return coverageFunction(v1) - coverageFunction(v2);\r\n}\r\n\r\nvec3 color(vec2 pos) {\r\n  float pixsize = dFdx(pos.x);\r\n  float v = coverageLine(abs(DE(pos)), Width, pixsize);\r\n  return pow(mix(pow(BackgroundColor, vec3(Gamma)), pow(CurveColor, vec3(Gamma)), v), vec3(1.0 / Gamma));\r\n}",laser2Frag:"// http://glslsandbox.com/e#37112.0\r\n\r\n// float dist = -Capsule(pin.position, vec2(1.0, 0), .25);\r\n// dist = 1.0 - pow(dist, 2.0) * 4.0;\r\n// if (abs(pin.position.y) < laserInnerWidth) {\r\n//   float t = dist * abs(pin.position.y) / laserInnerWidth + 0.5;\r\n//   dist = clamp(t, 0.0, dist);\r\n// }\r\n\r\nfloat dist = cWidth / abs(pin.position.x);\r\ndist = clamp(pow(dist, 10.0), 0.0, 1.0);\r\n\r\nfloat d2 = (0.1 * cInnerWidth) / abs(pin.position.x);\r\ndist -= clamp(pow(d2, 2.0), 0.0, 1.0) * 0.5;\r\n\r\n// vec3 c = vec3(dist*0.1, dist*0.4, dist*0.8);\r\n// pout.color = mix(vec3(dist), c, laserColor);\r\npout.color = vec3(dist);",laser2FragPars:"uniform float cWidth;\r\nuniform float cInnerWidth;\r\n// \r\n// float Capsule(vec2 p, vec2 a, float r) {\r\n//   vec2 pa = p - a, ba = -a*2.0;\r\n//   float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\r\n//   return length(pa - ba*h) - r;\r\n// }\r\n",laser2Uniforms:{cWidth:{value:.5},cInnerWidth:{value:.4}},laserFrag:"// http://glslsandbox.com/e#26951.0\r\n\r\nfloat t = abs(cWidth / (sin(pin.position.x + sin(pin.position.y*0.0) * pin.position.y) * 5.0));\r\nt -= (1.0 - abs(cWidth / (sin(pin.position.x) * 0.5))) * 4.0;\r\nvec3 c = vec3(t*0.1, t*0.4, t*0.8);\r\nvec3 g = vec3(rgb2gray(c));\r\npout.color = mix(g, c, cColor);",laserFragPars:"uniform float cWidth;\r\nuniform float cColor;",laserUniforms:{cWidth:{value:.4},cColor:{value:1}},lensFlareFrag:"// http://glslsandbox.com/e#36072.2\r\n\r\nvec2 uv = pin.uv;\r\nfloat tt = cRadius / abs(distance(uv, vec2(0.5)) * zoom);\r\nfloat v = cRange / abs(length((vec2(0.5) - pin.uv) * vec2(0.03, 1.0)) * (zoom * 10.0));\r\n\r\nvec3 finalColor = tex2D(uv) * 0.5 * cRadius;\r\ntt = pow(tt, cPowerExponent);\r\nv = pow(v, cPowerExponent);\r\nfinalColor += vec3(2.0 * tt, 4.0 * tt, 8.0 * tt);\r\nfinalColor += vec3(2.0 * v, 4.0 * v, 8.0 * v);\r\n\r\nfloat x;\r\n\r\n// ghost\r\n\r\n// uv = pin.uv - 0.5;\r\n// x = length(uv);\r\n// uv *= pow(x, 4.0) * -100.0 + 1.0 / (x-0.5);\r\n// uv = clamp(uv + 0.5, 0.0, 1.0);\r\n// finalColor += tex2D(uv);\r\n\r\n// ghost with double chroma\r\n// uv = pin.uv - 0.5;\r\n// x = length(uv);\r\n// uv *= pow(x, 16.0) * -1000000.0 + 0.2 / (x-0.3);\r\n// uv = clamp(uv + 0.5, 0.0, 1.0);\r\n// finalColor += tex2D(uv);\r\n\r\n// chroma\r\n// uv = pin.uv - 0.5;\r\n// x = length(uv);\r\n// uv *= pow(x, 16.0) * -20000.0 + 0.2 / (x*x+5.0);\r\n// uv = clamp(uv + 0.5, 0.0, 1.0);\r\n// finalColor += tex2D(uv);\r\n\r\n// double chroma\r\n// uv = pin.uv - 0.5;\r\n// x = length(uv);\r\n// uv *= pow(x, 16.0) * -10000.0 + 0.2 / (x*x);\r\n// uv = clamp(uv + 0.5, 0.0, 1.0);\r\n// finalColor += tex2D(uv);\r\n\r\nvec2 D = 0.5 - pin.uv;\r\nvec3 o = vec3(-D.x * 0.4, 0.0, D.x * 0.4);\r\nvec3 lx = vec3(0.01, 0.01, 0.3);\r\nvec2 S = pin.uv - 0.5;\r\nvec2 m = 0.5 * S;\r\nm.xy *= pow(4.0 * length(S), 1.0);\r\nm.xy *= -2.0;\r\nm.xy = 0.5 + m.xy;\r\n\r\nvec3 e = tex2D(m.xy);\r\nS = (m.xy - 0.5) * 1.75;\r\ne *= clamp(1.0 - dot(S,S), 0.0, 1.0);\r\n\r\nfloat n = max(e.x, max(e.y, e.z)), c = n / (1.0 + n);\r\ne.xyz *= c;\r\nfinalColor += e;\r\n\r\nvec3 gray = vec3(rgb2gray(finalColor));\r\npout.color = mix(gray, finalColor, cColor);",lensFlareFragPars:"// http://glslsandbox.com/e#36072.2\r\n\r\nuniform float cRadius;\r\nuniform float cRange;\r\nuniform float cColor;\r\nuniform float cPowerExponent;\r\n\r\n#define dist 0.05\r\n#define zoom 100.0\r\n\r\nvec3 tex2D(vec2 uv) {\r\n  if (uv.x == 0.0 || uv.y == 0.0 || uv.x == 1.0 || uv.y == 1.0) return vec3(0.0);\r\n  float d = distance(uv, vec2(0.5));\r\n  if (d >= dist) return vec3(0.0);\r\n  return vec3(0.2 * ((dist - d)/dist), 0.4 * ((dist-d) / dist), 0.8 * ((dist-d) / dist));\r\n}",lensFlareUniforms:{cRadius:{value:1},cRange:{value:1},cColor:{value:0},cPowerExponent:{value:1}},lightFrag:"// http://glslsandbox.com/e#30670.0\r\n\r\nfloat size = 200.0 * cRadius;\r\nfloat lum = size/length(pin.coord - resolution*0.5);\r\nvec3 c = vec3(lum, pow(max(lum*0.9,0.0), 2.0)*0.4, pow(max(lum*0.8, 0.0), 3.0)*0.15);\r\nc = pow(c, vec3(cPowerExponent));\r\nvec3 g = vec3(rgb2gray(c));\r\npout.color = mix(g, c, cColor);",lightFragPars:"uniform float cRadius;\r\nuniform float cPowerExponent;\r\nuniform float cColor;",lightningFrag:"// http://glslsandbox.com/e#36774.0\r\nvec2 uv = pin.uv * 2.0111 - 1.5;\r\n\r\nvec3 finalColor = vec3(0.0);\r\nfor (int i=0; i<3; ++i) {\r\n  float amp = 80.0 + float(i) * 5.0;\r\n  float period = 0.4;\r\n  float thickness = mix(0.9, 1.0, noise(uv*10.0));\r\n  float t = abs(cWidth / (sin(uv.x + fbm(uv * cFrequency + 4.0*time*period)) * amp) * thickness);\r\n//   float show = fract(abs(sin(time))) >= 0.0 ? 1.0 : 0.0;\r\n//   finalColor += t * vec3(0.2, 0.2, 1.0);\r\n  finalColor += t * vec3(0.1) * cIntensity;\r\n}\r\n\r\npout.color = finalColor;",lightningFragPars:"// http://glslsandbox.com/e#36774.0\r\nuniform float cIntensity;\r\nuniform float cFrequency;\r\nuniform float cWidth;\r\n\r\nfloat hash(vec2 p) {\r\n  return fract(sin(dot(vec3(p.xy,1.0), vec3(37.1, 61.7, 12.4))) * 3758.5453123);\r\n}\r\n\r\nfloat noise(in vec2 p) {\r\n  vec2 i = floor(p);\r\n  vec2 f = fract(p);\r\n  f *= f * (3.0 - 2.0 * f);\r\n  return mix(mix(hash(i+vec2(0.0,0.0)), hash(i+vec2(1.0,0.0)), f.x),\r\n             mix(hash(i+vec2(0.0,1.0)), hash(i+vec2(1.0,1.0)), f.x),\r\n             f.y);\r\n}\r\n\r\nfloat fbm(vec2 p) {\r\n  float v = 0.0;\r\n  v += noise(p*1.0) * 0.5;\r\n  v += noise(p*2.0) * 0.25;\r\n  v += noise(p*4.0) * 0.125;\r\n  return v;\r\n}",lightningUniforms:{cIntensity:{value:1},cFrequency:{value:1},cWidth:{value:7}},lightUniforms:{cRadius:{value:1},cPowerExponent:{value:1},cColor:{value:1}},magicCircleFrag:"// http://glslsandbox.com/e#36354.1\r\npout.color = scene(pin.position);",magicCircleFragPars:"// http://glslsandbox.com/e#36354.1\r\nvec2 rotate(vec2 p, float rad) {\r\n  mat2 m = mat2(cos(rad), sin(rad), -sin(rad), cos(rad));\r\n  return m * p;\r\n}\r\n\r\nvec2 translate(vec2 p, vec2 diff) {\r\n  return p - diff;\r\n}\r\n\r\nvec2 scale(vec2 p, float r) {\r\n  return p * r;\r\n}\r\n\r\nfloat circle(float pre, vec2 p, float r1, float r2, float power) {\r\n  float l = length(p);\r\n  if (r1 < l && l < r2) pre = 0.0;\r\n  float d = min(abs(l-r1), abs(l-r2));\r\n  float res = power / d;\r\n  return clamp(pre + res, 0.0, 1.0);\r\n}\r\n\r\n// https://www.shadertoy.com/view/4dfXDn\r\n// float triangle(float pre, vec2 p, float width, float height, float power) {\r\n//   vec2 n = normalize(vec2(height, width/2.0));\r\n//   float d = max(abs(p).x * n.x + p.y * n.y - (height * n.y), -p.y);\r\n//   float res = power / d;\r\n//   return clamp(pre + res, 0.0, 1.0);\r\n// }\r\n\r\nfloat rectangle(float pre, vec2 p, vec2 half1, vec2 half2, float power) {\r\n  p = abs(p);\r\n  if ((half1.x < p.x || half1.y < p.y) && (p.x < half2.x && p.y < half2.y)) {\r\n    pre = max(0.01, pre);\r\n  }\r\n  float dx1 = (p.y < half1.y) ? abs(half1.x - p.x) : length(p - half1);\r\n  float dx2 = (p.y < half2.y) ? abs(half1.x - p.x) : length(p - half2);\r\n  float dy1 = (p.x < half1.x) ? abs(half1.y - p.y) : length(p - half1);\r\n  float dy2 = (p.x < half2.x) ? abs(half1.y - p.y) : length(p - half2);\r\n  float d = min(min(dx1, dx2), min(dy1, dy2));\r\n  float res = power / d;\r\n  return clamp(pre + res, 0.0, 1.0);\r\n}\r\n\r\nfloat radiation(float pre, vec2 p, float r1, float r2, int num, float power) {\r\n  float angle = 2.0 * PI / float(num);\r\n  float d = 1e10;\r\n  for (int i=0; i<360; i++) {\r\n    if (i >= num) break;\r\n    float _d = (r1 < p.y && p.y < r2) ? abs(p.x) : min(length(p-vec2(0.0, r1)), length(p-vec2(0.0, r2)));\r\n    d = min(d, _d);\r\n    p = rotate(p, angle);\r\n  }\r\n  float res = power / d;\r\n  return clamp(pre + res, 0.0, 1.0);\r\n}\r\n\r\nvec3 scene(vec2 p) {\r\n  float dest = 0.0;\r\n  p = scale(p, sin(PI*time/1.0) * 0.02+1.1);\r\n\r\n// frame\r\n {\r\n  vec2 q = p;\r\n  q = rotate(q, time * PI / 6.0);\r\n  dest = circle(dest, q, 0.85, 0.9, 0.006);\r\n  dest = radiation(dest, q, 0.87, 0.88, 36, 0.0008);\r\n }\r\n\r\n// outer rectangles\r\n {\r\n  vec2 q = p;\r\n  q = rotate(q, time * PI / 6.0);\r\n  const int n = 6;\r\n  float angle = PI / float(n);\r\n  q = rotate(q, floor(atan(q.x, q.y) / angle + 0.5) * angle);\r\n  for (int i=0; i<n; i++) {\r\n    dest = rectangle(dest, q, vec2(0.85/sqrt(2.0)), vec2(0.85/sqrt(2.0)), 0.0015);\r\n    q = rotate(q, angle);\r\n  }\r\n }\r\n\r\n// circles on frame\r\n//  {\r\n//   vec2 q = p;\r\n//   q = rotate(q, time * PI / 6.0);\r\n//   const int n = 12;\r\n//   q = rotate(q, 2.0 * PI / float(n) / 2.0);\r\n//   float angle = 2.0 * PI / float(n);\r\n//   for (int i=0; i<n; i++) {\r\n//     dest = circle(dest, q-vec2(0.0, 0.875), 0.001, 0.05, 0.004);\r\n//     dest = circle(dest, q-vec2(0.0, 0.875), 0.001, 0.001, 0.008);\r\n//     q = rotate(q, angle);\r\n//   }\r\n//  }\r\n\r\n// inner circles\r\n {\r\n   vec2 q = p;\r\n   dest = circle(dest, q, 0.5, 0.55, 0.002);\r\n }\r\n\r\n// inner rectangles\r\n {\r\n  vec2 q = p;\r\n  q = rotate(q, -time * PI / 6.0);\r\n  const int n = 3;\r\n  float angle = PI / float(n);\r\n  q = rotate(q, floor(atan(q.x, q.y) / angle + 0.5) * angle);\r\n  for (int i=0; i<n; i++) {\r\n    dest = rectangle(dest, q, vec2(0.36, 0.36), vec2(0.36, 0.36), 0.0015);\r\n    q = rotate(q, angle);\r\n  }\r\n }\r\n\r\n// circles on inner circle\r\n {\r\n  vec2 q = p;\r\n  q = rotate(q, -time * PI / 6.0);\r\n  const int n = 12;\r\n  q = rotate(q, 2.0 * PI / float(n) / 2.0);\r\n  float angle = 2.0 * PI / float(n);\r\n  for (int i=0; i<n; i++) {\r\n    dest = circle(dest, q-vec2(0.0, 0.53), 0.001, 0.035, 0.004);\r\n    dest = circle(dest, q-vec2(0.0, 0.53), 0.001, 0.001, 0.001);\r\n    q = rotate(q, angle);\r\n  }\r\n }\r\n\r\n// dots\r\n {\r\n  vec2 q = p;\r\n  q = rotate(q, time * PI / 6.0);\r\n  dest = radiation(dest, q, 0.25, 0.3, 12, 0.005);\r\n }\r\n\r\n// triangles\r\n//  {\r\n//   vec2 q = p;\r\n//   q = rotate(q, -time * PI / 6.0);\r\n//   dest = triangle(dest, q, 0.2, 0.2, 0.005);\r\n//   q = rotate(q, PI);\r\n//   dest = triangle(dest, q, 0.2, 0.2, 0.005);\r\n//  }\r\n\r\n// rectangle\r\n {\r\n  vec2 q = p;\r\n  q = rotate(q, -time * PI / 6.0);\r\n  const int n = 3;\r\n  float angle = PI / float(n);\r\n  q = rotate(q, floor(atan(q.x, q.y) / angle + 0.5) * angle);\r\n  for (int i=0; i<n; i++) {\r\n    dest = rectangle(dest, q, vec2(0.15, 0.15), vec2(0.15, 0.15), 0.0015);\r\n    q = rotate(q, angle);\r\n  }\r\n }\r\n\r\n// dots\r\n {\r\n  vec2 q = p;\r\n  q = rotate(q, time * PI / 6.0);\r\n  dest = radiation(dest, q, 0.1, 0.1, 12, 0.005);\r\n }\r\n\r\n// rings\r\n//  {\r\n//   vec2 q = p;\r\n//   q = scale(q, sin(PI * time / 1.0) * 0.04 + 1.1);\r\n//   q = rotate(q, -time * PI / 6.0);\r\n//   for (float i=0.0; i<6.0; i++) {\r\n//     float r = 0.13 - i*0.01;\r\n//     q = translate(q, vec2(0.1, 0.0));\r\n//     dest = circle(dest, q, r, r, 0.002);\r\n//     q = translate(q, -vec2(0.1, 0.0));\r\n//     q = rotate(q, -time * PI / 12.0);\r\n//   }\r\n//   dest = circle(dest, q, 0.04, 0.04, 0.004);\r\n//  }\r\n\r\n//   return pow(dest, 2.5) * vec3(1.0, 0.95, 0.8);\r\n  return vec3(pow(dest, 2.5));\r\n}",mandalasFrag:"// https://www.shadertoy.com/view/4tdSDr\r\n\r\n#define S 4\r\nvec2 I = pin.coord;\r\nvec2 R = resolution;\r\nI = I+I-R;\r\nvec4 O = vec4(1.0,1.0,0.0,0.0);\r\nmat2 M;\r\nfor (int i=0; i<S+S; i++) {\r\n  M = mat2(O.y=cos(O.x=acos(-1.0)*float(i)/float(S)), O.z=sin(O.x), -O.z,O.y);\r\n  I *= M;\r\n  O.a = max(O.a, calc((I+R)/(R+R)));\r\n}\r\npout.color = O.aaa;",mandaraFrag:"// https://www.shadertoy.com/view/MtcSz4\r\n\r\nvec2 p = pin.position * 0.7;\r\nvec2 f = vec2(length(p), atan(p.y, p.x));\r\nfloat T0 = cos(0.3*time);\r\nfloat T1 = 0.5 + 0.5*T0;\r\nfloat T2 = sin(0.15*time);\r\n\r\nfloat m0 = 0.0;\r\nfloat m1 = 0.0;\r\nfloat m2 = 0.0;\r\nfloat m3 = 0.0;\r\nfloat m4 = 0.0;\r\n\r\nif (f.x < cRadius) {\r\n  f.y += 0.1 * time;\r\n  vec2 c;\r\n  vec2 f2;\r\n\r\n  c = vec2(0.225 -0.1*T0, PI/4.0);\r\n  if (f.x < 0.25) {\r\n    for (float i=0.0; i<2.0; ++i) {\r\n      f2 = mod(f,c)-0.5*c;\r\n      m0 += spiral(vec2(f2.x, f2.y), 192.0);\r\n    }\r\n  }\r\n\r\n  c = vec2(0.225 -0.1*T0, PI/4.0);\r\n  if (f.x < cInnerRadius) {\r\n    for (float i=0.0; i<2.0; ++i) {\r\n      f.y += PI/8.0;\r\n      f2 = mod(f,c)-0.5*c;\r\n      m1 += rose((0.75-0.5*T0)*f2, 0.4*T1, 24.0);\r\n      m1 += rose2((0.5+0.5*T1)*f2, 0.2+0.2*T0, 36.0);\r\n    }\r\n  }\r\n\r\n  c = vec2(0.6 -0.2*T0, PI/4.0);\r\n  if (f.x > cInnerRadius2) {\r\n    for (float i=0.0; i<2.0; ++i) {\r\n      f.y += PI/8.0;\r\n      f2 = mod(f,c)-0.5*c;\r\n      m2 += spiral(vec2((0.25+0.5*T1)*f2.x, f2.y), 392.0);\r\n//       m2 += rose2((1.0+0.25*T0)*f2, 0.5, 24.0);\r\n    }\r\n  }\r\n\r\n//   c = vec2(0.4 -0.23*T0, PI/4.0);\r\n//   if (f.x < 0.265) {\r\n//     for (float i=0.0; i<2.0; ++i) {\r\n//       f.y += PI/8.0;\r\n//       f2 = mod(f,c)-0.5*c;\r\n//       m3 += spiral(f2, 256.0);\r\n//       m3 += rose(f2, 1.5*T1, 16.0);\r\n//     }\r\n//   }\r\n\r\n  m4 += circle(f, 0.040, 192.0);\r\n  m4 += circle(f, cInnerRadius2, 192.0);\r\n  m4 += circle(f, cInnerRadius, 192.0);\r\n\r\n}\r\n\r\n// m4 += circle(f, cRadius, 192.0);\r\n\r\n// color\r\nfloat z = m0+m1+m2+m3+m4;\r\nz *= z;\r\nz = clamp(z, 0.0, 1.0);\r\npout.color = vec3(z);",mandaraFragPars:"// https://www.shadertoy.com/view/MtcSz4\r\n\r\nuniform float cRadius;\r\nuniform float cInnerRadius;\r\nuniform float cInnerRadius2;\r\n\r\nfloat circle(vec2 p, float r, float width) {\r\n  float d = 0.0;\r\n  d += smoothstep(1.0, 0.0, width*abs(p.x-r));\r\n  return d;\r\n}\r\n\r\nfloat arc(vec2 p, float r, float a, float width) {\r\n  float d = 0.0;\r\n  if (abs(p.y) < a) {\r\n    d += smoothstep(1.0, 0.0, width*abs(p.x-r));\r\n  }\r\n  return d;\r\n}\r\n\r\nfloat rose(vec2 p, float t, float width) {\r\n  const float a0 = 6.0;\r\n  float d = 0.0;\r\n  p.x *= 7.0 + 8.0 * t;\r\n  d += smoothstep(1.0, 0.0, width*abs(p.x-sin(a0*p.y)));\r\n  d += smoothstep(1.0, 0.0, width*abs(p.x-abs(sin(a0*p.y))));\r\n  d += smoothstep(1.0, 0.0, width*abs(abs(p.x)-sin(a0*p.y)));\r\n  d += smoothstep(1.0, 0.0, width*abs(abs(p.x)-abs(sin(a0*p.y))));\r\n  return d;\r\n}\r\n\r\nfloat rose2(vec2 p, float t, float width) {\r\n  const float a0 = 6.0;\r\n  float d = 0.0;\r\n  p.x *= 7.0 + 8.0 * t;\r\n  d += smoothstep(1.0, 0.0, width*abs(p.x-cos(a0*p.y)));\r\n  d += smoothstep(1.0, 0.0, width*abs(p.x-abs(cos(a0*p.y))));\r\n  d += smoothstep(1.0, 0.0, width*abs(abs(p.x)-cos(a0*p.y)));\r\n  d += smoothstep(1.0, 0.0, width*abs(abs(p.x)-abs(cos(a0*p.y))));\r\n  return d;\r\n}\r\n\r\nfloat spiral(vec2 p, float width) {\r\n  float d = 0.0;\r\n  d += smoothstep(1.0, 0.0, width*abs(p.x-0.5*p.y/PI));\r\n  d += smoothstep(1.0, 0.0, width*abs(p.x-0.5*abs(p.y)/PI));\r\n  d += smoothstep(1.0, 0.0, width*abs(abs(p.x)-0.5*p.y/PI));\r\n  d += smoothstep(1.0, 0.0, width*abs(abs(p.x)-0.5*abs(p.y)/PI));\r\n  return d;\r\n}",mandaraUniforms:{cRadius:{value:.7325},cInnerRadius:{value:.43},cInnerRadius2:{value:.235}},mandelblot:"int j=0;\r\nvec2 x = pin.position + vec2(-0.5, 0.0);\r\nfloat y = 1.5 - pin.mouse.x * 0.5;\r\nvec2 z = vec2(0.0);\r\n\r\nfor (int i=0; i<360; i++) {\r\n  j++;\r\n  if (length(z) > 2.0) break;\r\n  z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + x * y;\r\n}\r\n\r\nfloat h = mod(time * 20.0, 360.0) / 360.0;\r\nvec3 color = hsv2rgb(vec3(h, 1.0, 1.0));\r\n\r\nfloat t = float(j) / 360.0;\r\npout.color = color * t;",marbleNoiseFrag:"vec2 pos = pin.coord / cScale;\r\nvec2 dpos = vec2(pos.x - pos.y, pos.x + pos.y);\r\ndpos = dpos * rotate2d(radians(time*5.0));\r\ndpos += 0.12 * combinedNoise(dpos);\r\ndpos += 0.25 * snoise(0.5*dpos*vec2(0.5,1.0));\r\nfloat graph = 0.5 + sin(dpos.x * cFrequency) / 2.0;\r\npout.color = vec3(graph);",marbleNoiseFragPars:"uniform float cScale;\r\nuniform float cFrequency;\r\n\r\nfloat combinedNoise(vec2 p) {\r\n  float s = 0.5;\r\n  float v = 0.0;\r\n  for (int i=0; i<3; i++) {\r\n    v += s*snoise(p/s);\r\n    s *= 0.4;\r\n  }\r\n  return v;\r\n}",marbleNoiseUniforms:{cScale:{value:100},cFrequency:{value:10}},noise:"#define NOISE_OCTAVE_MAX 10\r\nuniform int cNoiseOctave;\r\nuniform float cNoiseFrequency;\r\nuniform float cNoiseAmplitude;\r\nuniform float cNoisePersistence;\r\nuniform bool cNoiseGraphEnable;\r\n\r\nfloat rand(float x) {\r\n  return fract(sin(x) * 4358.5453123);\r\n}\r\nfloat rand3(float n) {\r\n  return fract(cos(n*89.42) * 343.32);\r\n}\r\nfloat rand(vec2 p) {\r\n  return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453);\r\n}\r\n\r\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\r\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\r\nhighp float rand2(const in vec2 uv) {\r\n  const highp float a = 12.9898, b = 78.233, c = 43758.5453;\r\n  highp float dt = dot(uv.xy, vec2(a,b)), sn = mod(dt, PI);\r\n  return fract(sin(sn) * c);\r\n}\r\n\r\nfloat cosine(float a, float b, float x) {\r\n  float f = (1.0 - cos(x * PI)) * 0.5;\r\n  return a * (1.0 - f) + b * f;\r\n}\r\n\r\nfloat bicosine(float tl, float tr, float bl, float br, float x, float y) {\r\n  return cosine(cosine(tl,tr,x), cosine(bl,br,x), y);\r\n}\r\n\r\nfloat linear(float a, float b, float t) {\r\n  return a + (b-a)*t;\r\n}\r\n\r\nfloat bilinear(float tl, float tr, float bl, float br, float x, float y) {\r\n  return linear(linear(tl,tr,x), linear(bl,br,x), y);\r\n}\r\n\r\nfloat cubic(float a, float b, float x) {\r\n  float f = x*x*(3.0 - 2.0*x); // 3x^2 + 2x\r\n  return a * (1.0 - f) + b * f;\r\n}\r\n\r\nfloat bicubic(float tl, float tr, float bl, float br, float x, float y) {\r\n  return cubic(cubic(tl,tr,x), cubic(bl,br,x), y);\r\n}\r\n\r\nfloat quintic(float a, float b, float x) {\r\n  float f = x*x*x*(x*(x*6.0 - 15.0)+10.0); // 6x^5 - 15x^4 + 10x^3\r\n  return a * (1.0 - f) + b * f;\r\n}\r\n\r\nfloat biquintic(float tl, float tr, float bl, float br, float x, float y) {\r\n  return quintic(quintic(tl,tr,x), quintic(bl,br,x), y);\r\n}\r\n\r\n// Value Noise by Inigo Quilez - iq/2013\r\n// https://www.shadertoy.com/view/lsf3WH\r\nvec2 vrand(vec2 p) {\r\n  p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\r\n  return -1.0 + 2.0 * fract(sin(p)*43758.5453123);\r\n}\r\n\r\n// gradation noise\r\nfloat vnoise(vec2 p) {\r\n  vec2 i = floor(p);\r\n  vec2 f = fract(p);\r\n  vec2 u = f*f*(3.0-2.0*f);\r\n  return mix(mix(dot(vrand(i+vec2(0.0,0.0)), f-vec2(0.0,0.0)),\r\n                 dot(vrand(i+vec2(1.0,0.0)), f-vec2(1.0,0.0)), u.x),\r\n             mix(dot(vrand(i+vec2(0.0,1.0)), f-vec2(0.0,1.0)),\r\n                 dot(vrand(i+vec2(1.0,1.0)), f-vec2(1.0,1.0)), u.x), u.y);\r\n}\r\n\r\nfloat plerp(vec2 p) {\r\n  vec2 i = floor(p);\r\n  vec2 f = fract(p);\r\n  return bicosine(rand(i+vec2(0.0,0.0)),\r\n                  rand(i+vec2(1.0,0.0)),\r\n                  rand(i+vec2(0.0,1.0)),\r\n                  rand(i+vec2(1.0,1.0)), f.x, f.y);\r\n//   vec4 v = vec4(rand(vec2(i.x,       i.y)),\r\n//                 rand(vec2(i.x + 1.0, i.y)),\r\n//                 rand(vec2(i.x,       i.y + 1.0)),\r\n//                 rand(vec2(i.x + 1.0, i.y + 1.0)));\r\n//   return cosine(cosine(v.x, v.y, f.x), cosine(v.z, v.w, f.x), f.y);\r\n}\r\n\r\nfloat pnoise(vec2 p) {\r\n  float t = 0.0;\r\n  for (int i=0; i<NOISE_OCTAVE_MAX; i++) {\r\n    if (i >= cNoiseOctave) break;\r\n    float freq = pow(2.0, float(i));\r\n    float amp = pow(cNoisePersistence, float(cNoiseOctave - i));\r\n    t += plerp(vec2(p.x / freq, p.y / freq)) * amp;\r\n  }\r\n  return t;\r\n}\r\n\r\nfloat pnoise(vec2 p, int octave, float frequency, float persistence) {\r\n  float t = 0.0;\r\n  float maxAmplitude = EPSILON;\r\n  float amplitude = 1.0;\r\n  for (int i=0; i<NOISE_OCTAVE_MAX; i++) {\r\n    if (i >= octave) break;\r\n    t += plerp(p * frequency) * amplitude;\r\n    frequency *= 2.0;\r\n    maxAmplitude += amplitude;\r\n    amplitude *= persistence;\r\n  }\r\n  return t / maxAmplitude;\r\n}\r\n\r\n// ridged noise\r\nfloat rpnoise(vec2 p, int octave, float frequency, float persistence) {\r\n  float t = 0.0;\r\n  float maxAmplitude = EPSILON;\r\n  float amplitude = 1.0;\r\n  for (int i=0; i<NOISE_OCTAVE_MAX; i++) {\r\n    if (i >= octave) break;\r\n    t += ((1.0 - abs(plerp(p * frequency))) * 2.0 - 1.0) * amplitude;\r\n    frequency *= 2.0;\r\n    maxAmplitude += amplitude;\r\n    amplitude *= persistence;\r\n  }\r\n  return t / maxAmplitude;\r\n}\r\n\r\nfloat psnoise(vec2 p, vec2 q, vec2 r) {\r\n  return pnoise(vec2(p.x,       p.y      )) *        q.x  *        q.y +\r\n         pnoise(vec2(p.x,       p.y + r.y)) *        q.x  * (1.0 - q.y) +\r\n         pnoise(vec2(p.x + r.x, p.y      )) * (1.0 - q.x) *        q.y +\r\n         pnoise(vec2(p.x + r.x, p.y + r.y)) * (1.0 - q.x) * (1.0 - q.y);\r\n}\r\n\r\n// PRNG (https://www.shadertoy.com/view/4djSRW)\r\nfloat prng(in vec2 seed) {\r\n  seed = fract(seed * vec2(5.3983, 5.4427));\r\n  seed += dot(seed.yx, seed.xy + vec2(21.5351, 14.3137));\r\n  return fract(seed.x * seed.y * 95.4337);\r\n}\r\n\r\n// https://www.shadertoy.com/view/Xd23Dh\r\n// Created by inigo quilez - iq/2014\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// This is a procedural pattern that has 2 parameters, that generalizes cell-noise, \r\n// perlin-noise and voronoi, all of which can be written in terms of the former as:\r\n//\r\n// cellnoise(x) = pattern(0,0,x)\r\n// perlin(x) = pattern(0,1,x)\r\n// voronoi(x) = pattern(1,0,x)\r\n//\r\n// From this generalization of the three famouse patterns, a new one (which I call \r\n// \"Voronoise\") emerges naturally. It's like perlin noise a bit, but within a jittered \r\n// grid like voronoi):\r\n//\r\n// voronoise(x) = pattern(1,1,x)\r\n//\r\n// Not sure what one would use this generalization for, because it's slightly slower \r\n// than perlin or voronoise (and certainly much slower than cell noise), and in the \r\n// end as a shading TD you just want one or another depending of the type of visual \r\n// features you are looking for, I can't see a blending being needed in real life.  \r\n// But well, if only for the math fun it was worth trying. And they say a bit of \r\n// mathturbation can be healthy anyway!\r\n// Use the mouse to blend between different patterns:\r\n// cell noise   u=0,v=0\r\n// voronoi      u=1,v=0\r\n// perlin noise u=0,v=1\r\n// voronoise    u=1,v=1\r\n// More info here: http://iquilezles.org/www/articles/voronoise/voronoise.htm\r\n// psudo-random number generator\r\nfloat iqhash2(vec2 p) {\r\n  vec2 q = vec2(dot(p, vec2(127.1,311.7)), dot(p, vec2(269.5,183.3)));\r\n  return abs(fract(sin(q.x*q.y)*43758.5453123)-0.5)*2.0;\r\n}\r\nvec2 iqhash2vec(vec2 p) {\r\n  vec2 q = vec2(dot(p, vec2(127.1,311.7)), dot(p, vec2(269.5,183.3)));\r\n  return -1.0 + 2.0 * fract(sin(q)*43758.5453123);\r\n}\r\n\r\n\r\nvec3 iqhash3( vec2 p ) {\r\n  vec3 q = vec3(dot(p,vec2(127.1,311.7)), \r\n                dot(p,vec2(269.5,183.3)), \r\n                dot(p,vec2(419.2,371.9)) );\r\n  return fract(sin(q)*43758.5453);\r\n}\r\n\r\nfloat iqnoise( in vec2 x, float u, float v ) {\r\n  vec2 p = floor(x);\r\n  vec2 f = fract(x);\r\n  float k = 1.0+63.0*pow(1.0-v,4.0);\r\n  float va = 0.0;\r\n  float wt = 0.0;\r\n  for( int j=-2; j<=2; j++ ) {\r\n    for( int i=-2; i<=2; i++ ) {\r\n      vec2 g = vec2( float(i),float(j) );\r\n      vec3 o = iqhash3( p + g )*vec3(u,u,1.0);\r\n      vec2 r = g - f + o.xy;\r\n      float d = dot(r,r);\r\n      float ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\r\n      va += o.z*ww;\r\n      wt += ww;\r\n    }\r\n  }\r\n  return va/wt;\r\n}\r\n\r\n// https://www.shadertoy.com/view/MdX3Rr by inigo quilez\r\nconst mat2 iqfbmM = mat2(0.8,-0.6,0.6,0.8);\r\nfloat iqfbm( in vec2 p ) {\r\n  float f = 0.0;\r\n  f += 0.5000*pnoise( p ); p = iqfbmM*p*2.02;\r\n  f += 0.2500*pnoise( p ); p = iqfbmM*p*2.03;\r\n  f += 0.1250*pnoise( p ); p = iqfbmM*p*2.01;\r\n  f += 0.0625*pnoise( p );\r\n  return f/0.9375;\r\n}\r\n\r\n\r\n// simplex noise\r\n\r\nvec2 mod289(vec2 x) {\r\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\r\n}\r\n\r\nvec3 mod289(vec3 x) {\r\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\r\n}\r\n\r\nvec4 mod289(vec4 x) {\r\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\r\n}\r\n\r\nvec3 permute(in vec3 x) {\r\n  return mod289(((x*34.0)+1.0)*x);\r\n}\r\n\r\nvec4 permute(in vec4 x) {\r\n  return mod289(((x*34.0)+1.0)*x);\r\n}\r\n\r\nvec4 taylorInvSqrt(in vec4 r) {\r\n  return 1.79284291400159 - 0.85373472095314 * r;\r\n}\r\n\r\nfloat snoise(in vec2 v) {\r\n  const vec4 C = vec4(0.211324865405187, // (3.0-sqrt(3.0))/6.0\r\n                      0.366025403784439, // 0.5*(sqrt(3.0)-1.0)\r\n                     -0.577350269189626, // -1.0 + 2.0 * C.x\r\n                      0.024390243902439); // 1.0 / 41.0\r\n// First corner\r\n  vec2 i = floor(v + dot(v, C.yy) );\r\n  vec2 x0 = v - i + dot(i, C.xx);\r\n\r\n// Other corners\r\n  vec2 i1;\r\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\r\n  //i1.y = 1.0 - i1.x;\r\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\r\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\r\n  // x1 = x0 - i1 + 1.0 * C.xx ;\r\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\r\n  vec4 x12 = x0.xyxy + C.xxzz;\r\n  x12.xy -= i1;\r\n\r\n// Permutations\r\n  i = mod289(i); // Avoid truncation effects in permutation\r\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\r\n+ i.x + vec3(0.0, i1.x, 1.0 ));\r\n\r\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\r\n  m = m*m ;\r\n  m = m*m ;\r\n\r\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\r\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\r\n\r\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\r\n  vec3 h = abs(x) - 0.5;\r\n  vec3 ox = floor(x + 0.5);\r\n  vec3 a0 = x - ox;\r\n\r\n// Normalise gradients implicitly by scaling m\r\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\r\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\r\n\r\n// Compute final noise value at P\r\n  vec3 g;\r\n  g.x = a0.x * x0.x + h.x * x0.y;\r\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\r\n  return 130.0 * dot(m, g);\r\n}\r\n\r\n\r\nfloat snoise(vec3 v) {\r\nconst vec2  C = vec2(1.0/6.0, 1.0/3.0);\r\nconst vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\r\n\r\n// First corner\r\nvec3 i  = floor(v + dot(v, C.yyy) );\r\nvec3 x0 =   v - i + dot(i, C.xxx) ;\r\n\r\n// Other corners\r\nvec3 g = step(x0.yzx, x0.xyz);\r\nvec3 l = 1.0 - g;\r\nvec3 i1 = min( g.xyz, l.zxy );\r\nvec3 i2 = max( g.xyz, l.zxy );\r\n\r\n// x0 = x0 - 0.0 + 0.0 * C.xxx;\r\n// vec3 x1 = x0 - i1 + 1.0 * C.xxx;\r\n// vec3 x2 = x0 - i2 + 2.0 * C.xxx;\r\n// vec3 x3 = x0 - 1.0 + 3.0 * C.xxx;\r\nvec3 x1 = x0 - i1 + C.xxx;\r\nvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\r\nvec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\r\n\r\n// Permutations\r\n\ti = mod289(i); \r\n\tvec4 p = permute( permute( permute( \r\n           i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\r\n         + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \r\n         + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\r\n\r\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\r\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\r\nfloat n_ = 0.142857142857; // 1.0/7.0\r\nvec3  ns = n_ * D.wyz - D.xzx;\r\n\r\nvec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\r\n\r\nvec4 x_ = floor(j * ns.z);\r\nvec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\r\n\r\nvec4 x = x_ *ns.x + ns.yyyy;\r\nvec4 y = y_ *ns.x + ns.yyyy;\r\nvec4 h = 1.0 - abs(x) - abs(y);\r\n\r\nvec4 b0 = vec4( x.xy, y.xy );\r\nvec4 b1 = vec4( x.zw, y.zw );\r\n\r\n//vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\r\n//vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\r\nvec4 s0 = floor(b0)*2.0 + 1.0;\r\nvec4 s1 = floor(b1)*2.0 + 1.0;\r\nvec4 sh = -step(h, vec4(0.0));\r\n\r\nvec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\r\nvec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\r\n\r\nvec3 p0 = vec3(a0.xy,h.x);\r\nvec3 p1 = vec3(a0.zw,h.y);\r\nvec3 p2 = vec3(a1.xy,h.z);\r\nvec3 p3 = vec3(a1.zw,h.w);\r\n\r\n//Normalise gradients\r\nvec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\r\np0 *= norm.x;\r\np1 *= norm.y;\r\np2 *= norm.z;\r\np3 *= norm.w;\r\n\r\n// Mix final noise value\r\nvec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\r\nm = m * m;\r\nreturn 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\r\n}\r\n\r\n// vec4 grad4(float j, vec4 ip) {\r\n//   const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\r\n//   vec4 p,s;\r\n//   p.xyz = floor(fract(vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\r\n//   p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\r\n//   s = vec4(lessThan(p,vec4(0.0)));\r\n//   p.xyz = p.xyz + (s.xyz*2.0-1.0)*s.www;\r\n//   return p;\r\n// }\r\n\r\n// float snoise(in vec4 v) {\r\n//   const vec4 C = vec4(0.138196601125011, // (5-sqrt(5))/20 G4\r\n//                       0.276393202250021, // 2 * G4\r\n//                       0.414589803375032, // 3 * G4\r\n//                      -0.447213595499958); // -1 + 4 * G4\r\n\r\n//   // First corner\r\n//   vec4 i = floor(v + dot(v, C.yyyy));\r\n//   vec4 x0 = v - i + dot(i, C.xxxx);\r\n\r\n//   // Other corners\r\n\r\n//   // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\r\n//   vec4 i0;\r\n//   vec3 isX = step(x0.yzw, x0.xxx);\r\n//   vec3 isYZ = step(x0.zww, x0.yyz);\r\n//   // i0.x = dot(isX, vec3(1.0));\r\n//   i0.x = isX.x + isX.y + isX.z;\r\n//   i0.yzw = 1.0 - isX;\r\n//   // i0.y += dot(isYZ.xy, vec2(1.0));\r\n//   i0.y += isYZ.x + isYZ.y;\r\n//   i0.zw += 1.0 - isYZ.xy;\r\n//   i0.z += isYZ.z;\r\n//   i0.w += 1.0 - isYZ.z;\r\n\r\n//   // i0 now contains the unique values 0,1,2,3 in each channel\r\n//   vec4 i3 = clamp(i0, 0.0, 1.0);\r\n//   vec4 i2 = clamp(i0-1.0, 0.0, 1.0);\r\n//   vec4 i1 = clamp(i0-2.0, 0.0, 1.0);\r\n\r\n//   // x0 = x0 - 0.0 + 0.0 * C.xxxx\r\n//   // x1 = x0 - i1 + 1.0 * C.xxxx\r\n//   // x2 = x0 - i2 + 2.0 * C.xxxx\r\n//   // x3 = x0 - i3 + 3.0 * C.xxxx\r\n//   // x4 = x0 - 1.0 + 4.0 * C.xxxx\r\n//   vec4 x1 = x0 - i1 + C.xxxx;\r\n//   vec4 x2 = x0 - i2 + C.yyyy;\r\n//   vec4 x3 = x0 - i3 + C.zzzz;\r\n//   vec4 x4 = x0 + C.wwww;\r\n\r\n//   // Permutations\r\n//   i = mod289(i);\r\n//   float j0 = permute(permute(permute(permute(i.w) + i.z) + i.y) + i.x);\r\n//   vec4 j1 = permute(permute(permute(permute(\r\n//       i.w + vec4(i1.w, i2.w, i3.w, 1.0))\r\n//     + i.z + vec4(i1.z, i2.z, i3.z, 1.0))\r\n//     + i.y + vec4(i1.y, i2.y, i3.y, 1.0))\r\n//     + i.z + vec4(i1.z, i2.z, i3.z, 1.0))\r\n//   ))));\r\n\r\n//   // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\r\n//   // 7x7x6 = 294, which is close to the ring size 17*17=289.\r\n//   vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0);\r\n\r\n//   vec4 p0 = grad4(j0,   ip);\r\n//   vec4 p1 = grad4(j1.x, ip);\r\n//   vec4 p2 = grad4(j1.y, ip);\r\n//   vec4 p3 = grad4(j1.z, ip);\r\n//   vec4 p4 = grad4(j1.w, ip);\r\n\r\n//   // Normalize gradients\r\n//   vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\r\n//   p0 *= norm.x;\r\n//   p1 *= norm.y;\r\n//   p2 *= norm.z;\r\n//   p3 *= norm.w;\r\n//   p4 *= taylorInvSqrt(dot(p4,p4));\r\n\r\n//   // Mix contributions from the five corners\r\n//   vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(p2,x2)), 0.0);\r\n//   vec3 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)), 0.0);\r\n//   m0 = m0*m0;\r\n//   m1 = m1*m1;\r\n//   return 49.0 * (dot(m0*m0), vec3(dot(p0,x0), dot(p1,x1), dot(p2,x2))) + \r\n//     dot(m1*m1, vec2(dot(p3,x3), dot(p4,x4)));\r\n// }",noiseGraphFrag:"if (cNoiseGraphEnable) {\r\n  graph = clamp(graph, 0.0, 1.0);\r\n  graph = step(graph - fract(pin.uv.y), 0.0);\r\n  pout.color = mix(vec3(0.0, 0.5, 0.0), vec3(1.0), graph);\r\n}",noiseUniforms:{cNoiseOctave:{value:6},cNoiseFrequency:{value:2},cNoiseAmplitude:{value:.65},cNoisePersistence:{value:.5},cNoiseGraphEnable:{value:!1}},particleFrag:"vec3 col = vec3(0.);\r\nfor (float i=0.0; i<PARTICLE_COUNT; i++) {\r\n    if (i>=cCount) break;\r\n    float seed = SEED + floor(i/cCount+time);\r\n    vec2 anchor = vec2(0.5, 0.5);\r\n    vec2 velocity = vec2(mix(-.5, .5, rand(vec2(seed,i))),mix(-.5, .5, rand(vec2(i,seed)/3.)));\r\n    float creationTime = time - fract(i/cCount + time);\r\n    col += particle(pin.uv, 0., anchor, velocity, creationTime) * currentColor();\r\n}\r\ncol = smoothstep(.6, .9, col);\r\npout.color = vec3(rgb2gray(col));",particleFragPars:"// https://www.shadertoy.com/view/llGBWw\r\nuniform float cSize;\r\nuniform float cLifeTime;\r\nuniform float cGravity;\r\nuniform float cCount;\r\n#define SEED 0.12345679\r\n#define GRAV vec2(0,-.26)\r\n#define SIZE 0.024\r\n#define DIE_TIME 0.9\r\n#define PARTICLE_COUNT 500.0\r\n\r\nfloat particle(vec2 uv, float identifier, vec2 anchor, vec2 velocity, float creationTime) {\r\n    float particleTime = max(0., time - creationTime);\r\n    float size = max(0., cLifeTime - particleTime) * cSize;\r\n    vec2 velocityOffset = velocity * particleTime;\r\n    vec2 gravityOffset = vec2(0,-cGravity) * pow(particleTime, 1.798);\r\n    vec2 point = anchor + velocityOffset + gravityOffset;\r\n    float dist = distance(uv, point);\r\n    float hit = smoothstep(size, 0., dist);\r\n    return hit;\r\n}\r\nvec3 currentColor() {\r\n    float c = time * 0.2;\r\n    float r = sin(c*PI)/2. + .5;\r\n    float g = sin((c+.6)*PI)/2. +.5;\r\n    float b = sin((c+1.2)*PI)/2. + .5;\r\n    return vec3(r,g,b);\r\n}\r\n\r\n",particleUniforms:{cSize:{value:.024},cLifeTime:{value:.9},cGravity:{value:.26},cCount:{value:300}},pentagonFrag:"vec2 R = resolution.xy;\r\nvec2 U = pin.coord;\r\nvec2 V = U = (U+U-R) / R.y;\r\nvec3 O = vec3(0.0);\r\n\r\nU = U * rotate2d(0.3+time);\r\n\r\nfloat p = 0.6283; // = 2Pi/10\r\nfloat x,y;\r\nfloat a = mod(atan(U.y,U.x) + p, p+p)-p; // 2Pi/5 symmetry\r\nU = P(length(U), a)*1.25;\r\nx = U.x;\r\ny = U.y = abs(U.y); // mirror symmetry in each fan\r\n\r\n// B S( x-0.6*cSize  - 0.4*y, 0.01+cWidth*0.01); // exterior thin wall\r\nB S( x-cScale*0.5  - cAlpha*y, 0.5*cWidth); // exterior thin wall\r\n// B S( x-0.67 + 1.2*y, 0.01) * S(abs(y), 0.04)*0.6;\r\n\r\n// B S( x-cStarX*0.5  - cStarY*y, 0.5*cWidth) // thick wall\r\n  // * max(S(y,0.45),\r\n  //       C(P(0.83,p), 0.07));\r\n\r\n// B S( x-0.46, 0.06) * S(y, 0.19) // interior bar attached to thick wall\r\n//   * (1.0 - C(vec2(0.477,0.18), 0.045));\r\n\r\n// U *= 0.72;\r\n// B S( U.x-0.5 - 0.4*U.y, 0.05) * 0.3 // exterior pit (by scaling thick wall)\r\n//   * max(S(U.y, 0.45),\r\n//         C(P(0.83,p), 0.07))\r\n//   * (0.6 + 0.4*cos(200.0*a)); // radial strips\r\n\r\n// B S( x-1.7 - 0.4*y, 0.9) * 0.3\r\n//   * max(0.0, cos(200.0*V.y) - 0.6); // background strips (V: before 5-sym)\r\n\r\n// O += (1.0-O)*0.3; // B&W background\r\n//O = mix(vec3(1.0, 0.95, 0.6), vec3(0.6, 0.3, 0.3), O); // background + color scheme\r\npout.color = O;\r\n",pentagonFragPars:"// https://www.shadertoy.com/view/MlBfWz\r\nuniform float cScale;\r\nuniform float cAlpha;\r\nuniform float cWidth;\r\n\r\n#define P(r,a) (r)*vec2(cos(a),sin(a)) // to polar\r\n#define S(v,tk) smoothstep(2.0/R.y, -2.0/R.y, abs(v)-(tk)) // darw bar (antialiased)\r\n#define C(p,r) (S(length(U-p), r) + S(length(U-p*vec2(1.0,-1.0)), r)) // draw(2 sym disks)\r\n#define B O += (1.0-O)* // blend",pentagonUniforms:{cScale:{value:1},cAlpha:{value:1},cWidth:{value:.02}},perlinNoiseFrag:"vec2 t = pin.coord + vec2(time * 10.0);\r\nfloat n = pnoise(t);\r\npout.color = vec3(n);\r\n\r\nfloat graph = pnoise(t.xx);",polarConversionFrag:"vec2 coords = pin.uv - vec2(0.5); // cartesian\r\n// cartesian -> polar\r\nfloat mag = length(coords) * 2.0; // length(coords) / 0.5\r\nif (mag > 1.0) {\r\n  pout.color = vec3(0.0);\r\n} else {\r\n  mag = clamp(mag, 0.0, 1.0);\r\n  float angle = atan(coords.y, coords.x);\r\n  angle -= 1.57079632679;\r\n  if (angle < 0.0) angle += 6.28318530718;\r\n  angle /= 6.28318530718;\r\n  vec4 c = texture2D(tDiffuse, vec2(angle, mag));\r\n  pout.color = c.rgb;\r\n}",polarConversionFragPars:"// https://gist.github.com/KeyMaster-/70c13961a6ed65b6677d\r\n// vec2 polar;\r\n// polar.y = sqrt(dot(pin.position, pin.position));\r\n// polar.y /= resolution.x / 0.5;\r\n// polar.y = 1.0 - polar.y;\r\n// \r\n// polar.x = atan(pin.position.y, pin.position.x);\r\n// polar.x -= 1.57079632679;\r\n// if (polar.x < 0.0) polar.x += 6.28318530718;\r\n// polar.x /= 6.28318530718;\r\n// polar.x = 1.0 - polar.x;\r\n// \r\n// vec4 c = texture2D(tDiffuse, polar);\r\n// pout.color = c.rgb;\r\n\r\nvec2 cartesian(vec2 coords) {\r\n  return coords - vec2(0.5);\r\n}\r\n\r\nvec2 cartToPolar(vec2 coords) {\r\n  float mag = length(coords) / 0.5;\r\n  if (mag > 1.0) return vec2(0.0);\r\n  mag = clamp(mag, 0.0, 1.0);\r\n  float angle = atan(coords.y, coords.x);\r\n//   angle += 1.57079632679;\r\n  if (angle < 0.0) angle += 6.28318530718;\r\n  angle /= 6.28318530718;\r\n  return vec2(angle, mag);\r\n}",randomNoiseFrag:"vec2 p = pin.uv - time*0.1;\r\nfloat lum = iqhash2(p);\r\npout.color = vec3(lum);\r\n\r\nfloat graph = iqhash2(p.xx);",randomNoiseFragPars:"// dummy",raymarch:"float box(vec2 p, vec2 b, float r) {\r\n  return length(max(abs(p)-b,0.0))-r;\r\n}",ringAnimFrag:"float t = 0.02 / abs(sin(time) - length(pin.position));\r\npout.color = vec3(t);",ringFrag:"float t = cWidth / (abs(cRadius - length(pin.position)));\r\nt = pow(t, cPowerExponent);\r\npout.color = vec3(t);",ringFragPars:"uniform float cRadius;\r\nuniform float cWidth;\r\nuniform float cPowerExponent;",ringUniforms:{cRadius:{value:.5},cWidth:{value:.1},cPowerExponent:{value:1}},seemlessNoiseFrag:"float map = min(resolution.x, resolution.y) * cNoiseScale;\r\nvec2 t = mod(pin.coord.xy + vec2(time * 10.0), map);\r\nfloat n = psnoise(t, t / map, vec2(map));\r\npout.color = vec3(n);\r\n\r\nfloat graph = psnoise(t.xx, t.xx/map, vec2(map));",seemlessNoiseFragPars:"uniform float cNoiseScale;",seemlessNoiseUniforms:{cNoiseScale:{value:1}},silexarsFrag:"vec3 c;\r\nfloat l, z = sin(time) * 1.0 + 17.0;\r\nfor (int i=0; i<3; i++) {\r\n  vec2 uv = pin.uv;\r\n  vec2 p = uv - 0.5;\r\n  z += 0.07;\r\n  l = length(p);\r\n  uv += p / l * (sin(z) + 1.0) * abs(sin(l*9.0-z*2.0));\r\n  c[i] = 0.01 / length(abs(mod(uv, 1.0)-0.5));\r\n}\r\npout.color = c/l;",smokeFrag:"// http://glslsandbox.com/e#37011.6\r\nfloat rot = -1.0 * time * 0.2;\r\nvec3 ro = vec3(0.0, -0.0, -1.0); // 4.0 * normalize(vec3(cos(rot), 0.0, sin(rot)))\r\nvec3 ta = vec3(0.0);\r\n\r\n// build ray\r\nvec3 ww = normalize(ta - ro);\r\nvec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\r\nvec3 vv = normalize(cross(ww, uu));\r\nvec3 rd = normalize(pin.position.x*uu + pin.position.y*vv + 0.8*ww);\r\n\r\n// vec3 rd = normalize(vec3(pin.position, 2.0));\r\n// circle\r\nfloat circle_radius = 1.0;\r\nfloat border = 0.015;\r\nvec4 bkg_color = vec4(0.0);\r\nvec4 circle_color = vec4(1.0);\r\nfloat dist = sqrt(dot(pin.position, pin.position));\r\nif ((dist > (circle_radius + border)) || (dist < (circle_radius - border))) {\r\n  circle_color = bkg_color;\r\n}\r\n\r\n// raymarch\r\npout.color = raymarch(ro, rd);",smokeFragPars:"// http://glslsandbox.com/e#37011.6\r\nuniform float cVolume;\r\nuniform float cBeta;\r\nuniform float cDelta;\r\n\r\nfloat hash(float n) { return fract(sin(n) * 783.5453123); }\r\n\r\nfloat noise(in vec3 x) {\r\n  vec3 p = floor(x);\r\n  vec3 f = fract(x);\r\n  f = f*f*(3.0-2.0*f);\r\n  float n = p.x + p.y * 157.0 + 113.0 * p.z;\r\n  return mix(mix(mix(hash(n+  0.0), hash(n+  1.0), f.x),\r\n                 mix(hash(n+157.0), hash(n+158.0), f.x), f.y),\r\n             mix(mix(hash(n+113.0), hash(n+114.0), f.x),\r\n                 mix(hash(n+270.0), hash(n+271.0), f.x), f.y), f.z);\r\n}\r\n\r\nfloat fbm(vec3 p) {\r\n  float f;\r\n  f = 0.50000 * noise(p); p = p*2.02;\r\n  f += 0.2500 * noise(p); p = p*2.03;\r\n  f += 0.1250 * noise(p); p = p*2.01;\r\n  f += 0.0625 * noise(p);\r\n  return f;\r\n}\r\n\r\nfloat sdEllipsoid(in vec3 p, in vec3 r) {\r\n  return (length(p/r) - 1.0) * min(min(r.x, r.y), r.z);\r\n}\r\n\r\nfloat map(in vec3 p, float f, vec3 r) {\r\n  float den = sdEllipsoid(p, r);\r\n  den = smoothstep(-0.1, 0.25, den);\r\n  den = -den - (sin(0.0) + 1.0) * 0.3;\r\n  return clamp(den + f, 0.0, 1.0);\r\n}\r\n\r\n// vec3 light(vec3 ro, vec3 rd) {\r\n//   vec4 rnd = vec4(0.1, 0.2, 0.3, 0.4);\r\n//   float arclight = 0.0;\r\n//   vec3 pos = ro + rd;\r\n//   for (int i=0; i<3; ++i) {\r\n//     rnd = fract(sin(rnd * 1.111111) * 298729.258972);\r\n//     float ts = rnd.z * 4.0 * 1.61803398875 + 1.0;\r\n//     float arcfl = floor(time / ts + rnd.y) * ts;\r\n//     float arcfr = fract(time / ts + rnd.y) * ts;\r\n//     float arcseed = floor(time * 1.0 + rnd.y);\r\n//     float arcdur = rnd.x * 0.2 + 0.05;\r\n//     float arcint = smoothstep(0.1 + arcdur, arcdur, arcfr);\r\n//     arclight += exp(-0.5) * fract(sin(arcseed) * 198721.6231) * arcint;\r\n//   }\r\n//   vec3 arccol = vec3(0.9, 0.7, 0.7);\r\n//   vec3 lighting = arclight * arccol * 0.5;\r\n//   return lighting;\r\n// }\r\n\r\nvec3 raymarch(in vec3 ro, in vec3 rd) {\r\n  vec4 sum = vec4(0.0);\r\n  float t = 0.0;\r\n  for (int i=0; i<100; ++i) {\r\n    if (sum.a > 0.99) break;\r\n    vec3 pos = ro + t*rd;\r\n    float f = fbm(cBeta * pos + vec3(0.0, 0.0, 0.25) * time);\r\n    float d = map(pos, f, vec3(1.0, 1.0, 0.5));\r\n//     vec4 col = vec4(mix(vec3(0.07, 0.1, 0.2), vec3(1.5), d), 1.0);\r\n    vec4 col = vec4(mix(vec3(0.0), vec3(1.5), d), 1.0);\r\n    col *= d*cVolume;\r\n    sum += col * (1.0 - sum.a);\r\n    t += cDelta;\r\n  }\r\n//   vec3 lighting = light(ro, rd);\r\n//   vec3 rain_cloud = mix(vec3(0.0), lighting, sum.a);\r\n//   rain_cloud += sum.rgb;\r\n//   vec3 sky_color = mix(rain_cloud, vec3(0.5, 0.5, 0.3), 1.0 - sum.a);\r\n//   vec3 sky_color = mix(rain_cloud, vec3(0.0), 1.0 - sum.a);\r\n//   return clamp(sky_color, 0.0, 1.0);\r\n  return clamp(mix(sum.rgb, vec3(0.0), 1.0 - sum.a), 0.0, 1.0);\r\n}",smokeUniforms:{cVolume:{value:3},cBeta:{value:4},cDelta:{value:.05}},snowFrag:"t = time * cSpeed;\r\n\r\nfloat c = .0;\r\nif (cDensity > 4.) c += snow(pin.uv, 30.);\r\nif (cDensity > 3.) c += snow(pin.uv, 15.);\r\nif (cDensity > 2.) c += snow(pin.uv, 10.);\r\nc += snow(pin.uv, 5.);\r\nif (cDensity > 1. && cDensity < 5.5) c += snow(pin.uv, 3.);\r\n\r\n\r\nvec3 finalColor = vec3(c*.6);\r\n\r\nvec2 v = pin.position;\r\nfinalColor *= (.5+cRange - sqrt((v.x*v.x) + (v.y*v.y)))*2.5;\r\n\r\n// vec2 p = pin.uv;\r\n// p = 2.*p - 2.;\r\n// p.x *= resolution.x / resolution.y;\r\n// p.x -= time * .125;\r\n// float a = 0.5;\r\n// float n = pin.coord.y / resolution.y;\r\n// n *= n;\r\n// n *= snowNoise(p*2.) * a;\r\n// finalColor += vec3(n) * 1.2;\r\n\r\npout.color = finalColor;",snowFragPars:"uniform float cSpeed;\r\nuniform float cScale;\r\nuniform float cDensity;\r\nuniform float cRange;\r\nfloat t = 0.0;\r\n\r\nvec2 snowHash(in vec2 p) {\r\n  return cos(t + sin(mat2(17., 5., 3., 257.) * p - p) * 1234.5678);\r\n}\r\n\r\nfloat snowNoise(in vec2 p) {\r\n  const float K1 = (sqrt(3.)-1.)/2.;\r\n  const float K2 = (3.-sqrt(3.))/6.;\r\n  vec2 i = floor(p+(p.x + p.y)*K1);\r\n  vec2 a = p - i + (i.x + i.y)*K2;\r\n  vec2 o = (a.x > a.y) ? vec2(1., 0.) : vec2(0., 1.);\r\n  vec2 b = a - o + K2;\r\n  vec2 c = a - 1. + 2. * K2;\r\n  vec3 h = (.5 - vec3(dot(a,a), dot(b,b), dot(c,c))) * 3.;\r\n  vec3 n = vec3(dot(a,snowHash(i)), dot(b, snowHash(i+o)), dot(c, snowHash(i+1.)));\r\n  return dot(n, h*h*h*h*h)*.5 + .5;\r\n}\r\n\r\nfloat snow(vec2 uv, float scale) {\r\n  float w = smoothstep(1., 0., -uv.y * (scale / 40.0));\r\n  uv += t/scale;\r\n  uv.y += t/scale;\r\n  uv.x += sin(uv.y + t*.25)/scale;\r\n  uv *= scale;\r\n  \r\n  vec2 s = floor(uv);\r\n  vec2 f = fract(uv);\r\n  float k = 4.;\r\n  vec2 p = .5 + .3 * sin(11. * fract(sin((s+scale)*mat2(7., 3., 6., 5.))*5.)) - f;\r\n  float d = length(p);\r\n  k = min(d,k);\r\n  k = smoothstep(0., k, sin(f.x + f.y)*.01);\r\n  return w*k*(cScale*5.0);\r\n}",snowUniforms:{cSpeed:{value:.2},cScale:{value:.5},cDensity:{value:5},cRange:{value:.5}},solarFrag:"// float t = 1.0 / (length(pin.position) * solarIntensity);\r\nfloat t = cIntensity / (length(pin.position));\r\nt = pow(t, cPowerExponent);\r\npout.color = vec3(t);",solarFragPars:"uniform float cIntensity;\r\nuniform float cPowerExponent;",solarUniforms:{cIntensity:{value:.4},cPowerExponent:{value:1}},sparkFrag:"vec2 n = normalize(pin.position);\r\nfloat t = cIntensity * 2.0 / length(pin.position);\r\nfloat r = pnoise(n*resolution+time) * 2.0;\r\nr = max(t-r, 0.0);\r\nr = pow(r, cPowerExponent);\r\npout.color = vec3(r);",sparkFragPars:"uniform float cIntensity;\r\nuniform float cPowerExponent;",sparkNoiseFrag:"float lum = fbm(vec3(pin.uv * 16.0 * cNoiseFrequency, time));\r\npout.color = vec3(lum);\r\n\r\nfloat graph = fbm(vec3(pin.uv.xx * 16.0 * cNoiseFrequency, time));",sparkNoiseFragPars:"float fbm(vec3 v) {\r\n  float n = 0.0;\r\n  n += 1.0000 * abs(snoise(v));\r\n  n += 0.5000 * abs(snoise(v*2.0));\r\n  n += 0.2500 * abs(snoise(v*4.0));\r\n  n += 0.1250 * abs(snoise(v*8.0));\r\n  float rn = 1.0 - n;\r\n  return rn*rn;\r\n}",sparkUniforms:{cIntensity:{value:.5},cPowerExponent:{value:1}},speckleFrag:"float w = 1.0 - dot(pin.position, pin.position) * mix(100.0, 3.0, cRadius);\r\nvec2 uv = pin.position * mix(48.0, 1.0, cScale);\r\nvec2 ip = floor(uv);\r\nvec2 v = cellular2x2x2(vec3(uv, time/2.0));\r\nfloat c = v.x; // v.y - v.x\r\nc -= (0.35 + 1.0*cDensity)*w;\r\nc = smoothstep(0.0, max(0.1/c, 0.0), c);\r\nc = mix(0.0, 1.0, c);\r\npout.color = vec3(1.0 - sqrt(max(c, 0.0)));",speckleFragPars:"// https://www.shadertoy.com/view/XlSBDz\r\nuniform float cRadius;\r\nuniform float cScale;\r\nuniform float cDensity;\r\n\r\n// Cellular noise, returning F1 and F2 in a vec2.\r\n// Speeded up by using 2x2x2 search window instead of 3x3x3,\r\n// at the expense of some pattern artfiacts.\r\n// F2 is often wrong and has sharp discontinuities.\r\n// If you need a good F2, use th slower 3x3x3 version.\r\nvec2 cellular2x2x2(vec3 P) {\r\n  #define K 0.142957142857 // 1/7\r\n  #define Ko 0.428571428571 // 1/2-K/2\r\n  #define K2 0.020408163265306 // 1/(7*7)\r\n  #define Kz 0.166666666667 // 1/6\r\n  #define Kzo 0.416666666667 // 1/2-1/6*2\r\n  #define jitter 0.8 // smaller jitter gives less errors in F2\r\n  vec3 Pi = mod(floor(P), 289.0);\r\n  vec3 Pf = fract(P);\r\n  vec4 Pfx = Pf.x + vec4(0.0, -1.0, 0.0, -1.0);\r\n  vec4 Pfy = Pf.y + vec4(0.0, 0.0, -1.0, -1.0);\r\n  vec4 p = permute(Pi.x + vec4(0.0, 1.0, 0.0, 1.0));\r\n  p = permute(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0));\r\n  vec4 p1 = permute(p + Pi.z); // z+0\r\n  vec4 p2 = permute(p + Pi.z + vec4(1.0)); // z+1\r\n  vec4 ox1 = fract(p1*K) - Ko;\r\n  vec4 oy1 = mod(floor(p1*K), 7.0)*K - Ko;\r\n  vec4 oz1 = floor(p1*K2)*Kz - Kzo; // p1 < 289 guaranteed\r\n  vec4 ox2 = fract(p2*K) - Ko;\r\n  vec4 oy2 = mod(floor(p2*K), 7.0)*K - Ko;\r\n  vec4 oz2 = floor(p2*K2)*Kz - Kzo;\r\n  vec4 dx1 = Pfx + jitter*ox1;\r\n  vec4 dy1 = Pfy + jitter*oy1;\r\n  vec4 dz1 = Pf.z + jitter*oz1;\r\n  vec4 dx2 = Pfx + jitter*ox2;\r\n  vec4 dy2 = Pfy + jitter*oy2;\r\n  vec4 dz2 = Pf.z - 1.0 + jitter*oz2;\r\n  vec4 d1 = dx1*dx1 + dy1*dy1 + dz1*dz1; // z+0\r\n  vec4 d2 = dx2*dx2 + dy2*dy2 + dz2*dz2; // z+1\r\n  \r\n  // Sort out the two smallest distances (F1, F2)\r\n  // Do it right and sort out both F1 and F2\r\n  vec4 d = min(d1,d2); // F1 is now in d\r\n  d2 = max(d1,d2); // Make sure we keep all candidates for F2\r\n  d.xy = (d.x < d.y) ? d.xy : d.yx; // Swap smallest to d.x\r\n  d.xz = (d.x < d.z) ? d.xz : d.zx;\r\n  d.xw = (d.x < d.w) ? d.xw : d.wx; // F1 is now in d.x\r\n  d.yzw = min(d.yzw, d2.yzw); // F2 now not in d2.yzw\r\n  d.y = min(d.y, d.z); // nor in d.z\r\n  d.y = min(d.y, d.w); // nor in d.w\r\n  d.y = min(d.y, d2.x); // F2 is now in d.y\r\n  return sqrt(d.xy); // F1 and F2\r\n}",speckleUniforms:{cRadius:{value:1},cScale:{value:1},cDensity:{value:1}},squigglesFrag:"vec3 color = vec3(0.0);\r\nfloat s = 1.0;\r\nfor (int i=0; i<numLayers; ++i) {\r\n    if (float(i)>=cDensity) break;\r\n    float sn = 0.0;\r\n    float y = 0.0;\r\n    \r\n    vec2 deriv;\r\n    float nx = smplxNoise2D(pin.position*s*mix(10., 1., cScale), deriv, 0.1+1./s, 0.0);\r\n    float ny = smplxNoise2D(pin.position*s*mix(10., 1., cScale), deriv, 0.11+1./s, 0.0);\r\n    for (int j=0; j<wormLength; ++j) {\r\n        if (float(j)>=cSize) break;\r\n        sn += smplxNoise2D(pin.position*s+vec2(1./s,0.)+vec2(nx,ny)*4., deriv, 0.2+1./s, y);\r\n        color += vec3(norm(deriv).z)/s;\r\n        y += 0.1;\r\n    }\r\n    s *= 1.1;\r\n}\r\ncolor /= 4.;\r\n\r\nvec2 deriv;\r\nfloat delay = smplxNoise2D(pin.position*s*1., deriv, 0.111, 0.);\r\npout.color = mix(color, vec3(1.0)-color, clamp(sin(time*0.25+pin.position.x*.5+delay*32.)*32., 0.0, 1.0));",squigglesFragPars:"uniform float cDensity;\r\nuniform float cSize;\r\nuniform float cScale;\r\n\r\n// https://www.shadertoy.com/view/MstBD4\r\n// Number of layars.\r\n// Higher value shows more layers of effects\r\n// Lower value higer FPS.\r\nconst int numLayers = 16;\r\n\r\n//Length of worm\r\nconst int wormLength = 8;\r\n\r\nfloat squigglesRand(vec3 pos) {\r\n    vec3 p = pos + vec3(2.);\r\n    vec3 fp = fract(p*p.yzx*222.)+vec3(2.);\r\n    p.y *= p.z * fp.x;\r\n    p.x *= p.y * fp.y;\r\n    return fract(p.x*p.x);\r\n}\r\n\r\nfloat skewF(float n) {\r\n    return (sqrt(n+1.0)-1.0)/n;\r\n}\r\n\r\nfloat unskewG(float n) {\r\n    return (1.0/sqrt(n+1.0)-1.0)/n;\r\n}\r\n\r\nvec2 smplxNoise2DDeriv(vec2 x, float m, vec2 g) {\r\n    vec2 dmdxy = min(dot(x,x)-vec2(0.5), 0.0);\r\n    dmdxy = 8.*x*dmdxy*dmdxy*dmdxy;\r\n    return dmdxy*dot(x,g) + m*g;\r\n}\r\n\r\nfloat smplxNoise2D(vec2 p, out vec2 deriv, float randKey, float roffset) {\r\n    // i is a skewed coordinate of a bottom vertex of a simplex where p is in.\r\n    vec2 i0 = floor(p+vec2(p.x+p.y)*skewF(2.0));\r\n    // x0, x1, x2 are unskewed displacement vectors.\r\n    float unskew = unskewG(2.0);\r\n    vec2 x0 = p-(i0+vec2((i0.x+i0.y)*unskew));\r\n\r\n    vec2 ii1 = x0.x > x0.y ? vec2(1.0,0.0) : vec2(0.0,1.0);\r\n    vec2 ii2 = vec2(1.0);\r\n    vec2 x1 = x0 - ii1 - vec2(unskew);\r\n    vec2 x2 = x0 - ii2 - vec2(2.0*unskew);\r\n\r\n    vec3 m = max(vec3(0.5)-vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\r\n    m = m*m;\r\n    m = m*m;\r\n\r\n    float r0 = 3.1416*2.0*squigglesRand(vec3(mod(i0, 16.0)/16.0, randKey));\r\n    float r1 = 3.1416*2.0*squigglesRand(vec3(mod(i0+ii1, 16.0)/16.0, randKey));\r\n    float r2 = 3.1416*2.0*squigglesRand(vec3(mod(i0+ii2, 16.0)/16.0, randKey));\r\n\r\n    float randKey2 = randKey + 0.01;\r\n    float spmin = 0.5;\r\n    float sps = 2.0;\r\n    float sp0 = spmin + sps*squigglesRand(vec3(mod(i0, 16.0)/16.0, randKey2));\r\n    float sp1 = spmin + sps*squigglesRand(vec3(mod(i0+ii1, 16.0)/16.0, randKey2));\r\n    float sp2 = spmin + sps*squigglesRand(vec3(mod(i0+ii2, 16.0)/16.0, randKey2));\r\n\r\n    r0 += time*sp0 + roffset;\r\n    r1 += time*sp1 + roffset;\r\n    r2 += time*sp2 + roffset;\r\n\r\n    // Gradients\r\n    vec2 g0 = vec2(cos(r0), sin(r0));\r\n    vec2 g1 = vec2(cos(r1), sin(r1));\r\n    vec2 g2 = vec2(cos(r2), sin(r2));\r\n\r\n    deriv = smplxNoise2DDeriv(x0, m.x, g0);\r\n    deriv += smplxNoise2DDeriv(x1, m.y, g1);\r\n    deriv += smplxNoise2DDeriv(x2, m.z, g2);\r\n\r\n    return dot(m*vec3(dot(x0,g0), dot(x1,g1), dot(x2,g2)), vec3(1.0));\r\n}\r\n\r\nvec3 norm(vec2 deriv) {\r\n    deriv *= 2000.0;\r\n    vec3 tx = vec3(1.0, 0.0, deriv.x);\r\n    vec3 ty = vec3(0.0, 1.0, deriv.y);\r\n    return normalize(cross(tx,ty));\r\n}\r\n",squigglesUniforms:{cSize:{value:8},cScale:{value:.5},cDensity:{value:16}},sunFrag:"// https://www.shadertoy.com/view/MlKGDc by Iulian Marinescu Ghetau\r\n\r\ninitScene();\r\n\r\nvec3 col0 = rayTrace(pin.coord + vec2(0.0, 0.0));\r\nvec3 col1 = rayTrace(pin.coord + vec2(0.5, 0.0));\r\nvec3 col2 = rayTrace(pin.coord + vec2(0.0, 0.5));\r\nvec3 col3 = rayTrace(pin.coord + vec2(0.5, 0.5));\r\nvec3 col = 0.25 * (col0 + col1 + col2 + col3);\r\n\r\nvec3 gray = vec3(rgb2gray(col));\r\npout.color = mix(gray, col, cColor);",sunFragPars:'// https://www.shadertoy.com/view/MlKGDc by Iulian Marinescu Ghetau\r\n\r\nuniform float cRadius;\r\nuniform float cColor;\r\n\r\nstruct Ray {\r\n  vec3 o;\r\n  vec3 dir;\r\n};\r\n\r\nstruct Intersect {\r\n  vec3 pos;\r\n  vec3 norm;\r\n};\r\n\r\nvec4 obj;  // xyz - position, w - cRadius\r\n\r\nconst float eps = 1e-3;\r\n\r\n// Number of ray iteration\r\nconst int iterations = 15;\r\n\r\n// Next, I define an exposure time adn gamma value. At this point, I also create\r\n// a basic directional light and define the ambient light color; the color here\r\n// is mostly a matter of taste. Basically ... lighting controls.\r\nconst float exposure = 0.3;\r\nconst float gamma = 2.2;\r\nconst float intensity = 50.0;\r\n\r\n// The maximum Radius the Camera can move around (sync with the value in BufA)\r\nconst float cCamPanRadius = 10000.0;\r\n\r\n// The position of the saved camera variables in the Render Buffer A (sync with the value in BufA)\r\nconst vec2 txCamPos = vec2(0.0, 0.0);\r\nconst vec2 txCamForward = vec2(1.0, 0.0);\r\n\r\n// Convert val from [0,1] interval to [minVal,maxVal]\r\n// vec3 decode(vec3 val, float minVal, float maxVal) {\r\n//   return vec3(minVal) + (maxVal - minVal) * val;\r\n// }\r\n\r\n// The intersection functions are from inigo\'s article\r\n// http://www.iquilezles.org/www/articles/simplegpurt/simplegpurt.htm\r\nbool intSphere(in vec4 sp, in vec3 ro, in vec3 rd, in float tm, out float t) {\r\n  bool r = false;\r\n  vec3 d = ro - sp.xyz;\r\n  float b = dot(rd, d);\r\n  float c = dot(d,d) - sp.w*sp.w;\r\n  t = b*b-c;\r\n  if (t > 0.0) {\r\n    t = -b-sqrt(t);\r\n    r = (t > 0.0) && (t < tm);\r\n  }\r\n  return r;\r\n}\r\n\r\n// Ray Marching code based on Fiery Spikeball shader: https://www.shadertoy.com/view/4lBXzy#\r\n\r\n// #define DITHERING\r\n\r\n// Noise function based on https://www.shadertoy.com/view/4sfGzS\r\n// I tried the Iq\'s faster version but it shows discontinuities when you zoom in very close\r\nfloat hash(float n) { return fract(sin(n) * 783.5453123); }\r\n\r\nfloat noise(in vec3 x) {\r\n  vec3 p = floor(x);\r\n  vec3 f = fract(x);\r\n  f = f*f*(3.0-2.0*f);\r\n  float n = p.x + p.y * 157.0 + 113.0 * p.z;\r\n  return mix(mix(mix(hash(n+  0.0), hash(n+  1.0), f.x),\r\n                 mix(hash(n+157.0), hash(n+158.0), f.x), f.y),\r\n             mix(mix(hash(n+113.0), hash(n+114.0), f.x),\r\n                 mix(hash(n+270.0), hash(n+271.0), f.x), f.y), f.z);\r\n}\r\n\r\nfloat fbm(vec3 p) {\r\n  const mat3 m = mat3(1.0);\r\n  vec3 q = 0.1 * p;\r\n  float f;\r\n  f = 0.5000 * noise(q); q = m*q*2.01;\r\n  f += 0.2500 * noise(q); q = m*q*2.02;\r\n  f += 0.1250 * noise(q); q = m*q*2.03;\r\n  f += 0.0625 * noise(q);\r\n  return f;\r\n}\r\n\r\nfloat sdSphere(vec4 sp, vec3 p) {\r\n  return length(p - sp.xyz) - sp.w;\r\n}\r\n\r\nfloat dfSunSurface(vec3 p) {\r\n  float cs = cos(time * 0.1);\r\n  float si = sin(time * 0.1);\r\n  mat2 rM = mat2(cs, si, -si, cs);\r\n  p.xz *= rM;\r\n  return max(0.0, sdSphere(obj + vec4(0.0, 0.0, 0.0, -1.0), p) + fbm(p*60.0+time*2.0) * 0.15);\r\n}\r\n\r\n// See "Combustible Voronoi"\r\n// https://www.shadertoy.com/view/4tlSzl\r\nvec3 firePalette(float i) {\r\n  float T = 900.0 + 3500.0 * i; // Temperature range (in Kelvin)\r\n  vec3 L = vec3(7.4, 5.6, 4.4); // Red, green, blue wavelengths (in hundreds of nanometers).\r\n  L = pow(L, vec3(5.0)) * (exp(1.43876719683e5/(T*L))-1.0);\r\n  return 1.0 - exp(-5e8/L); // Exposure level. Set to "50." For "70," change the "5" to a "7," etc.\r\n}\r\n\r\nvec3 rayMarch(vec3 ro, vec3 rd, vec2 uv, out float dist) {\r\n// ld, td: local, total density\r\n// w: weighwing factor\r\n  float ld = 0.0, td = 0.0, w;\r\n\r\n// t: length of the ray\r\n// d: distance function\r\n  float d = 1.0, t = 0.0;\r\n\r\n// Distance threshold\r\n  const float h = 0.25;\r\n\r\n// total color\r\n  float tc = 0.0;\r\n\r\n  vec2 seed = uv + fract(time);\r\n\r\n// Tidied the raymarcher up a bit. Plus, got rid some redundancies... I think.\r\n\r\n  for (int i=0; i<30; i++) {\r\n    // Loop break conditions. Seems to work, but let me know if I\'ve \r\n    // overlooked something. The middle break isn\'t really used here, but\r\n    // it can help in certain situations.\r\n    if (td > (1.0 - 0.02) || d < 0.001*t || t>12.0)  break;\r\n\r\n    // evaluate distance function\r\n    // Took away the "0.5" factor, and put it below\r\n    d = dfSunSurface(ro + t*rd);\r\n\r\n    // check whether we are close enough (step)\r\n    // compute local density and weighing factor\r\n    ld = (h-d) * step(d, h);\r\n    w = (1.0 - td) * ld;\r\n\r\n    // accumulate color and density\r\n    tc += w*w + 1.0/70.0;  // Difference weight distribution\r\n    td += w;\r\n\r\n    // dithering implementation come from Eiffies\' https://www.shadertoy.com/view/MsBGRh\r\n    #ifdef DITHERING\r\n    // add in noise to reduce banding and create fuzz\r\n    d = abs(d) * (0.9 + 0.4*rnd(seed*vec2(i)));\r\n    #endif\r\n\r\n    // enforce minumum stepsize\r\n    // d = max(d, 0.01);\r\n\r\n    // step forward\r\n    t += d * 0.5;\r\n  }\r\n\r\n  dist = clamp(d, 0.0, 1.0);\r\n\r\n  return firePalette(tc);\r\n}\r\n\r\n// http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\r\n// mat3 rotMat(vec3 axis, float angle) {\r\n//   axis = normalize(axis);\r\n//   float s = sin(angle);\r\n//   float c = cos(angle);\r\n//   float oc = 1.0 - c;\r\n// \r\n//   return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\r\n//               oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\r\n//               oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\r\n// }\r\n\r\nvoid initScene() {\r\n  obj = vec4(0.0, 0.0, 0.0, 5.0 - 3.5 * (1.0 - cRadius));\r\n}\r\n\r\n// Get a Ray from the Camera position (read from BufA) to the fragment given by the uv coordinates\r\nRay calcFragmentRay(vec2 uv) {\r\n  vec3 camPos = vec3(0.0, 0.0, 12.0);\r\n  vec3 camForward = vec3(0.0, 0.0, -1.0);\r\n//   vec3 camPos = decode(loadValue(txCamPos), -cCamPanRadius, cCamPanRadius);\r\n//   vec3 camForward = decode(loadValue(txCamForward), -1.0, 0.0);\r\n  vec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));\r\n  vec3 camUp = cross(camForward, camRight);\r\n  return Ray(camPos, normalize(uv.x * camRight + uv.y * camUp + camForward));\r\n}\r\n\r\n// Intersects a ray with the scene and return the closest intersection\r\nbool intObjs(vec3 ro, vec3 rd, out Intersect hit) {\r\n  bool r = false;\r\n  float t = 0.0, tm = cCamPanRadius;\r\n  if (intSphere(obj, ro, rd, tm, t)) {\r\n    tm = t; r = true;\r\n    hit.pos = ro + tm * rd;\r\n    hit.norm = normalize(hit.pos - obj.xyz);\r\n  }\r\n  return r;\r\n}\r\n\r\n// Check if a ray is in the shadow\r\nbool inShadow(vec3 ro, vec3 rd) {\r\n  float t, tm = cCamPanRadius;\r\n  if (intSphere(obj, ro, rd, tm, t)) return true;\r\n  return false;\r\n}\r\n\r\n// Calculate the fresnel coef using Schlick\'s approximation\r\n// float calcFresnel(vec3 n, vec3 rd, float r0) {\r\n//   float ndotv = clamp(dot(n, -rd), 0.0, 1.0);\r\n//   return r0 + (1.0 - r0) * pow(1.0 - ndotv, 5.0);\r\n// }\r\n\r\nvec3 calcShading(Ray ray, Intersect hit, vec2 uv, out float sunDist) {\r\n// The Sun is shaded using a distance based function, \r\n// bounded by the objs[ixLight] sphere.\r\n// Start to march the ray from points equally distant from the\r\n// sun\'s center, this way the Sun\'s shading does not depend on the camera location.\r\n// (The Sun looks the same no matter where you look from)\r\n  vec3 col = rayMarch(hit.pos, ray.dir, uv, sunDist);\r\n  return col;\r\n}\r\n\r\nvec3 rayTrace(vec2 fragCoord) {\r\n// Pixels to fragment coordinates do not map one a one-to-one basis, so I need \r\n// to divide the fragment coordinates by the viewport resolution. I then offset \r\n// that by a fixed value to re-center the coordinate system.\r\n  vec2 uv = fragCoord / resolution - vec2(0.5);\r\n\r\n// For each fragment, create a ray at a fixed point of origin directed at\r\n// the coordinates of each fragment.\r\n  Ray ray = calcFragmentRay(uv);\r\n\r\n  float mask = 1.0; // accumulates reflected light (fresnel coefficient)\r\n  vec3 color = vec3(0.0); // accumulates color\r\n  for (int i=0; i <= iterations; i++) {\r\n    Intersect hit;\r\n    if (intObjs(ray.o, ray.dir, hit)) {\r\n      \r\n      float sunDist = 0.0;\r\n      color += mask * calcShading(ray, hit, uv, sunDist);\r\n\r\n//       float fresnel = calcFresnel(hit.norm, ray.dir, 0.0);\r\n\r\n// The sun\r\n      mask *= sunDist;\r\n// The original ray doesn\'t change\r\n// This allows to shade objects behind Sun\'s Corona\r\n      ray.o = hit.pos + eps * ray.dir;\r\n    } else {\r\n// If the trace failed\r\n      color += mask * vec3(0.0);\r\n      break;\r\n    }\r\n  }\r\n\r\n// Adjust for exposure and perform linear gamma correction\r\n//   color = pow(color * exposure, vec3(1.0 / gamma));\r\n\r\n  return color;\r\n}',sunUniforms:{cRadius:{value:1},cColor:{value:0}},tessNoiseFrag:"vec2 p = pin.uv - cOffset;\r\np *= pow(2.0, 13.0);\r\nvec4 a = tessNoise(p);\r\nvec4 n = vec4(a.x+a.y+a.z+a.w) * .5;\r\npout.color = vec3(n.xyz);\r\n\r\nfloat graph = n.x;",tessNoiseFragPars:"uniform float cOffset;\r\n\r\nvec4 tessNoise(vec2 p) {\r\n  vec4 base = vec4(p, 0.0, 0.0);\r\n  vec4 rotation = vec4(0.0, 0.0, 0.0, 0.0);\r\n  float theta = fract(time*1.025);\r\n  float phase = .55;\r\n  float frequency = .49 * mix(1.0, 1.2, cNoiseFrequency);\r\n  \r\n  vec4 result;\r\n  for (int i=0; i<16; i++) {\r\n    base += rotation;\r\n    rotation = fract(base.wxyz - base.zwxy + theta);\r\n    rotation *= (1.0 - rotation);\r\n    base *= frequency;\r\n    base += base.wxyz * phase;\r\n  }\r\n  return rotation * 2.0;\r\n}",tessNoiseUniforms:{cOffset:{value:.5}},testFrag:"vec2 p = (-resolution + 2.0*pin.coord) / resolution.y;\nvec2 m = mouse.xy / resolution.xy;\nvec3 ro = 4.0*normalize(vec3(sin(3.0*m.x), 0.4*m.y, cos(3.0*m.x)));\nvec3 ta = vec3(0.0,-1.0,0.0);\nmat3 ca = setCamera(ro, ta, 0.0);\nvec3 rd = ca*normalize(vec3(p.xy,1.5));\npout.color = render(ro, rd).xyz;",testFragPars:"uniform sampler2D tNoise;\nfloat noise(in vec3 x) {\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n  f = f*f*(3.0-2.0*f);\n  vec2 uv = (p.xy + vec2(37.0, 17.0)*p.z) + f.xy;\n  uv = (uv+0.5)/256.0;\n  uv = vec2(uv.x, -uv.y);\n  vec2 rg = texture2D(tNoise, uv).yx;\n  return -1.0 + 2.0*mix(rg.x, rg.y, f.z);\n}\nfloat map5(in vec3 p) {\n  vec3 q = p - vec3(0.0, 0.1, 1.0) * time;\n  float f;\n  f  = 0.50000*noise(q); q = q*2.02;\n  f += 0.25000*noise(q); q = q*2.03;\n  f += 0.12500*noise(q); q = q*2.01;\n  f += 0.06250*noise(q); q = q*2.02;\n  f += 0.03125*noise(q);\n  return clamp(1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0);\n}\nfloat map4(in vec3 p) {\n  vec3 q = p - vec3(0.0, 0.1, 1.0) * time;\n  float f;\n  f  = 0.50000*noise(q); q = q*2.02;\n  f += 0.25000*noise(q); q = q*2.03;\n  f += 0.12500*noise(q); q = q*2.01;\n  f += 0.06250*noise(q);\n  return clamp(1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0);\n}\nfloat map3(in vec3 p) {\n  vec3 q = p - vec3(0.0, 0.1, 1.0) * time;\n  float f;\n  f  = 0.50000*noise(q); q = q*2.02;\n  f += 0.25000*noise(q); q = q*2.03;\n  f += 0.12500*noise(q);\n  return clamp(1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0);\n}\nfloat map2(in vec3 p) {\n  vec3 q = p - vec3(0.0, 0.1, 1.0) * time;\n  float f;\n  f  = 0.50000*noise(q); q = q*2.02;\n  f += 0.25000*noise(q);\n  return clamp(1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0);\n}\nvec3 sundir = normalize(vec3(-1.0, 0.0, -1.0));\nvec4 integrate(in vec4 sum, in float dif, in float den, in vec3 bgcol, in float t) {\n  vec3 lin = vec3(0.65,0.7,0.75)*1.4 + vec3(1.0,0.6,0.3)*dif;\n  vec4 col = vec4(mix(vec3(1.0,0.95,0.8), vec3(0.25,0.3,0.35), den), den);\n  col.xyz *= lin;\n  col.xyz = mix(col.xyz, bgcol, 1.0-exp(-0.003*t*t));\n  col.a *= 0.4;\n  col.rgb *= col.a;\n  return sum + col*(1.0-sum.a);\n}\n#define MARCH(STEPS,MAPLOD) for(int i=0; i<STEPS; i++) { vec3 pos = ro + t*rd; if (pos.y<-3.0 || pos.y>2.0 || sum.a > 0.99) break; float den = MAPLOD(pos); if (den>0.01) { float dif = clamp((den - MAPLOD(pos+0.3*sundir))/0.6, 0.0, 1.0); sum = integrate(sum, dif, den, bgcol, t); } t += max(0.05, 0.02*t); }\nvec4 raymarch(in vec3 ro, in vec3 rd, in vec3 bgcol) {\n  vec4 sum = vec4(0.0);\n  float t = 0.0;\n  MARCH(30,map5);\n  MARCH(30,map4);\n  MARCH(30,map3);\n  MARCH(30,map2);\n  return clamp(sum, 0.0, 1.0);\n}\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize(cross(cw,cp));\n  vec3 cv = normalize(cross(cu,cw));\n  return mat3(cu, cv, cw);\n}\nvec4 render(in vec3 ro, in vec3 rd) {\n  float sun = clamp(dot(sundir,rd), 0.0, 1.0);\n  vec3 col = vec3(0.6,0.71,0.75) - rd.y*0.2*vec3(1.0,0.5,1.0) + 0.15*0.5;\n  col += 0.2*vec3(1.0,0.6,0.1)*pow(sun,8.0);\n  vec4 res = raymarch(ro, rd, col);\n  col = col * (1.0-res.w) + res.xyz;\n  col += 0.2*vec3(1.0,0.4,0.2)*pow(sun,3.0);\n  return vec4(col, 1.0);\n}",testUniforms:{tNoise:{value:null}},tilingFrag:"vec4 c1 = texture2D(tDiffuse, pin.uv);\r\nvec4 c2 = texture2D(tDiffuse, pin.uv+vec2(0.5));\r\nfloat a1 = radialMask(pin.uv);\r\nfloat rm2 = radialMask(pin.uv+vec2(0.5));\r\nfloat lm2 = linearMask(pin.uv+vec2(0.5));\r\nfloat a2 = mix(lm2, rm2, cRadialMask);\r\nfloat a = a1+a2;\r\nfloat r = a1*c1.r/a + a2*c2.r/a;\r\nfloat g = a1*c1.g/a + a2*c2.g/a;\r\nfloat b = a1*c1.b/a + a2*c2.b/a;\r\npout.color = vec3(r,g,b);\r\n",tilingFragPars:"uniform float cRadialMask;\r\nfloat radialMask(in vec2 uv) {\r\n    vec2 p = abs(fract(uv) - vec2(0.5)) * 2.0;\r\n    return max(1.0-dot(p,p), 0.0001);\r\n}\r\nfloat linearMask(in vec2 uv) {\r\n    vec2 p = abs(fract(uv) - vec2(0.5));\r\n    return max((0.5-max(p.x,p.y)) / 0.5, 0.0001);\r\n}",tilingUniforms:{cRadialMask:{value:1}},toonFrag:"if (cToonEnable) {\r\n  vec3 dark = mix( vec3(0.0), vec3(0.5),  step(cToonDark, pout.color) ) ;\r\n  vec3 light = mix( dark, vec3(1.0),  step(cToonLight, pout.color) ) ;\r\n//   vec3 dark = mix( vec3(0.0), vec3( 1.0, 0.4, 0.0),  step(0.8, pout.color) ) ;\r\n//   vec3 light = mix( dark, vec3( 1.0, 0.8, 0.0),  step(0.95, pout.color) ) ;\r\n  pout.color = light;\r\n}",toonFragPars:"uniform bool cToonEnable;\r\nuniform float cToonDark;\r\nuniform float cToonLight;",toonUniforms:{cToonEnable:{value:!1},cToonDark:{value:.8},cToonLight:{value:.95}},trabeculumFrag:"vec2 camctrl = vec2(cCameraPan, cCameraTilt);\r\nif (camctrl.x+camctrl.y == 0.) camctrl.xy = vec2(0.5);\r\n\r\nfloat theta = (camctrl.x*2.-1.)*PI;\r\nfloat phi = (camctrl.y-.5)*PI;\r\nfloat t=3.*time, B=.07; theta += B*cos(t); phi += B*sin(t);\r\n\r\nvec3 cameraPos = vec3(sin(theta)*cos(phi), sin(phi), cos(theta)*cos(phi));\r\nvec3 cameraTarget = vec3(0.);\r\nvec3 ww = normalize(cameraPos - cameraTarget);\r\nvec3 uu = normalize(cross(vec3(0.,1.,0.), ww));\r\nvec3 vv = normalize(cross(ww,uu));\r\nvec2 q = 2.*(pin.uv - vec2(.5,.5));\r\nvec3 rayDir = normalize(q.x*uu + q.y*vv - 1.5*ww);\r\n\r\nvec3 col = vec3(0.);\r\nfloat transp=1., epsC = .01/2.;\r\nfloat l = .5;\r\nfloat density = cDensity * 200.;\r\nvec3 p = cameraPos + l*rayDir, p_=p;\r\nfor (int i=0; i<200; i++) {\r\n    if (float(i)>=density) break;\r\n    float Aloc = tweaknoise(p,true);\r\n    if (Aloc>0.01) {\r\n        float a = 2.*PI*float(i)/density;\r\n        vec3 c = .5+.5*cos(a+vec3(0.,2.*PI/3.,-2.*PI/3.)+time);\r\n        col += transp*c*Aloc;\r\n        col = clamp(col, 0., 1.);\r\n        transp *= 1.-Aloc;\r\n        if (transp<.001) break;\r\n    }\r\n    p += epsC*rayDir;\r\n}\r\nvec3 rgb = col+transp*skyColor;\r\nvec3 gray = vec3(rgb2gray(rgb));\r\npout.color = mix(gray, rgb, cColor);\r\n",trabeculumFragPars:"uniform float cDensity;\r\nuniform float cScale;\r\nuniform float cIntensity;\r\nuniform float cTrabeculumVariation;\r\nuniform float cCameraTilt;\r\nuniform float cCameraPan;\r\nuniform float cColor;\r\n\r\nconst vec3 skyColor = 0.*vec3(.7,.8,1.); const float skyTrsp = .5;\r\n\r\nfloat grad = .2/2., scale = 5., thresh = .5;\r\n\r\nvec3 hash13(float n) {\r\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\r\n}\r\nfloat hash31(vec3 n) {\r\n    return rand(n.x+10.*n.y+100.*n.z);\r\n}\r\nvec3 hash33(vec3 n) {\r\n    return hash13(n.x+10.*n.y+100.*n.z);\r\n}\r\nvec4 worley(vec3 p) {\r\n    vec4 d = vec4(1e15);\r\n    vec3 ip = floor(p);\r\n    for (float i=-1.;i<2.; i++) {\r\n        for (float j=-1.;j<2.;j++) {\r\n            for (float k=-1.;k<2.;k++) {\r\n                vec3 p0 = ip + vec3(i,j,k);\r\n                vec3 c  = hash33(p0)+p0-p;\r\n                float d0 = dot(c,c);\r\n                if      (d0<d.x) { d.yzw = d.xyz; d.x=d0; }\r\n                else if (d0<d.y) { d.zw  = d.yz;  d.y=d0; }\r\n                else if (d0<d.z) { d.w   = d.z;   d.z=d0; }\r\n                else if (d0<d.w) {                d.w=d0; }\r\n            }\r\n        }\r\n    }\r\n    return sqrt(d);\r\n}\r\n\r\nfloat tweaknoise(vec3 p, bool step) {\r\n    float d1 = smoothstep(grad/2., -grad/2., length(p)-.5);\r\n    float d2 = smoothstep(grad/1., -grad/1., abs(p.z)-.5);\r\n    float d= d1;\r\n    if (cTrabeculumVariation <= .0) d = (1.-d1)*d2;\r\n    if (cTrabeculumVariation >= 2.) d = d2;\r\n    if (d < .5) return 0.;\r\n    grad=.8;\r\n    scale = mix(2.,10.,cScale);\r\n    thresh = .5+.5*(cos(.5*time)+.36*cos(.5*3.*time))/1.36;\r\n    vec4 w = scale*worley(scale*p-vec3(0.,0.,3.*time));\r\n    float v = 1.-1./(1./(w.z-w.x)+1./(w.a-w.x));\r\n\r\n    if (cIntensity < 1.) {\r\n        return v*d*cIntensity;\r\n    } else {\r\n        return smoothstep(thresh-grad/2., thresh+grad/2., v*d);\r\n    }\r\n}\r\n",trabeculumUniforms:{cDensity:{value:1},cScale:{value:1},cIntensity:{value:1},cTrabeculumVariation:{value:2},cCameraTilt:{value:0},cCameraPan:{value:0},cColor:{value:1}},turbulentNoiseFrag:"vec2 p = pin.uv - time*0.1;\r\nfloat lum = fbm(p, cNoiseOctave, cNoiseFrequency * 128.0, cNoiseAmplitude);\r\npout.color = vec3(lum);\r\n\r\nfloat graph = fbm(p.xx, cNoiseOctave, cNoiseFrequency * 128.0, cNoiseAmplitude);",turbulentNoiseFragPars:"float fbm(vec2 v, int octaves, float frequency, float amplitude) {\r\n  const mat2 m = mat2( 0.00, 0.80, -0.80,  0.36 );\r\n  vec2 q = v;\r\n  float f = 0.0;\r\n  f  = 0.5000 * rpnoise(q, octaves, frequency, amplitude); q = m*q*2.01;\r\n  f += 0.2500 * rpnoise(q, octaves, frequency, amplitude); q = m*q*2.02;\r\n  f += 0.1250 * rpnoise(q, octaves, frequency, amplitude); q = m*q*2.03;\r\n  f += 0.0625 * rpnoise(q, octaves, frequency, amplitude);\r\n\r\n  f = f*1.2 + 0.5;\r\n//   f = sqrt(f);\r\n  return f;\r\n}",vert:"attribute vec3 position;\r\nvoid main() {\r\n  gl_Position = vec4(position, 1.0);\r\n}",voronoiNoiseFrag:"vec2 p = pin.uv - time*0.1;\r\nfloat lum = iqnoise(p * 48.0 * cNoiseFrequency, 1.0, 0.0);\r\npout.color = vec3(lum);\r\n\r\nfloat graph = iqnoise(p.xx * 48.0 * cNoiseFrequency, 1.0, 0.0);",voronoiNoiseFragPars:"// dummy",waterCircleWaveFrag:"const float period = 0.2;\r\nconst float amp = 0.05;\r\nconst float lambda = 0.5;\r\nfloat r = sqrt(pow2(pin.position.x) + pow2(pin.position.y));\r\nfloat phase = 2.0 * PI * (time/period - r/lambda);\r\nif (phase >= 0.0 && phase < 2.0*PI) {\r\n  pout.color = vec3((amp * sin(phase)) / sqrt(r));\r\n} else {\r\n  pout.color = vec3(0.0);\r\n}",waterPlaneWaveFrag:"const float period = 0.2;\r\nconst float amp = 0.05;\r\nconst float lambda = 0.5;\r\nfloat r = sqrt(pow2(pin.position.x) + pow2(pin.position.y));\r\nfloat phase = 2.0 * PI * (time/period - pin.position.x/lambda - pin.position.y/lambda);\r\nif (phase >= 0.0 && phase < 2.0*PI) {\r\n  pout.color = vec3((amp * sin(phase)));\r\n} else {\r\n  pout.color = vec3(0.0);\r\n}",waterTurbulenceFrag:"vec2 p = pin.position * mix(2.0,15.0,cScale);\r\nfloat c = Turb(p);\r\npout.color = vec3(c);",waterTurbulenceFragPars:"uniform float cScale;\r\nuniform float cIntensity;\r\n\r\n#define MAX_ITER 2.0\r\n\r\nfloat Turb(vec2 p) {\r\n    vec2 i = p;\r\n    float c = 0.0;\r\n    float inten = cIntensity;\r\n    float r = length(p + vec2(sin(time), sin(time*0.433+2.))*3.);\r\n    for (float n=0.0; n<MAX_ITER; n++) {\r\n        float t = r-time * (1.0 - (1.9/(n+1.)));\r\n        t = r-time/(n+.6);//r-time*(1.+.5/float(n+1.)));\r\n        i -= p + vec2(\r\n            cos(t-i.x-r)+sin(t+i.y),\r\n            sin(t-i.y)+cos(t+i.x)+r);\r\n            c += 1./length(vec2(sin(i.x+t)/inten, cos(i.y+t)/inten));\r\n    }\r\n    c /= float(MAX_ITER);\r\n    c = clamp(c,-1.,1.);\r\n    return c;\r\n}",waterTurbulenceUniforms:{cScale:{value:.5},cIntensity:{value:.15}},waveRingFrag:"float u = sin((atan(pin.position.y, pin.position.x) + time * 0.5) * floor(cFrequency)) * cAmplitude;\r\nfloat t = cWidth / abs(cRadius + u - length(pin.position));\r\nt = pow(abs(t), cPowerExponent);\r\npout.color = vec3(t);",waveRingFragPars:"uniform float cRadius;\r\nuniform float cWidth;\r\nuniform float cFrequency;\r\nuniform float cAmplitude;\r\nuniform float cPowerExponent;",waveRingUniforms:{cRadius:{value:.5},cWidth:{value:.01},cFrequency:{value:20},cAmplitude:{value:.01},cPowerExponent:{value:1}},woodFrag:"float t = sin(length(pin.position) * cFrequency + time * 5.0);\r\n// float t = sin(length(pin.mouse - pin.position) * 30.0 + time * 5.0);\r\nt = pow(t, cPowerExponent);\r\npout.color = vec3(t);",woodFragPars:"uniform float cFrequency;\r\nuniform float cPowerExponent;",woodUniforms:{cFrequency:{value:30},cPowerExponent:{value:1}}};class er{constructor(){this.enables={}}enable(r,e){this.enables[r]=void 0===e?1:e}clear(){this.enables={}}checkKey(r){for(let e in this.enables)if(e===r)return!0;return!1}check(r){if(null===r||0===r.length)return!0;let e=0;for(let n in r)if("-"===r[n][0]){if(this.checkKey(r[n].substr(1)))return!1}else if("+"===r[n][0])0===e&&(e=1),this.checkKey(r[n].substr(1))&&(e=2);else if(!1===this.checkKey(r[n]))return!1;return!(e>0&&e<2)}generateDefines(){return{NOISE_OCTAVE:8,NOISE_PERSISTENCE:.5}}addUniform(r,e,n){this.check(e)&&r.push(rr[n])}generateUniforms(){const e=[];return e.push({resolution:{value:new r.Vector2},mouse:{value:new r.Vector2},time:{value:0},cameraPos:{value:new r.Vector3},cameraDir:{value:new r.Vector3},tDiffuse:{value:null}}),this.addUniform(e,[],"noiseUniforms"),this.addUniform(e,["DISPLACEMENT"],"displacementUniforms"),this.addUniform(e,["WOOD"],"woodUniforms"),this.addUniform(e,["CIRCLE"],"circleUniforms"),this.addUniform(e,["SOLAR"],"solarUniforms"),this.addUniform(e,["SPARK"],"sparkUniforms"),this.addUniform(e,["RING"],"ringUniforms"),this.addUniform(e,["GRADATION"],"gradationUniforms"),this.addUniform(e,["GRADATIONLINE"],"gradationLineUniforms"),this.addUniform(e,["FLASH"],"flashUniforms"),this.addUniform(e,["CONE"],"coneUniforms"),this.addUniform(e,["FLOWER"],"flowerUniforms"),this.addUniform(e,["FLOWERFUN"],"flowerFunUniforms"),this.addUniform(e,["WAVERING"],"waveRingUniforms"),this.addUniform(e,["FBMNOISE2"],"fbmNoise2Uniforms"),this.addUniform(e,["FBMNOISE3"],"fbmNoise3Uniforms"),this.addUniform(e,["SEEMLESSNOISE"],"seemlessNoiseUniforms"),this.addUniform(e,["MARBLENOISE"],"marbleNoiseUniforms"),this.addUniform(e,["TESSNOISE"],"tessNoiseUniforms"),this.addUniform(e,["GRADIENTNOISE"],"gradientNoiseUniforms"),this.addUniform(e,["+HEIGHT2NORMAL","+HEIGHT2NORMALSOBEL"],"height2NormalUniforms"),this.addUniform(e,["COLORBALANCE"],"colorBalanceUniforms"),this.addUniform(e,["SMOKE"],"smokeUniforms"),this.addUniform(e,["CELL"],"cellUniforms"),this.addUniform(e,["FLAME"],"flameUniforms"),this.addUniform(e,["FLAMEEYE"],"flameEyeUniforms"),this.addUniform(e,["FIRE"],"fireUniforms"),this.addUniform(e,["LIGHTNING"],"lightningUniforms"),this.addUniform(e,["FLARE"],"flareUniforms"),this.addUniform(e,["FLARE2"],"flare2Uniforms"),this.addUniform(e,["FLARE3"],"flare3Uniforms"),this.addUniform(e,["MAGICCIRCLE"],"magicCircleUniforms"),this.addUniform(e,["CROSS"],"crossUniforms"),this.addUniform(e,["EXPLOSION"],"explosionUniforms"),this.addUniform(e,["EXPLOSION2"],"explosion2Uniforms"),this.addUniform(e,["CORONA"],"coronaUniforms"),this.addUniform(e,["LENSFLARE"],"lensFlareUniforms"),this.addUniform(e,["SUN"],"sunUniforms"),this.addUniform(e,["LASER"],"laserUniforms"),this.addUniform(e,["LASER2"],"laser2Uniforms"),this.addUniform(e,["LIGHT"],"lightUniforms"),this.addUniform(e,["CLOUD"],"cloudUniforms"),this.addUniform(e,["CLOUD2"],"cloud2Uniforms"),this.addUniform(e,["CLOUDS"],"cloudsUniforms"),this.addUniform(e,["MANDARA"],"mandaraUniforms"),this.addUniform(e,["TOON"],"toonUniforms"),this.addUniform(e,["CHECKER"],"checkerUniforms"),this.addUniform(e,["FLAMELANCE"],"flamelanceUniforms"),this.addUniform(e,["BONFIRE"],"bonfireUniforms"),this.addUniform(e,["SNOW"],"snowUniforms"),this.addUniform(e,["DIAMONDGEAR"],"diamondGearUniforms"),this.addUniform(e,["BRUSHSTROKE"],"brushStrokeUniforms"),this.addUniform(e,["SPECKLE"],"speckleUniforms"),this.addUniform(e,["BUBBLES"],"bubblesUniforms"),this.addUniform(e,["PENTAGON"],"pentagonUniforms"),this.addUniform(e,["GRUNGE"],"grungeUniforms"),this.addUniform(e,["ENERGY"],"energyUniforms"),this.addUniform(e,["INKSPLAT"],"inksplatUniforms"),this.addUniform(e,["PARTICLE"],"particleUniforms"),this.addUniform(e,["ELECTRIC"],"electricUniforms"),this.addUniform(e,["TILING"],"tilingUniforms"),this.addUniform(e,["CAUSTICS"],"causticsUniforms"),this.addUniform(e,["SQUIGGLES"],"squigglesUniforms"),this.addUniform(e,["WATERTURBULENCE"],"waterTurbulenceUniforms"),this.addUniform(e,["TRABECULUM"],"trabeculumUniforms"),this.addUniform(e,["TEST"],"testUniforms"),r.UniformsUtils.clone(r.UniformsUtils.merge(e))}addCode(r,e,n){this.check(e)&&(r.push("//[ "+n+" ]"),r.push(rr[n]),r.push("// "+n))}generateVertexShader(){const r=[];return this.addCode(r,["GLSL3"],"glsl3Vert"),this.addCode(r,["DISPLACEMENT"],"displacementVert"),this.addCode(r,["-DISPLACEMENT"],"vert"),r.join("\n")}generateFragmentShader(){const r=[];return this.addCode(r,["GLSL3"],"glsl3Frag"),this.addCode(r,[],"common"),this.addCode(r,[],"color"),this.addCode(r,[],"gradient"),this.addCode(r,[],"noise"),this.addCode(r,[],"raymarch"),this.addCode(r,[],"fragPars"),this.addCode(r,["DISPLACEMENT"],"displacementFragPars"),this.addCode(r,["WOOD"],"woodFragPars"),this.addCode(r,["CIRCLE"],"circleFragPars"),this.addCode(r,["SOLAR"],"solarFragPars"),this.addCode(r,["SPARK"],"sparkFragPars"),this.addCode(r,["RING"],"ringFragPars"),this.addCode(r,["GRADATION"],"gradationFragPars"),this.addCode(r,["GRADATIONLINE"],"gradationLineFragPars"),this.addCode(r,["FLASH"],"flashFragPars"),this.addCode(r,["CONE"],"coneFragPars"),this.addCode(r,["FLOWER"],"flowerFragPars"),this.addCode(r,["FLOWERFUN"],"flowerFunFragPars"),this.addCode(r,["WAVERING"],"waveRingFragPars"),this.addCode(r,["BOOLEANNOISE"],"booleanNoiseFragPars"),this.addCode(r,["CELLNOISE"],"cellNoiseFragPars"),this.addCode(r,["FBMNOISE"],"fbmNoiseFragPars"),this.addCode(r,["FBMNOISE2"],"fbmNoise2FragPars"),this.addCode(r,["FBMNOISE3"],"fbmNoise3FragPars"),this.addCode(r,["VORONOINOISE"],"voronoiNoiseFragPars"),this.addCode(r,["TURBULENTNOISE"],"turbulentNoiseFragPars"),this.addCode(r,["SPARKNOISE"],"sparkNoiseFragPars"),this.addCode(r,["RANDOMNOISE"],"randomNoiseFragPars"),this.addCode(r,["SEEMLESSNOISE"],"seemlessNoiseFragPars"),this.addCode(r,["TESSNOISE"],"tessNoiseFragPars"),this.addCode(r,["GRADIENTNOISE"],"gradientNoiseFragPars"),this.addCode(r,["+HEIGHT2NORMAL","+HEIGHT2NORMALSOBEL"],"height2NormalFragPars"),this.addCode(r,["COLORBALANCE"],"colorBalanceFragPars"),this.addCode(r,["POLARCONVERSION"],"polarConversionFragPars"),this.addCode(r,["SMOKE"],"smokeFragPars"),this.addCode(r,["FLAME"],"flameFragPars"),this.addCode(r,["FLAMEEYE"],"flameEyeFragPars"),this.addCode(r,["FIRE"],"fireFragPars"),this.addCode(r,["CELL"],"cellFragPars"),this.addCode(r,["LIGHTNING"],"lightningFragPars"),this.addCode(r,["FLARE"],"flareFragPars"),this.addCode(r,["FLARE2"],"flare2FragPars"),this.addCode(r,["FLARE3"],"flare3FragPars"),this.addCode(r,["MAGICCIRCLE"],"magicCircleFragPars"),this.addCode(r,["CROSS"],"crossFragPars"),this.addCode(r,["EXPLOSION"],"explosionFragPars"),this.addCode(r,["EXPLOSION2"],"explosion2FragPars"),this.addCode(r,["CORONA"],"coronaFragPars"),this.addCode(r,["LENSFLARE"],"lensFlareFragPars"),this.addCode(r,["SUN"],"sunFragPars"),this.addCode(r,["LASER"],"laserFragPars"),this.addCode(r,["LASER2"],"laser2FragPars"),this.addCode(r,["LIGHT"],"lightFragPars"),this.addCode(r,["CLOUD"],"cloudFragPars"),this.addCode(r,["CLOUD2"],"cloud2FragPars"),this.addCode(r,["CLOUDS"],"cloudsFragPars"),this.addCode(r,["MANDARA"],"mandaraFragPars"),this.addCode(r,["TOON"],"toonFragPars"),this.addCode(r,["CHECKER"],"checkerFragPars"),this.addCode(r,["MARBLENOISE"],"marbleNoiseFragPars"),this.addCode(r,["FLAMELANCE"],"flamelanceFragPars"),this.addCode(r,["BONFIRE"],"bonfireFragPars"),this.addCode(r,["SNOW"],"snowFragPars"),this.addCode(r,["DIAMONDGEAR"],"diamondGearFragPars"),this.addCode(r,["BRUSHSTROKE"],"brushStrokeFragPars"),this.addCode(r,["SPECKLE"],"speckleFragPars"),this.addCode(r,["BUBBLES"],"bubblesFragPars"),this.addCode(r,["PENTAGON"],"pentagonFragPars"),this.addCode(r,["GRUNGE"],"grungeFragPars"),this.addCode(r,["ENERGY"],"energyFragPars"),this.addCode(r,["INKSPLAT"],"inksplatFragPars"),this.addCode(r,["PARTICLE"],"particleFragPars"),this.addCode(r,["ELECTRIC"],"electricFragPars"),this.addCode(r,["TILING"],"tilingFragPars"),this.addCode(r,["CAUSTICS"],"causticsFragPars"),this.addCode(r,["SQUIGGLES"],"squigglesFragPars"),this.addCode(r,["WATERTURBULENCE"],"waterTurbulenceFragPars"),this.addCode(r,["TRABECULUM"],"trabeculumFragPars"),this.addCode(r,["TEST"],"testFragPars"),r.push(""),r.push("void main() {"),this.addCode(r,[],"frag"),this.addCode(r,["DISPLACEMENT"],"displacementFrag"),this.addCode(r,["WOOD"],"woodFrag"),this.addCode(r,["CIRCLE"],"circleFrag"),this.addCode(r,["SOLAR"],"solarFrag"),this.addCode(r,["SPARK"],"sparkFrag"),this.addCode(r,["RING"],"ringFrag"),this.addCode(r,["GRADATION"],"gradationFrag"),this.addCode(r,["GRADATIONLINE"],"gradationLineFrag"),this.addCode(r,["FLASH"],"flashFrag"),this.addCode(r,["CONE"],"coneFrag"),this.addCode(r,["FLOWER"],"flowerFrag"),this.addCode(r,["FLOWERFUN"],"flowerFunFrag"),this.addCode(r,["WAVERING"],"waveRingFrag"),this.addCode(r,["PERLINNOISE"],"perlinNoiseFrag"),this.addCode(r,["BOOLEANNOISE"],"booleanNoiseFrag"),this.addCode(r,["CELLNOISE"],"cellNoiseFrag"),this.addCode(r,["FBMNOISE"],"fbmNoiseFrag"),this.addCode(r,["FBMNOISE2"],"fbmNoise2Frag"),this.addCode(r,["FBMNOISE3"],"fbmNoise3Frag"),this.addCode(r,["VORONOINOISE"],"voronoiNoiseFrag"),this.addCode(r,["TURBULENTNOISE"],"turbulentNoiseFrag"),this.addCode(r,["SPARKNOISE"],"sparkNoiseFrag"),this.addCode(r,["RANDOMNOISE"],"randomNoiseFrag"),this.addCode(r,["MANDELBLOT"],"mandelblotFrag"),this.addCode(r,["JULIA"],"juliaFrag"),this.addCode(r,["SEEMLESSNOISE"],"seemlessNoiseFrag"),this.addCode(r,["MARBLENOISE"],"marbleNoiseFrag"),this.addCode(r,["TESSNOISE"],"tessNoiseFrag"),this.addCode(r,["GRADIENTNOISE"],"gradientNoiseFrag"),this.addCode(r,["+PERLINNOISE","+BOOLEANNOISE","+CELLNOISE","+FBMNOISE","+FBMNOISE2","+FBMNOISE3","+VORONOINOISE","+TURBULENTNOISE","+SPARKNOISE","+RANDOMNOISE","+SEEMLESSNOISE","+MARBLENOISE","+TESSNOISE","+GRADIENTNOISE"],"noiseGraphFrag"),this.addCode(r,["HEIGHT2NORMAL"],"height2NormalFrag"),this.addCode(r,["HEIGHT2NORMALSOBEL"],"height2NormalSobelFrag"),this.addCode(r,["POLARCONVERSION"],"polarConversionFrag"),this.addCode(r,["COLORBALANCE"],"colorBalanceFrag"),this.addCode(r,["SMOKE"],"smokeFrag"),this.addCode(r,["FLAME"],"flameFrag"),this.addCode(r,["FLAMEEYE"],"flameEyeFrag"),this.addCode(r,["FIRE"],"fireFrag"),this.addCode(r,["CELL"],"cellFrag"),this.addCode(r,["LIGHTNING"],"lightningFrag"),this.addCode(r,["FLARE"],"flareFrag"),this.addCode(r,["FLARE2"],"flare2Frag"),this.addCode(r,["FLARE3"],"flare3Frag"),this.addCode(r,["MAGICCIRCLE"],"magicCircleFrag"),this.addCode(r,["CROSS"],"crossFrag"),this.addCode(r,["EXPLOSION"],"explosionFrag"),this.addCode(r,["EXPLOSION2"],"explosion2Frag"),this.addCode(r,["CORONA"],"coronaFrag"),this.addCode(r,["LENSFLARE"],"lensFlareFrag"),this.addCode(r,["SUN"],"sunFrag"),this.addCode(r,["LASER"],"laserFrag"),this.addCode(r,["LASER2"],"laser2Frag"),this.addCode(r,["LIGHT"],"lightFrag"),this.addCode(r,["CLOUD"],"cloudFrag"),this.addCode(r,["CLOUD2"],"cloud2Frag"),this.addCode(r,["CLOUDS"],"cloudsFrag"),this.addCode(r,["MANDARA"],"mandaraFrag"),this.addCode(r,["COPY"],"copyFrag"),this.addCode(r,["CHECKER"],"checkerFrag"),this.addCode(r,["FLAMELANCE"],"flamelanceFrag"),this.addCode(r,["BONFIRE"],"bonfireFrag"),this.addCode(r,["SNOW"],"snowFrag"),this.addCode(r,["DIAMONDGEAR"],"diamondGearFrag"),this.addCode(r,["BRUSHSTROKE"],"brushStrokeFrag"),this.addCode(r,["SPECKLE"],"speckleFrag"),this.addCode(r,["BUBBLES"],"bubblesFrag"),this.addCode(r,["PENTAGON"],"pentagonFrag"),this.addCode(r,["GRUNGE"],"grungeFrag"),this.addCode(r,["ENERGY"],"energyFrag"),this.addCode(r,["INKSPLAT"],"inksplatFrag"),this.addCode(r,["PARTICLE"],"particleFrag"),this.addCode(r,["ELECTRIC"],"electricFrag"),this.addCode(r,["TILING"],"tilingFrag"),this.addCode(r,["CAUSTICS"],"causticsFrag"),this.addCode(r,["SQUIGGLES"],"squigglesFrag"),this.addCode(r,["WATERTURBULENCE"],"waterTurbulenceFrag"),this.addCode(r,["TRABECULUM"],"trabeculumFrag"),this.addCode(r,["BINARYMATRIX"],"binaryMatrixFrag"),this.addCode(r,["TEST"],"testFrag"),this.addCode(r,["TOON"],"toonFrag"),this.addCode(r,[],"fragEnd"),r.push("}"),r.join("\n")}createMaterial(e){const n=new r.RawShaderMaterial({uniforms:e,vertexShader:this.generateVertexShader(),fragmentShader:this.generateFragmentShader()});return this.check(["GLSL3"])&&(n.glslVersion=r.GLSL3),this.check(["INKSPLAT"])&&(n.extensions.derivatives=!0),n}createMaterial(e,n){const t=new r.RawShaderMaterial(Object.assign({uniforms:e,vertexShader:this.generateVertexShader(),fragmentShader:this.generateFragmentShader()},n));return this.check(["GLSL3"])&&(t.glslVersion=r.GLSL3),this.check(["INKSPLAT"])&&(t.extensions.derivatives=!0),t}createStandardMaterial(e){return new r.ShaderMaterial({uniforms:e,vertexShader:this.generateVertexShader(),fragmentShader:this.generateFragmentShader()})}}const nr={SetShaderParameter(e,n,t){if(n in e)if(e[n].value instanceof r.Color)t instanceof r.Color?e[n].value.copy(t):e[n].value.copy(new r.Color(t));else if(e[n].value instanceof r.Color||e[n].value instanceof r.Vector2||e[n].value instanceof r.Vector3||e[n].value instanceof r.Vector4||e[n].value instanceof r.Matrix3||e[n].value instanceof r.Matrix4)e[n].value.copy(t);else if(e[n].value instanceof r.CubeTexture||e[n].value instanceof r.Texture)e[n].value=t;else if(e[n].value instanceof Array)for(let r=0;r<t.length;++r)e[n].value[r]=t[r];else e[n].value=t},SetShaderArrayParameter(e,n,t,o,a){if(n in e&&o in e[n].value[t])if(e[n].value[t][o]instanceof r.Color||e[n].value[t][o]instanceof r.Vector2||e[n].value[t][o]instanceof r.Vector3||e[n].value[t][o]instanceof r.Vector4||e[n].value[t][o]instanceof r.Matrix3||e[n].value[t][o]instanceof r.Matrix4)e[n].value[t][o].copy(a);else if(e[n].value[t][o]instanceof r.CubeTexture||e[n].value[t][o]instanceof r.Texture)e[n].value[t][o]=a;else if(e[n].value[t][o]instanceof Array)for(let r=0;r<a.length;++r)e[n].value[t][o][r]=a[r];else e[n].value[t][o]=a},GetDefaultShaderParameters:()=>({time:0})};export{o as AreaLight,z as ClearMaskPass,A as ClearPass,E as Composer,G as CopyPass,H as EdgePass,er as FxgenShader,nr as FxgenShaderUtils,M as GPUParticle,R as HeightField,I as MaskPass,D as Ocean,T as Pass,i as RectLight,_ as RenderPass,k as SSAARenderPass,$ as SSAOPass,V as ScreenPass,U as ScreenSprite,s as Shader,n as ShaderChunk,l as ShaderLib,O as ShaderPass,t as ShaderUtils,F as ShadowMesh,P as Solar,q as TAARenderPass,a as TubeLight,B as UnrealBloomPass,j as ViewAlpha,K as ViewB,J as ViewDecodeDepth,Z as ViewDecodeRGB,Q as ViewDepth,Y as ViewG,X as ViewR,W as ViewRGB,f as all,c as any,p as buildGause,h as buildKernel,y as clearTextOut,g as createPlaneReflectMatrix,x as createShadowedLight,u as degrees,S as dumpMatrix4,C as floatFormat,m as gauss,v as pow2,d as radians,w as textOut,b as textOutMatrix4};
